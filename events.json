{
  "code": 0,
  "message": "Success",
  "generated_at": 1652474440,
  "data": {
    "info": {
      "metadata": [
        {
          "name": "System",
          "prefix": "System",
          "storage": [
            {
              "name": "Account",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "frame_system:AccountInfo",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " The full account information for a particular account ID."
              ]
            },
            {
              "name": "ExtrinsicCount",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00",
              "docs": [
                " Total extrinsics count for the current block."
              ]
            },
            {
              "name": "BlockWeight",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "frame_support:weights:PerDispatchClass",
                "PlainTypeValue": 7
              },
              "fallback": "0x000000000000000000000000000000000000000000000000",
              "docs": [
                " The current weight for the block."
              ]
            },
            {
              "name": "AllExtrinsicsLen",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00",
              "docs": [
                " Total length (in bytes) for all extrinsics put together, for the current block."
              ]
            },
            {
              "name": "BlockHash",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "U32"
                  ],
                  "value": "H256",
                  "keys_id": 4,
                  "value_id": 0
                }
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " Map of block numbers to block hashes."
              ]
            },
            {
              "name": "ExtrinsicData",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "U32"
                  ],
                  "value": "Vec\u003cU8\u003e",
                  "keys_id": 4,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Extrinsics data for the current block (maps an extrinsic's index to its data)."
              ]
            },
            {
              "name": "Number",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " The current block number being processed. Set by `execute_block`."
              ]
            },
            {
              "name": "ParentHash",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "H256",
                "PlainTypeValue": 9
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " Hash of the previous block."
              ]
            },
            {
              "name": "Digest",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003csp_runtime:generic:digest:DigestItem\u003e",
                "PlainTypeValue": 11
              },
              "fallback": "0x00",
              "docs": [
                " Digest of the current block, also part of the block header."
              ]
            },
            {
              "name": "Events",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cframe_system:EventRecord\u003e",
                "PlainTypeValue": 15
              },
              "fallback": "0x00",
              "docs": [
                " Events deposited for the current block.",
                "",
                " NOTE: This storage item is explicitly unbounded since it is never intended to be read",
                " from within the runtime."
              ]
            },
            {
              "name": "EventCount",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " The number of events in the `Events\u003cT\u003e` list."
              ]
            },
            {
              "name": "EventTopics",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "H256"
                  ],
                  "value": "Vec\u003cTuple:U32U32\u003e",
                  "keys_id": 9,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Mapping between a topic (represented by T::Hash) and a vector of indexes",
                " of events in the `\u003cEvents\u003cT\u003e\u003e` list.",
                "",
                " All topic vectors have deterministic storage locations depending on the topic. This",
                " allows light-clients to leverage the changes trie storage tracking mechanism and",
                " in case of changes fetch the list of events of interest.",
                "",
                " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just",
                " the `EventIndex` then in case if the topic has the same contents on the next block",
                " no notification will be triggered thus the event might be lost."
              ]
            },
            {
              "name": "LastRuntimeUpgrade",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "frame_system:LastRuntimeUpgradeInfo",
                "PlainTypeValue": 136
              },
              "fallback": "0x00",
              "docs": [
                " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."
              ]
            },
            {
              "name": "UpgradedToU32RefCount",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Bool",
                "PlainTypeValue": 68
              },
              "fallback": "0x00",
              "docs": [
                " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."
              ]
            },
            {
              "name": "UpgradedToTripleRefCount",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Bool",
                "PlainTypeValue": 68
              },
              "fallback": "0x00",
              "docs": [
                " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False",
                " (default) if not."
              ]
            },
            {
              "name": "ExecutionPhase",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "frame_system:Phase",
                "PlainTypeValue": 133
              },
              "fallback": "0x00",
              "docs": [
                " The execution phase of the block."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "0000",
              "name": "fill_block",
              "docs": [
                "A dispatch that will fill the block weight up to the given ratio."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "ratio",
                  "type": "U32",
                  "type_name": "Perbill"
                }
              ]
            },
            {
              "lookup": "0001",
              "name": "remark",
              "docs": [
                "Make some on-chain remark.",
                "",
                "# \u003cweight\u003e",
                "- `O(1)`",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "remark",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "0002",
              "name": "set_heap_pages",
              "docs": [
                "Set the number of pages in the WebAssembly environment's heap."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "pages",
                  "type": "U64",
                  "type_name": "u64"
                }
              ]
            },
            {
              "lookup": "0003",
              "name": "set_code",
              "docs": [
                "Set the new runtime code.",
                "",
                "# \u003cweight\u003e",
                "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`",
                "- 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is",
                "  expensive).",
                "- 1 storage write (codec `O(C)`).",
                "- 1 digest item.",
                "- 1 event.",
                "The weight of this function is dependent on the runtime, but generally this is very",
                "expensive. We will treat this as a full block.",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "code",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "0004",
              "name": "set_code_without_checks",
              "docs": [
                "Set the new runtime code without doing any checks of the given `code`.",
                "",
                "# \u003cweight\u003e",
                "- `O(C)` where `C` length of `code`",
                "- 1 storage write (codec `O(C)`).",
                "- 1 digest item.",
                "- 1 event.",
                "The weight of this function is dependent on the runtime. We will treat this as a full",
                "block. # \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "code",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "0005",
              "name": "set_storage",
              "docs": [
                "Set some items of storage."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "items",
                  "type": "Vec\u003cTuple:Vec\u003cU8\u003eVec\u003cU8\u003e\u003e",
                  "type_name": "Vec\u003cKeyValue\u003e"
                }
              ]
            },
            {
              "lookup": "0006",
              "name": "kill_storage",
              "docs": [
                "Kill some items from storage."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "keys",
                  "type": "Vec\u003cVec\u003cU8\u003e\u003e",
                  "type_name": "Vec\u003cKey\u003e"
                }
              ]
            },
            {
              "lookup": "0007",
              "name": "kill_prefix",
              "docs": [
                "Kill all storage items with a key that starts with the given prefix.",
                "",
                "**NOTE:** We rely on the Root origin to provide us the number of subkeys under",
                "the prefix we are removing to accurately calculate the weight of this function."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "prefix",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Key"
                },
                {
                  "TypeName": "",
                  "name": "subkeys",
                  "type": "U32",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "0008",
              "name": "remark_with_event",
              "docs": [
                "Make some on-chain remark and emit event."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "remark",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 138
          },
          "events": [
            {
              "lookup": "0000",
              "name": "ExtrinsicSuccess",
              "docs": [
                "An extrinsic completed successfully."
              ],
              "args": [
                "frame_support:weights:DispatchInfo"
              ],
              "args_type_name": [
                "DispatchInfo"
              ]
            },
            {
              "lookup": "0001",
              "name": "ExtrinsicFailed",
              "docs": [
                "An extrinsic failed."
              ],
              "args": [
                "sp_runtime:DispatchError",
                "frame_support:weights:DispatchInfo"
              ],
              "args_type_name": [
                "DispatchError",
                "DispatchInfo"
              ]
            },
            {
              "lookup": "0002",
              "name": "CodeUpdated",
              "docs": [
                "`:code` was updated."
              ],
              "args": null
            },
            {
              "lookup": "0003",
              "name": "NewAccount",
              "docs": [
                "A new account was created."
              ],
              "args": [
                "[U8; 32]"
              ],
              "args_type_name": [
                "AccountId"
              ]
            },
            {
              "lookup": "0004",
              "name": "KilledAccount",
              "docs": [
                "An account was reaped."
              ],
              "args": [
                "[U8; 32]"
              ],
              "args_type_name": [
                "AccountId"
              ]
            },
            {
              "lookup": "0005",
              "name": "Remarked",
              "docs": [
                "On on-chain remark happened."
              ],
              "args": [
                "[U8; 32]",
                "H256"
              ],
              "args_type_name": [
                "AccountId",
                "Hash"
              ]
            }
          ],
          "events_value": {
            "type": 18
          },
          "constants": [
            {
              "name": "BlockWeights",
              "type": "frame_system:limits:BlockWeights",
              "type_value": 143,
              "constants_value": "00f2052a0100000000204aa9d1010000405973070000000001c06e96a62e010000010098f73e5d010000010000000000000000405973070000000001c0f6e810a30100000100204aa9d1010000010088526a740000004059730700000000000000",
              "docs": [
                " Block \u0026 extrinsics weights: base values and limits."
              ]
            },
            {
              "name": "BlockLength",
              "type": "frame_support:weights:PerDispatchClass@148",
              "type_value": 147,
              "constants_value": "00003c000000500000005000",
              "docs": [
                " The maximum length of a block (in bytes)."
              ]
            },
            {
              "name": "BlockHashCount",
              "type": "U32",
              "type_value": 4,
              "constants_value": "fa000000",
              "docs": [
                " Maximum number of block number to block hash mappings to keep (oldest pruned first)."
              ]
            },
            {
              "name": "DbWeight",
              "type": "frame_support:weights:RuntimeDbWeight",
              "type_value": 149,
              "constants_value": "00000000000000000000000000000000",
              "docs": [
                " The weight of runtime database operations the runtime can invoke."
              ]
            },
            {
              "name": "Version",
              "type": "sp_version:RuntimeVersion",
              "type_value": 150,
              "constants_value": "486b696e74737567692d70617261636861696e486b696e74737567692d70617261636861696e010000000f0000000100000048df6acb689907609b0400000037e397fc7c91f5e40100000040fe3ad401f8959a05000000d2bc9897eed08f1503000000f78b278be53f454c02000000ab3c0572291feb8b01000000dd718d5cc53262d401000000ea93e3f16f3d696202000000bc9d89904f5b923f0100000037c8bb1350a9a2a801000000c6b106fa1a388380010000006ef953004ba30e5901000000c36ab59434ab90e90100000016da96d36c6d5bb701000000caf39b979a6880bd0100000069e2e1aa421f4fb00100000091d2aba1dfca2e06010000002be5cb02b0a56e73010000000300000000",
              "docs": [
                " Get the chain's current version."
              ]
            },
            {
              "name": "SS58Prefix",
              "type": "U16",
              "type_value": 154,
              "constants_value": "2c08",
              "docs": [
                " The designated SS85 prefix of this chain.",
                "",
                " This replaces the \"ss58Format\" property declared in the chain spec. Reason is",
                " that the runtime should know about the prefix in order to make use of it as",
                " an identifier of the chain."
              ]
            }
          ],
          "errors": [
            {
              "name": "InvalidSpecName",
              "doc": [
                "The name of specification does not match between the current runtime",
                "and the new runtime."
              ]
            },
            {
              "name": "SpecVersionNeedsToIncrease",
              "doc": [
                "The specification version is not allowed to decrease between the current runtime",
                "and the new runtime."
              ]
            },
            {
              "name": "FailedToExtractRuntimeVersion",
              "doc": [
                "Failed to extract the runtime version from the new runtime.",
                "",
                "Either calling `Core_version` or decoding `RuntimeVersion` failed."
              ]
            },
            {
              "name": "NonDefaultComposite",
              "doc": [
                "Suicide called when the account has non-default composite data."
              ]
            },
            {
              "name": "NonZeroRefCount",
              "doc": [
                "There is a non-zero reference count preventing the account from being purged."
              ]
            },
            {
              "name": "CallFiltered",
              "doc": [
                "The origin filter prevent the call to be dispatched."
              ]
            }
          ],
          "errors_value": {
            "type": 155
          },
          "index": 0
        },
        {
          "name": "Timestamp",
          "prefix": "Timestamp",
          "storage": [
            {
              "name": "Now",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U64",
                "PlainTypeValue": 8
              },
              "fallback": "0x0000000000000000",
              "docs": [
                " Current time for the current block."
              ]
            },
            {
              "name": "DidUpdate",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Bool",
                "PlainTypeValue": 68
              },
              "fallback": "0x00",
              "docs": [
                " Did the timestamp get updated in this block?"
              ]
            }
          ],
          "calls": [
            {
              "lookup": "0100",
              "name": "set",
              "docs": [
                "Set the current time.",
                "",
                "This call should be invoked exactly once per block. It will panic at the finalization",
                "phase, if this call hasn't been invoked by that time.",
                "",
                "The timestamp should be greater than the previous one by the amount specified by",
                "`MinimumPeriod`.",
                "",
                "The dispatch origin for this call must be `Inherent`.",
                "",
                "# \u003cweight\u003e",
                "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)",
                "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in",
                "  `on_finalize`)",
                "- 1 event handler `on_timestamp_set`. Must be `O(1)`.",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "now",
                  "type": "compact\u003cU64\u003e",
                  "type_name": "Moment"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 156
          },
          "constants": [
            {
              "name": "MinimumPeriod",
              "type": "U64",
              "type_value": 8,
              "constants_value": "7017000000000000",
              "docs": [
                " The minimum period between blocks. Beware that this is different to the *expected*",
                " period that the block production apparatus provides. Your chosen consensus system will",
                " generally work with this to determine a sensible block time. e.g. For Aura, it will be",
                " double this period on default settings."
              ]
            }
          ],
          "errors": null,
          "errors_value": null,
          "index": 1
        },
        {
          "name": "Utility",
          "prefix": "",
          "storage": null,
          "calls": [
            {
              "lookup": "0200",
              "name": "batch",
              "docs": [
                "Send a batch of dispatch calls.",
                "",
                "May be called from any origin.",
                "",
                "- `calls`: The calls to be dispatched from the same origin. The number of call must not",
                "  exceed the constant: `batched_calls_limit` (available in constant metadata).",
                "",
                "If origin is root then call are dispatch without checking origin filter. (This includes",
                "bypassing `frame_system::Config::BaseCallFilter`).",
                "",
                "# \u003cweight\u003e",
                "- Complexity: O(C) where C is the number of calls to be batched.",
                "# \u003c/weight\u003e",
                "",
                "This will return `Ok` in all circumstances. To determine the success of the batch, an",
                "event is deposited. If a call failed and the batch was interrupted, then the",
                "`BatchInterrupted` event is deposited, along with the number of successful calls made",
                "and the error of the failed call. If all were successful, then the `BatchCompleted`",
                "event is deposited."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "calls",
                  "type": "Vec\u003cCall\u003e",
                  "type_name": "Vec\u003c\u003cT as Config\u003e::Call\u003e"
                }
              ]
            },
            {
              "lookup": "0201",
              "name": "as_derivative",
              "docs": [
                "Send a call through an indexed pseudonym of the sender.",
                "",
                "Filter from origin are passed along. The call will be dispatched with an origin which",
                "use the same filter as the origin of this call.",
                "",
                "NOTE: If you need to ensure that any account-based filtering is not honored (i.e.",
                "because you expect `proxy` to have been used prior in the call stack and you do not want",
                "the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`",
                "in the Multisig pallet instead.",
                "",
                "NOTE: Prior to version *12, this was called `as_limited_sub`.",
                "",
                "The dispatch origin for this call must be _Signed_."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "U16",
                  "type_name": "u16"
                },
                {
                  "TypeName": "",
                  "name": "call",
                  "type": "Call",
                  "type_name": "Box\u003c\u003cT as Config\u003e::Call\u003e"
                }
              ]
            },
            {
              "lookup": "0202",
              "name": "batch_all",
              "docs": [
                "Send a batch of dispatch calls and atomically execute them.",
                "The whole transaction will rollback and fail if any of the calls failed.",
                "",
                "May be called from any origin.",
                "",
                "- `calls`: The calls to be dispatched from the same origin. The number of call must not",
                "  exceed the constant: `batched_calls_limit` (available in constant metadata).",
                "",
                "If origin is root then call are dispatch without checking origin filter. (This includes",
                "bypassing `frame_system::Config::BaseCallFilter`).",
                "",
                "# \u003cweight\u003e",
                "- Complexity: O(C) where C is the number of calls to be batched.",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "calls",
                  "type": "Vec\u003cCall\u003e",
                  "type_name": "Vec\u003c\u003cT as Config\u003e::Call\u003e"
                }
              ]
            },
            {
              "lookup": "0203",
              "name": "dispatch_as",
              "docs": [
                "Dispatches a function call with a provided origin.",
                "",
                "The dispatch origin for this call must be _Root_.",
                "",
                "# \u003cweight\u003e",
                "- O(1).",
                "- Limited storage reads.",
                "- One DB write (event).",
                "- Weight of derivative `call` execution + T::WeightInfo::dispatch_as().",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "as_origin",
                  "type": "kintsugi_runtime_parachain:OriginCaller",
                  "type_name": "Box\u003cPalletsOrigin\u003e"
                },
                {
                  "TypeName": "",
                  "name": "call",
                  "type": "Call",
                  "type_name": "Box\u003c\u003cT as Config\u003e::Call\u003e"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 157
          },
          "events": [
            {
              "lookup": "0200",
              "name": "BatchInterrupted",
              "docs": [
                "Batch of dispatches did not complete fully. Index of first failing dispatch given, as",
                "well as the error."
              ],
              "args": [
                "U32",
                "sp_runtime:DispatchError"
              ],
              "args_type_name": [
                "u32",
                "DispatchError"
              ]
            },
            {
              "lookup": "0201",
              "name": "BatchCompleted",
              "docs": [
                "Batch of dispatches completed fully with no error."
              ],
              "args": null
            },
            {
              "lookup": "0202",
              "name": "ItemCompleted",
              "docs": [
                "A single item within a Batch of dispatches has completed with no error."
              ],
              "args": null
            },
            {
              "lookup": "0203",
              "name": "DispatchedAs",
              "docs": [
                "A call was dispatched."
              ],
              "args": [
                "Results\u003cNULL,sp_runtime:DispatchError\u003e"
              ],
              "args_type_name": [
                "DispatchResult"
              ]
            }
          ],
          "events_value": {
            "type": 26
          },
          "constants": [
            {
              "name": "batched_calls_limit",
              "type": "U32",
              "type_value": 4,
              "constants_value": "aa2a0000",
              "docs": [
                " The limit on the number of batched calls."
              ]
            }
          ],
          "errors": [
            {
              "name": "TooManyCalls",
              "doc": [
                "Too many calls batched."
              ]
            }
          ],
          "errors_value": {
            "type": 290
          },
          "index": 2
        },
        {
          "name": "TransactionPayment",
          "prefix": "TransactionPayment",
          "storage": [
            {
              "name": "NextFeeMultiplier",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 73
              },
              "fallback": "0x000064a7b3b6e00d0000000000000000",
              "docs": null
            },
            {
              "name": "StorageVersion",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "pallet_transaction_payment:Releases",
                "PlainTypeValue": 291
              },
              "fallback": "0x00",
              "docs": null
            }
          ],
          "constants": [
            {
              "name": "TransactionByteFee",
              "type": "U128",
              "type_value": 6,
              "constants_value": "35820000000000000000000000000000",
              "docs": [
                " The fee to be paid for making a transaction; the per-byte portion."
              ]
            },
            {
              "name": "OperationalFeeMultiplier",
              "type": "U8",
              "type_value": 2,
              "constants_value": "05",
              "docs": [
                " A fee mulitplier for `Operational` extrinsics to compute \"virtual tip\" to boost their",
                " `priority`",
                "",
                " This value is multipled by the `final_fee` to obtain a \"virtual tip\" that is later",
                " added to a tip component in regular `priority` calculations.",
                " It means that a `Normal` transaction can front-run a similarly-sized `Operational`",
                " extrinsic (with no tip), by including a tip value greater than the virtual tip.",
                "",
                " ```rust,ignore",
                " // For `Normal`",
                " let priority = priority_calc(tip);",
                "",
                " // For `Operational`",
                " let virtual_tip = (inclusion_fee + tip) * OperationalFeeMultiplier;",
                " let priority = priority_calc(tip + virtual_tip);",
                " ```",
                "",
                " Note that since we use `final_fee` the multiplier applies also to the regular `tip`",
                " sent with the transaction. So, not only does the transaction get a priority bump based",
                " on the `inclusion_fee`, but we also amplify the impact of tips applied to `Operational`",
                " transactions."
              ]
            },
            {
              "name": "WeightToFee",
              "type": "Vec\u003cframe_support:weights:WeightToFeeCoefficient\u003e",
              "type_value": 292,
              "constants_value": "0401000000000000000000000000000000000000000001",
              "docs": [
                " The polynomial that is applied in order to derive fee from weight."
              ]
            }
          ],
          "errors": null,
          "errors_value": null,
          "index": 3
        },
        {
          "name": "Scheduler",
          "prefix": "Scheduler",
          "storage": [
            {
              "name": "Agenda",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "U32"
                  ],
                  "value": "Vec\u003coption\u003cpallet_scheduler:ScheduledV3\u003e\u003e",
                  "keys_id": 4,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Items to be executed, indexed by the block number that they should be executed on."
              ]
            },
            {
              "name": "Lookup",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "Vec\u003cU8\u003e"
                  ],
                  "value": "Tuple:U32U32",
                  "keys_id": 10,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Lookup from identity to the block number and index of the task."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "0400",
              "name": "schedule",
              "docs": [
                "Anonymously schedule a task."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "when",
                  "type": "U32",
                  "type_name": "BlockNumber"
                },
                {
                  "TypeName": "",
                  "name": "maybe_periodic",
                  "type": "option\u003cTuple:U32U32\u003e",
                  "type_name": "Option\u003cschedule::Period\u003cBlockNumber\u003e\u003e"
                },
                {
                  "TypeName": "",
                  "name": "priority",
                  "type": "U8",
                  "type_name": "schedule::Priority"
                },
                {
                  "TypeName": "",
                  "name": "call",
                  "type": "frame_support:traits:schedule:MaybeHashed",
                  "type_name": "Box\u003cCallOrHashOf\u003e"
                }
              ]
            },
            {
              "lookup": "0401",
              "name": "cancel",
              "docs": [
                "Cancel an anonymously scheduled task."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "when",
                  "type": "U32",
                  "type_name": "BlockNumber"
                },
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "U32",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "0402",
              "name": "schedule_named",
              "docs": [
                "Schedule a named task."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "id",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                },
                {
                  "TypeName": "",
                  "name": "when",
                  "type": "U32",
                  "type_name": "BlockNumber"
                },
                {
                  "TypeName": "",
                  "name": "maybe_periodic",
                  "type": "option\u003cTuple:U32U32\u003e",
                  "type_name": "Option\u003cschedule::Period\u003cBlockNumber\u003e\u003e"
                },
                {
                  "TypeName": "",
                  "name": "priority",
                  "type": "U8",
                  "type_name": "schedule::Priority"
                },
                {
                  "TypeName": "",
                  "name": "call",
                  "type": "frame_support:traits:schedule:MaybeHashed",
                  "type_name": "Box\u003cCallOrHashOf\u003e"
                }
              ]
            },
            {
              "lookup": "0403",
              "name": "cancel_named",
              "docs": [
                "Cancel a named scheduled task."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "id",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "0404",
              "name": "schedule_after",
              "docs": [
                "Anonymously schedule a task after a delay.",
                "",
                "# \u003cweight\u003e",
                "Same as [`schedule`].",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "after",
                  "type": "U32",
                  "type_name": "BlockNumber"
                },
                {
                  "TypeName": "",
                  "name": "maybe_periodic",
                  "type": "option\u003cTuple:U32U32\u003e",
                  "type_name": "Option\u003cschedule::Period\u003cBlockNumber\u003e\u003e"
                },
                {
                  "TypeName": "",
                  "name": "priority",
                  "type": "U8",
                  "type_name": "schedule::Priority"
                },
                {
                  "TypeName": "",
                  "name": "call",
                  "type": "frame_support:traits:schedule:MaybeHashed",
                  "type_name": "Box\u003cCallOrHashOf\u003e"
                }
              ]
            },
            {
              "lookup": "0405",
              "name": "schedule_named_after",
              "docs": [
                "Schedule a named task after a delay.",
                "",
                "# \u003cweight\u003e",
                "Same as [`schedule_named`](Self::schedule_named).",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "id",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                },
                {
                  "TypeName": "",
                  "name": "after",
                  "type": "U32",
                  "type_name": "BlockNumber"
                },
                {
                  "TypeName": "",
                  "name": "maybe_periodic",
                  "type": "option\u003cTuple:U32U32\u003e",
                  "type_name": "Option\u003cschedule::Period\u003cBlockNumber\u003e\u003e"
                },
                {
                  "TypeName": "",
                  "name": "priority",
                  "type": "U8",
                  "type_name": "schedule::Priority"
                },
                {
                  "TypeName": "",
                  "name": "call",
                  "type": "frame_support:traits:schedule:MaybeHashed",
                  "type_name": "Box\u003cCallOrHashOf\u003e"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 160
          },
          "events": [
            {
              "lookup": "0400",
              "name": "Scheduled",
              "docs": [
                "Scheduled some task."
              ],
              "args": [
                "U32",
                "U32"
              ],
              "args_type_name": [
                "BlockNumber",
                "u32"
              ]
            },
            {
              "lookup": "0401",
              "name": "Canceled",
              "docs": [
                "Canceled some task."
              ],
              "args": [
                "U32",
                "U32"
              ],
              "args_type_name": [
                "BlockNumber",
                "u32"
              ]
            },
            {
              "lookup": "0402",
              "name": "Dispatched",
              "docs": [
                "Dispatched some task."
              ],
              "args": [
                "Tuple:U32U32",
                "option\u003cVec\u003cU8\u003e\u003e",
                "Results\u003cNULL,sp_runtime:DispatchError\u003e"
              ],
              "args_type_name": [
                "TaskAddress\u003cBlockNumber\u003e",
                "Option\u003cVec\u003cu8\u003e\u003e",
                "DispatchResult"
              ]
            },
            {
              "lookup": "0403",
              "name": "CallLookupFailed",
              "docs": [
                "The call for the provided hash was not found so the task has been aborted."
              ],
              "args": [
                "Tuple:U32U32",
                "option\u003cVec\u003cU8\u003e\u003e",
                "frame_support:traits:schedule:LookupError"
              ],
              "args_type_name": [
                "TaskAddress\u003cBlockNumber\u003e",
                "Option\u003cVec\u003cu8\u003e\u003e",
                "LookupError"
              ]
            }
          ],
          "events_value": {
            "type": 29
          },
          "constants": [
            {
              "name": "MaximumWeight",
              "type": "U64",
              "type_value": 8,
              "constants_value": "00d0ed902e000000",
              "docs": [
                " The maximum weight that may be scheduled per block for any dispatchables of less",
                " priority than `schedule::HARD_DEADLINE`."
              ]
            },
            {
              "name": "MaxScheduledPerBlock",
              "type": "U32",
              "type_value": 4,
              "constants_value": "1e000000",
              "docs": [
                " The maximum number of scheduled calls in the queue for a single block.",
                " Not strictly enforced, but used for weight estimation."
              ]
            }
          ],
          "errors": [
            {
              "name": "FailedToSchedule",
              "doc": [
                "Failed to schedule a call"
              ]
            },
            {
              "name": "NotFound",
              "doc": [
                "Cannot find the scheduled call."
              ]
            },
            {
              "name": "TargetBlockNumberInPast",
              "doc": [
                "Given target block number is in the past."
              ]
            },
            {
              "name": "RescheduleNoChange",
              "doc": [
                "Reschedule failed because it does not change scheduled time."
              ]
            }
          ],
          "errors_value": {
            "type": 297
          },
          "index": 4
        },
        {
          "name": "Preimage",
          "prefix": "Preimage",
          "storage": [
            {
              "name": "StatusFor",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Identity"
                  ],
                  "key_vec": [
                    "H256"
                  ],
                  "value": "pallet_preimage:RequestStatus",
                  "keys_id": 9,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " The request status of a given hash."
              ]
            },
            {
              "name": "PreimageFor",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Identity"
                  ],
                  "key_vec": [
                    "H256"
                  ],
                  "value": "Vec\u003cU8\u003e",
                  "keys_id": 9,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " The preimages stored by this pallet."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "0500",
              "name": "note_preimage",
              "docs": [
                "Register a preimage on-chain.",
                "",
                "If the preimage was previously requested, no fees or deposits are taken for providing",
                "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "bytes",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "0501",
              "name": "unnote_preimage",
              "docs": [
                "Clear an unrequested preimage from the runtime storage."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "hash",
                  "type": "H256",
                  "type_name": "Hash"
                }
              ]
            },
            {
              "lookup": "0502",
              "name": "request_preimage",
              "docs": [
                "Request a preimage be uploaded to the chain without paying any fees or deposits.",
                "",
                "If the preimage requests has already been provided on-chain, we unreserve any deposit",
                "a user may have paid, and take the control of the preimage out of their hands."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "hash",
                  "type": "H256",
                  "type_name": "Hash"
                }
              ]
            },
            {
              "lookup": "0503",
              "name": "unrequest_preimage",
              "docs": [
                "Clear a previously made request for a preimage.",
                "",
                "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "hash",
                  "type": "H256",
                  "type_name": "Hash"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 163
          },
          "events": [
            {
              "lookup": "0500",
              "name": "Noted",
              "docs": [
                "A preimage has been noted."
              ],
              "args": [
                "H256"
              ],
              "args_type_name": [
                "Hash"
              ]
            },
            {
              "lookup": "0501",
              "name": "Requested",
              "docs": [
                "A preimage has been requested."
              ],
              "args": [
                "H256"
              ],
              "args_type_name": [
                "Hash"
              ]
            },
            {
              "lookup": "0502",
              "name": "Cleared",
              "docs": [
                "A preimage has ben cleared."
              ],
              "args": [
                "H256"
              ],
              "args_type_name": [
                "Hash"
              ]
            }
          ],
          "events_value": {
            "type": 33
          },
          "errors": [
            {
              "name": "TooLarge",
              "doc": [
                "Preimage is too large to store on-chain."
              ]
            },
            {
              "name": "AlreadyNoted",
              "doc": [
                "Preimage has already been noted on-chain."
              ]
            },
            {
              "name": "NotAuthorized",
              "doc": [
                "The user is not authorized to perform this action."
              ]
            },
            {
              "name": "NotNoted",
              "doc": [
                "The preimage cannot be removed since it has not yet been noted."
              ]
            },
            {
              "name": "Requested",
              "doc": [
                "A preimage may not be removed when there are outstanding requests."
              ]
            },
            {
              "name": "NotRequested",
              "doc": [
                "The preimage request cannot be removed since no outstanding requests exist."
              ]
            }
          ],
          "errors_value": {
            "type": 302
          },
          "index": 5
        },
        {
          "name": "Multisig",
          "prefix": "Multisig",
          "storage": [
            {
              "name": "Multisigs",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]",
                    "[U8; 32]"
                  ],
                  "value": "pallet_multisig:Multisig",
                  "keys_id": 303,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " The set of open multisig operations."
              ]
            },
            {
              "name": "Calls",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Identity"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "Tuple:WrapperOpaque\u003cCall\u003e[U8; 32]U128",
                  "keys_id": 1,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": null
            }
          ],
          "calls": [
            {
              "lookup": "0600",
              "name": "as_multi_threshold_1",
              "docs": [
                "Immediately dispatch a multi-signature call using a single approval from the caller.",
                "",
                "The dispatch origin for this call must be _Signed_.",
                "",
                "- `other_signatories`: The accounts (other than the sender) who are part of the",
                "multi-signature, but do not participate in the approval process.",
                "- `call`: The call to be executed.",
                "",
                "Result is equivalent to the dispatched result.",
                "",
                "# \u003cweight\u003e",
                "O(Z + C) where Z is the length of the call and C its execution weight.",
                "-------------------------------",
                "- DB Weight: None",
                "- Plus Call Weight",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "other_signatories",
                  "type": "Vec\u003c[U8; 32]\u003e",
                  "type_name": "Vec\u003cAccountId\u003e"
                },
                {
                  "TypeName": "",
                  "name": "call",
                  "type": "Call",
                  "type_name": "Box\u003c\u003cT as Config\u003e::Call\u003e"
                }
              ]
            },
            {
              "lookup": "0601",
              "name": "as_multi",
              "docs": [
                "Register approval for a dispatch to be made from a deterministic composite account if",
                "approved by a total of `threshold - 1` of `other_signatories`.",
                "",
                "If there are enough, then dispatch the call.",
                "",
                "Payment: `DepositBase` will be reserved if this is the first approval, plus",
                "`threshold` times `DepositFactor`. It is returned once this dispatch happens or",
                "is cancelled.",
                "",
                "The dispatch origin for this call must be _Signed_.",
                "",
                "- `threshold`: The total number of approvals for this dispatch before it is executed.",
                "- `other_signatories`: The accounts (other than the sender) who can approve this",
                "dispatch. May not be empty.",
                "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is",
                "not the first approval, then it must be `Some`, with the timepoint (block number and",
                "transaction index) of the first approval transaction.",
                "- `call`: The call to be executed.",
                "",
                "NOTE: Unless this is the final approval, you will generally want to use",
                "`approve_as_multi` instead, since it only requires a hash of the call.",
                "",
                "Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise",
                "on success, result is `Ok` and the result from the interior call, if it was executed,",
                "may be found in the deposited `MultisigExecuted` event.",
                "",
                "# \u003cweight\u003e",
                "- `O(S + Z + Call)`.",
                "- Up to one balance-reserve or unreserve operation.",
                "- One passthrough operation, one insert, both `O(S)` where `S` is the number of",
                "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional.",
                "- One call encode \u0026 hash, both of complexity `O(Z)` where `Z` is tx-len.",
                "- One encode \u0026 hash, both of complexity `O(S)`.",
                "- Up to one binary search and insert (`O(logS + S)`).",
                "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.",
                "- One event.",
                "- The weight of the `call`.",
                "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit",
                "  taken for its lifetime of `DepositBase + threshold * DepositFactor`.",
                "-------------------------------",
                "- DB Weight:",
                "    - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)",
                "    - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)",
                "- Plus Call Weight",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "threshold",
                  "type": "U16",
                  "type_name": "u16"
                },
                {
                  "TypeName": "",
                  "name": "other_signatories",
                  "type": "Vec\u003c[U8; 32]\u003e",
                  "type_name": "Vec\u003cAccountId\u003e"
                },
                {
                  "TypeName": "",
                  "name": "maybe_timepoint",
                  "type": "option\u003cpallet_multisig:Timepoint\u003e",
                  "type_name": "Option\u003cTimepoint\u003cBlockNumber\u003e\u003e"
                },
                {
                  "TypeName": "",
                  "name": "call",
                  "type": "WrapperOpaque\u003cCall\u003e",
                  "type_name": "OpaqueCall"
                },
                {
                  "TypeName": "",
                  "name": "store_call",
                  "type": "Bool",
                  "type_name": "bool"
                },
                {
                  "TypeName": "",
                  "name": "max_weight",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            },
            {
              "lookup": "0602",
              "name": "approve_as_multi",
              "docs": [
                "Register approval for a dispatch to be made from a deterministic composite account if",
                "approved by a total of `threshold - 1` of `other_signatories`.",
                "",
                "Payment: `DepositBase` will be reserved if this is the first approval, plus",
                "`threshold` times `DepositFactor`. It is returned once this dispatch happens or",
                "is cancelled.",
                "",
                "The dispatch origin for this call must be _Signed_.",
                "",
                "- `threshold`: The total number of approvals for this dispatch before it is executed.",
                "- `other_signatories`: The accounts (other than the sender) who can approve this",
                "dispatch. May not be empty.",
                "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is",
                "not the first approval, then it must be `Some`, with the timepoint (block number and",
                "transaction index) of the first approval transaction.",
                "- `call_hash`: The hash of the call to be executed.",
                "",
                "NOTE: If this is the final approval, you will want to use `as_multi` instead.",
                "",
                "# \u003cweight\u003e",
                "- `O(S)`.",
                "- Up to one balance-reserve or unreserve operation.",
                "- One passthrough operation, one insert, both `O(S)` where `S` is the number of",
                "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional.",
                "- One encode \u0026 hash, both of complexity `O(S)`.",
                "- Up to one binary search and insert (`O(logS + S)`).",
                "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.",
                "- One event.",
                "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit",
                "  taken for its lifetime of `DepositBase + threshold * DepositFactor`.",
                "----------------------------------",
                "- DB Weight:",
                "    - Read: Multisig Storage, [Caller Account]",
                "    - Write: Multisig Storage, [Caller Account]",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "threshold",
                  "type": "U16",
                  "type_name": "u16"
                },
                {
                  "TypeName": "",
                  "name": "other_signatories",
                  "type": "Vec\u003c[U8; 32]\u003e",
                  "type_name": "Vec\u003cAccountId\u003e"
                },
                {
                  "TypeName": "",
                  "name": "maybe_timepoint",
                  "type": "option\u003cpallet_multisig:Timepoint\u003e",
                  "type_name": "Option\u003cTimepoint\u003cBlockNumber\u003e\u003e"
                },
                {
                  "TypeName": "",
                  "name": "call_hash",
                  "type": "[U8; 32]",
                  "type_name": "[u8; 32]"
                },
                {
                  "TypeName": "",
                  "name": "max_weight",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            },
            {
              "lookup": "0603",
              "name": "cancel_as_multi",
              "docs": [
                "Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously",
                "for this operation will be unreserved on success.",
                "",
                "The dispatch origin for this call must be _Signed_.",
                "",
                "- `threshold`: The total number of approvals for this dispatch before it is executed.",
                "- `other_signatories`: The accounts (other than the sender) who can approve this",
                "dispatch. May not be empty.",
                "- `timepoint`: The timepoint (block number and transaction index) of the first approval",
                "transaction for this dispatch.",
                "- `call_hash`: The hash of the call to be executed.",
                "",
                "# \u003cweight\u003e",
                "- `O(S)`.",
                "- Up to one balance-reserve or unreserve operation.",
                "- One passthrough operation, one insert, both `O(S)` where `S` is the number of",
                "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional.",
                "- One encode \u0026 hash, both of complexity `O(S)`.",
                "- One event.",
                "- I/O: 1 read `O(S)`, one remove.",
                "- Storage: removes one item.",
                "----------------------------------",
                "- DB Weight:",
                "    - Read: Multisig Storage, [Caller Account], Refund Account, Calls",
                "    - Write: Multisig Storage, [Caller Account], Refund Account, Calls",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "threshold",
                  "type": "U16",
                  "type_name": "u16"
                },
                {
                  "TypeName": "",
                  "name": "other_signatories",
                  "type": "Vec\u003c[U8; 32]\u003e",
                  "type_name": "Vec\u003cAccountId\u003e"
                },
                {
                  "TypeName": "",
                  "name": "timepoint",
                  "type": "pallet_multisig:Timepoint",
                  "type_name": "Timepoint\u003cBlockNumber\u003e"
                },
                {
                  "TypeName": "",
                  "name": "call_hash",
                  "type": "[U8; 32]",
                  "type_name": "[u8; 32]"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 164
          },
          "events": [
            {
              "lookup": "0600",
              "name": "NewMultisig",
              "docs": [
                "A new multisig operation has begun."
              ],
              "args": [
                "[U8; 32]",
                "[U8; 32]",
                "[U8; 32]"
              ],
              "args_type_name": [
                "AccountId",
                "AccountId",
                "CallHash"
              ]
            },
            {
              "lookup": "0601",
              "name": "MultisigApproval",
              "docs": [
                "A multisig operation has been approved by someone."
              ],
              "args": [
                "[U8; 32]",
                "pallet_multisig:Timepoint",
                "[U8; 32]",
                "[U8; 32]"
              ],
              "args_type_name": [
                "AccountId",
                "Timepoint\u003cBlockNumber\u003e",
                "AccountId",
                "CallHash"
              ]
            },
            {
              "lookup": "0602",
              "name": "MultisigExecuted",
              "docs": [
                "A multisig operation has been executed."
              ],
              "args": [
                "[U8; 32]",
                "pallet_multisig:Timepoint",
                "[U8; 32]",
                "[U8; 32]",
                "Results\u003cNULL,sp_runtime:DispatchError\u003e"
              ],
              "args_type_name": [
                "AccountId",
                "Timepoint\u003cBlockNumber\u003e",
                "AccountId",
                "CallHash",
                "DispatchResult"
              ]
            },
            {
              "lookup": "0603",
              "name": "MultisigCancelled",
              "docs": [
                "A multisig operation has been cancelled."
              ],
              "args": [
                "[U8; 32]",
                "pallet_multisig:Timepoint",
                "[U8; 32]",
                "[U8; 32]"
              ],
              "args_type_name": [
                "AccountId",
                "Timepoint\u003cBlockNumber\u003e",
                "AccountId",
                "CallHash"
              ]
            }
          ],
          "events_value": {
            "type": 34
          },
          "constants": [
            {
              "name": "DepositBase",
              "type": "U128",
              "type_value": 6,
              "constants_value": "f07520970f0000000000000000000000",
              "docs": [
                " The base amount of currency needed to reserve for creating a multisig execution or to",
                " store a dispatch call for later.",
                "",
                " This is held for an additional storage item whose value size is",
                " `4 + sizeof((BlockNumber, Balance, AccountId))` bytes and whose key size is",
                " `32 + sizeof(AccountId)` bytes."
              ]
            },
            {
              "name": "DepositFactor",
              "type": "U128",
              "type_value": 6,
              "constants_value": "80965b06000000000000000000000000",
              "docs": [
                " The amount of currency needed per unit threshold when creating a multisig execution.",
                "",
                " This is held for adding 32 bytes more into a pre-existing storage value."
              ]
            },
            {
              "name": "MaxSignatories",
              "type": "U16",
              "type_value": 154,
              "constants_value": "6400",
              "docs": [
                " The maximum amount of signatories allowed in the multisig."
              ]
            }
          ],
          "errors": [
            {
              "name": "MinimumThreshold",
              "doc": [
                "Threshold must be 2 or greater."
              ]
            },
            {
              "name": "AlreadyApproved",
              "doc": [
                "Call is already approved by this signatory."
              ]
            },
            {
              "name": "NoApprovalsNeeded",
              "doc": [
                "Call doesn't need any (more) approvals."
              ]
            },
            {
              "name": "TooFewSignatories",
              "doc": [
                "There are too few signatories in the list."
              ]
            },
            {
              "name": "TooManySignatories",
              "doc": [
                "There are too many signatories in the list."
              ]
            },
            {
              "name": "SignatoriesOutOfOrder",
              "doc": [
                "The signatories were provided out of order; they should be ordered."
              ]
            },
            {
              "name": "SenderInSignatories",
              "doc": [
                "The sender was contained in the other signatories; it shouldn't be."
              ]
            },
            {
              "name": "NotFound",
              "doc": [
                "Multisig operation not found when attempting to cancel."
              ]
            },
            {
              "name": "NotOwner",
              "doc": [
                "Only the account that originally created the multisig is able to cancel it."
              ]
            },
            {
              "name": "NoTimepoint",
              "doc": [
                "No timepoint was given, yet the multisig operation is already underway."
              ]
            },
            {
              "name": "WrongTimepoint",
              "doc": [
                "A different timepoint was given to the multisig operation that is underway."
              ]
            },
            {
              "name": "UnexpectedTimepoint",
              "doc": [
                "A timepoint was given, yet no multisig operation is underway."
              ]
            },
            {
              "name": "MaxWeightTooLow",
              "doc": [
                "The maximum weight information provided was too low."
              ]
            },
            {
              "name": "AlreadyStored",
              "doc": [
                "The data to be stored is already stored."
              ]
            }
          ],
          "errors_value": {
            "type": 306
          },
          "index": 6
        },
        {
          "name": "Currency",
          "prefix": "",
          "storage": null,
          "constants": [
            {
              "name": "GetNativeCurrencyId",
              "type": "interbtc_primitives:CurrencyId",
              "type_value": 37,
              "constants_value": "000c",
              "docs": [
                " Native currency e.g. INTR/KINT"
              ]
            },
            {
              "name": "GetRelayChainCurrencyId",
              "type": "interbtc_primitives:CurrencyId",
              "type_value": 37,
              "constants_value": "000a",
              "docs": [
                " Relay chain currency e.g. DOT/KSM"
              ]
            },
            {
              "name": "GetWrappedCurrencyId",
              "type": "interbtc_primitives:CurrencyId",
              "type_value": 37,
              "constants_value": "000b",
              "docs": [
                " Wrapped currency e.g. IBTC/KBTC"
              ]
            }
          ],
          "errors": [
            {
              "name": "ArithmeticOverflow",
              "doc": null
            },
            {
              "name": "ArithmeticUnderflow",
              "doc": null
            },
            {
              "name": "TryIntoIntError",
              "doc": null
            },
            {
              "name": "InvalidCurrency",
              "doc": null
            }
          ],
          "errors_value": {
            "type": 307
          },
          "index": 7
        },
        {
          "name": "Tokens",
          "prefix": "Tokens",
          "storage": [
            {
              "name": "TotalIssuance",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:CurrencyId"
                  ],
                  "value": "U128",
                  "keys_id": 37,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The total issuance of a token type."
              ]
            },
            {
              "name": "Locks",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]",
                    "interbtc_primitives:CurrencyId"
                  ],
                  "value": "Vec\u003corml_tokens:BalanceLock\u003e",
                  "keys_id": 308,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Any liquidity locks of a token type under an account.",
                " NOTE: Should only be accessed when setting, changing and freeing a lock."
              ]
            },
            {
              "name": "Accounts",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]",
                    "interbtc_primitives:CurrencyId"
                  ],
                  "value": "orml_tokens:AccountData",
                  "keys_id": 308,
                  "value_id": 0
                }
              },
              "fallback": "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " The balance of a token type under an account.",
                "",
                " NOTE: If the total is ever zero, decrease account ref account.",
                "",
                " NOTE: This is only used in the case that this module is used to store",
                " balances."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "0800",
              "name": "transfer",
              "docs": [
                "Transfer some liquid free balance to another account.",
                "",
                "`transfer` will set the `FreeBalance` of the sender and receiver.",
                "It will decrease the total issuance of the system by the",
                "`TransferFee`. If the sender's account is below the existential",
                "deposit as a result of the transfer, the account will be reaped.",
                "",
                "The dispatch origin for this call must be `Signed` by the",
                "transactor.",
                "",
                "- `dest`: The recipient of the transfer.",
                "- `currency_id`: currency type.",
                "- `amount`: free balance amount to tranfer."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                },
                {
                  "TypeName": "",
                  "name": "currency_id",
                  "type": "interbtc_primitives:CurrencyId",
                  "type_name": "CurrencyId"
                },
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "Balance"
                }
              ]
            },
            {
              "lookup": "0801",
              "name": "transfer_all",
              "docs": [
                "Transfer all remaining balance to the given account.",
                "",
                "NOTE: This function only attempts to transfer _transferable_",
                "balances. This means that any locked, reserved, or existential",
                "deposits (when `keep_alive` is `true`), will not be transferred by",
                "this function. To ensure that this function results in a killed",
                "account, you might need to prepare the account by removing any",
                "reference counters, storage deposits, etc...",
                "",
                "The dispatch origin for this call must be `Signed` by the",
                "transactor.",
                "",
                "- `dest`: The recipient of the transfer.",
                "- `currency_id`: currency type.",
                "- `keep_alive`: A boolean to determine if the `transfer_all`",
                "  operation should send all of the funds the account has, causing",
                "  the sender account to be killed (false), or transfer everything",
                "  except at least the existential deposit, which will guarantee to",
                "  keep the sender account alive (true)."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                },
                {
                  "TypeName": "",
                  "name": "currency_id",
                  "type": "interbtc_primitives:CurrencyId",
                  "type_name": "CurrencyId"
                },
                {
                  "TypeName": "",
                  "name": "keep_alive",
                  "type": "Bool",
                  "type_name": "bool"
                }
              ]
            },
            {
              "lookup": "0802",
              "name": "transfer_keep_alive",
              "docs": [
                "Same as the [`transfer`] call, but with a check that the transfer",
                "will not kill the origin account.",
                "",
                "99% of the time you want [`transfer`] instead.",
                "",
                "The dispatch origin for this call must be `Signed` by the",
                "transactor.",
                "",
                "- `dest`: The recipient of the transfer.",
                "- `currency_id`: currency type.",
                "- `amount`: free balance amount to tranfer."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                },
                {
                  "TypeName": "",
                  "name": "currency_id",
                  "type": "interbtc_primitives:CurrencyId",
                  "type_name": "CurrencyId"
                },
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "Balance"
                }
              ]
            },
            {
              "lookup": "0803",
              "name": "force_transfer",
              "docs": [
                "Exactly as `transfer`, except the origin must be root and the source",
                "account may be specified.",
                "",
                "The dispatch origin for this call must be _Root_.",
                "",
                "- `source`: The sender of the transfer.",
                "- `dest`: The recipient of the transfer.",
                "- `currency_id`: currency type.",
                "- `amount`: free balance amount to tranfer."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "source",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                },
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                },
                {
                  "TypeName": "",
                  "name": "currency_id",
                  "type": "interbtc_primitives:CurrencyId",
                  "type_name": "CurrencyId"
                },
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "Balance"
                }
              ]
            },
            {
              "lookup": "0804",
              "name": "set_balance",
              "docs": [
                "Set the balances of a given account.",
                "",
                "This will alter `FreeBalance` and `ReservedBalance` in storage. it",
                "will also decrease the total issuance of the system",
                "(`TotalIssuance`). If the new free or reserved balance is below the",
                "existential deposit, it will reap the `AccountInfo`.",
                "",
                "The dispatch origin for this call is `root`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "who",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                },
                {
                  "TypeName": "",
                  "name": "currency_id",
                  "type": "interbtc_primitives:CurrencyId",
                  "type_name": "CurrencyId"
                },
                {
                  "TypeName": "",
                  "name": "new_free",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "Balance"
                },
                {
                  "TypeName": "",
                  "name": "new_reserved",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "Balance"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 167
          },
          "events": [
            {
              "lookup": "0800",
              "name": "Endowed",
              "docs": [
                "An account was created with some free balance."
              ],
              "args": [
                "interbtc_primitives:CurrencyId",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "CurrencyId",
                "AccountId",
                "Balance"
              ]
            },
            {
              "lookup": "0801",
              "name": "DustLost",
              "docs": [
                "An account was removed whose balance was non-zero but below",
                "ExistentialDeposit, resulting in an outright loss."
              ],
              "args": [
                "interbtc_primitives:CurrencyId",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "CurrencyId",
                "AccountId",
                "Balance"
              ]
            },
            {
              "lookup": "0802",
              "name": "Transfer",
              "docs": [
                "Transfer succeeded."
              ],
              "args": [
                "interbtc_primitives:CurrencyId",
                "[U8; 32]",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "CurrencyId",
                "AccountId",
                "AccountId",
                "Balance"
              ]
            },
            {
              "lookup": "0803",
              "name": "Reserved",
              "docs": [
                "Some balance was reserved (moved from free to reserved)."
              ],
              "args": [
                "interbtc_primitives:CurrencyId",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "CurrencyId",
                "AccountId",
                "Balance"
              ]
            },
            {
              "lookup": "0804",
              "name": "Unreserved",
              "docs": [
                "Some balance was unreserved (moved from reserved to free)."
              ],
              "args": [
                "interbtc_primitives:CurrencyId",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "CurrencyId",
                "AccountId",
                "Balance"
              ]
            },
            {
              "lookup": "0805",
              "name": "RepatriatedReserve",
              "docs": [
                "Some reserved balance was repatriated (moved from reserved to",
                "another account)."
              ],
              "args": [
                "interbtc_primitives:CurrencyId",
                "[U8; 32]",
                "[U8; 32]",
                "U128",
                "frame_support:traits:tokens:misc:BalanceStatus"
              ],
              "args_type_name": [
                "CurrencyId",
                "AccountId",
                "AccountId",
                "Balance",
                "BalanceStatus"
              ]
            },
            {
              "lookup": "0806",
              "name": "BalanceSet",
              "docs": [
                "A balance was set by root."
              ],
              "args": [
                "interbtc_primitives:CurrencyId",
                "[U8; 32]",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "CurrencyId",
                "AccountId",
                "Balance",
                "Balance"
              ]
            }
          ],
          "events_value": {
            "type": 36
          },
          "constants": [
            {
              "name": "MaxLocks",
              "type": "U32",
              "type_value": 4,
              "constants_value": "32000000",
              "docs": null
            }
          ],
          "errors": [
            {
              "name": "BalanceTooLow",
              "doc": [
                "The balance is too low"
              ]
            },
            {
              "name": "AmountIntoBalanceFailed",
              "doc": [
                "Cannot convert Amount into Balance type"
              ]
            },
            {
              "name": "LiquidityRestrictions",
              "doc": [
                "Failed because liquidity restrictions due to locking"
              ]
            },
            {
              "name": "MaxLocksExceeded",
              "doc": [
                "Failed because the maximum locks was exceeded"
              ]
            },
            {
              "name": "KeepAlive",
              "doc": [
                "Transfer/payment would kill account"
              ]
            },
            {
              "name": "ExistentialDeposit",
              "doc": [
                "Value too low to create account due to existential deposit"
              ]
            },
            {
              "name": "DeadAccount",
              "doc": [
                "Beneficiary account must pre-exist"
              ]
            }
          ],
          "errors_value": {
            "type": 313
          },
          "index": 8
        },
        {
          "name": "Escrow",
          "prefix": "Escrow",
          "storage": [
            {
              "name": "Reserved",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "U128",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": null
            },
            {
              "name": "Locked",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "escrow:LockedBalance",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x0000000000000000000000000000000000000000",
              "docs": null
            },
            {
              "name": "Epoch",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": null
            },
            {
              "name": "PointHistory",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Identity"
                  ],
                  "key_vec": [
                    "U32"
                  ],
                  "value": "escrow:Point",
                  "keys_id": 4,
                  "value_id": 0
                }
              },
              "fallback": "0x000000000000000000000000000000000000000000000000000000000000000000000000",
              "docs": null
            },
            {
              "name": "UserPointHistory",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Identity"
                  ],
                  "key_vec": [
                    "[U8; 32]",
                    "U32"
                  ],
                  "value": "escrow:Point",
                  "keys_id": 316,
                  "value_id": 0
                }
              },
              "fallback": "0x000000000000000000000000000000000000000000000000000000000000000000000000",
              "docs": null
            },
            {
              "name": "UserPointEpoch",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "U32",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000",
              "docs": null
            },
            {
              "name": "SlopeChanges",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32"
                  ],
                  "value": "U128",
                  "keys_id": 4,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": null
            },
            {
              "name": "Limits",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "Tuple:U32U32",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": null
            },
            {
              "name": "Blocks",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "Bool",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": null
            }
          ],
          "calls": [
            {
              "lookup": "0900",
              "name": "create_lock",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                },
                {
                  "TypeName": "",
                  "name": "unlock_height",
                  "type": "U32",
                  "type_name": "BlockNumber"
                }
              ]
            },
            {
              "lookup": "0901",
              "name": "increase_amount",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "0902",
              "name": "increase_unlock_height",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "unlock_height",
                  "type": "U32",
                  "type_name": "BlockNumber"
                }
              ]
            },
            {
              "lookup": "0903",
              "name": "withdraw",
              "docs": null,
              "args": null
            },
            {
              "lookup": "0904",
              "name": "set_account_limit",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "who",
                  "type": "[U8; 32]",
                  "type_name": "AccountId"
                },
                {
                  "TypeName": "",
                  "name": "start",
                  "type": "U32",
                  "type_name": "BlockNumber"
                },
                {
                  "TypeName": "",
                  "name": "end",
                  "type": "U32",
                  "type_name": "BlockNumber"
                }
              ]
            },
            {
              "lookup": "0905",
              "name": "set_account_block",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "who",
                  "type": "[U8; 32]",
                  "type_name": "AccountId"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 168
          },
          "events": [
            {
              "lookup": "0900",
              "name": "Deposit",
              "docs": null,
              "args": [
                "[U8; 32]",
                "U128",
                "U32"
              ],
              "args_type_name": [
                "AccountId",
                "BalanceOf",
                "BlockNumber"
              ]
            },
            {
              "lookup": "0901",
              "name": "Withdraw",
              "docs": null,
              "args": [
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "AccountId",
                "BalanceOf"
              ]
            }
          ],
          "events_value": {
            "type": 40
          },
          "constants": [
            {
              "name": "Span",
              "type": "U32",
              "type_value": 4,
              "constants_value": "e0c40000",
              "docs": [
                " All future times are rounded by this."
              ]
            },
            {
              "name": "MaxPeriod",
              "type": "U32",
              "type_value": 4,
              "constants_value": "00d44900",
              "docs": [
                " The maximum time for locks."
              ]
            }
          ],
          "errors": [
            {
              "name": "InputAmountZero",
              "doc": [
                "Input amount must be non-zero."
              ]
            },
            {
              "name": "LockFound",
              "doc": [
                "Lock already exists."
              ]
            },
            {
              "name": "LockNotFound",
              "doc": [
                "Lock does not exist."
              ]
            },
            {
              "name": "UnlockHeightNotInTheFuture",
              "doc": [
                "Unlock height is not in the future."
              ]
            },
            {
              "name": "UnlockHeightTooFarInTheFuture",
              "doc": [
                "Unlock height is greater than max period."
              ]
            },
            {
              "name": "LockAmountZero",
              "doc": [
                "Lock amount must be non-zero."
              ]
            },
            {
              "name": "UnlockHeightMustIncrease",
              "doc": [
                "Unlock height should be greater than lock."
              ]
            },
            {
              "name": "LockNotExpired",
              "doc": [
                "Previous lock has not expired."
              ]
            },
            {
              "name": "LockHasExpired",
              "doc": [
                "Previous lock has expired."
              ]
            },
            {
              "name": "LockAmountTooLarge",
              "doc": [
                "Lock amount is too large."
              ]
            },
            {
              "name": "InsufficientFunds",
              "doc": [
                "Insufficient account balance."
              ]
            },
            {
              "name": "NotSupported",
              "doc": [
                "Not supported."
              ]
            }
          ],
          "errors_value": {
            "type": 317
          },
          "index": 9
        },
        {
          "name": "Vesting",
          "prefix": "Vesting",
          "storage": [
            {
              "name": "VestingSchedules",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "Vec\u003corml_vesting:VestingSchedule\u003e",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Vesting schedules of an account.",
                "",
                " VestingSchedules: map AccountId =\u003e Vec\u003cVestingSchedule\u003e"
              ]
            }
          ],
          "calls": [
            {
              "lookup": "0a00",
              "name": "claim",
              "docs": null,
              "args": null
            },
            {
              "lookup": "0a01",
              "name": "vested_transfer",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                },
                {
                  "TypeName": "",
                  "name": "schedule",
                  "type": "orml_vesting:VestingSchedule",
                  "type_name": "VestingScheduleOf"
                }
              ]
            },
            {
              "lookup": "0a02",
              "name": "update_vesting_schedules",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "who",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                },
                {
                  "TypeName": "",
                  "name": "vesting_schedules",
                  "type": "Vec\u003corml_vesting:VestingSchedule\u003e",
                  "type_name": "Vec\u003cVestingScheduleOf\u003e"
                }
              ]
            },
            {
              "lookup": "0a03",
              "name": "claim_for",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 169
          },
          "events": [
            {
              "lookup": "0a00",
              "name": "VestingScheduleAdded",
              "docs": [
                "Added new vesting schedule."
              ],
              "args": [
                "[U8; 32]",
                "[U8; 32]",
                "orml_vesting:VestingSchedule"
              ],
              "args_type_name": [
                "AccountId",
                "AccountId",
                "VestingScheduleOf"
              ]
            },
            {
              "lookup": "0a01",
              "name": "Claimed",
              "docs": [
                "Claimed vesting."
              ],
              "args": [
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "AccountId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "0a02",
              "name": "VestingSchedulesUpdated",
              "docs": [
                "Updated vesting schedules."
              ],
              "args": [
                "[U8; 32]"
              ],
              "args_type_name": [
                "AccountId"
              ]
            }
          ],
          "events_value": {
            "type": 41
          },
          "constants": [
            {
              "name": "MinVestedTransfer",
              "type": "U128",
              "type_value": 6,
              "constants_value": "00000000000000000000000000000000",
              "docs": [
                " The minimum amount transferred to call `vested_transfer`."
              ]
            }
          ],
          "errors": [
            {
              "name": "ZeroVestingPeriod",
              "doc": [
                "Vesting period is zero"
              ]
            },
            {
              "name": "ZeroVestingPeriodCount",
              "doc": [
                "Number of vests is zero"
              ]
            },
            {
              "name": "InsufficientBalanceToLock",
              "doc": [
                "Insufficient amount of balance to lock"
              ]
            },
            {
              "name": "TooManyVestingSchedules",
              "doc": [
                "This account have too many vesting schedules"
              ]
            },
            {
              "name": "AmountLow",
              "doc": [
                "The vested transfer amount is too low"
              ]
            },
            {
              "name": "MaxVestingSchedulesExceeded",
              "doc": [
                "Failed because the maximum vesting schedules was exceeded"
              ]
            }
          ],
          "errors_value": {
            "type": 319
          },
          "index": 10
        },
        {
          "name": "EscrowAnnuity",
          "prefix": "EscrowAnnuity",
          "storage": [
            {
              "name": "RewardPerBlock",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 6
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": null
            }
          ],
          "calls": [
            {
              "lookup": "0b00",
              "name": "withdraw_rewards",
              "docs": null,
              "args": null
            },
            {
              "lookup": "0b01",
              "name": "update_rewards",
              "docs": null,
              "args": null
            }
          ],
          "calls_value": {
            "type": 171
          },
          "events": [
            {
              "lookup": "0b00",
              "name": "BlockReward",
              "docs": null,
              "args": [
                "U128"
              ],
              "args_type_name": [
                "BalanceOf"
              ]
            }
          ],
          "events_value": {
            "type": 44
          },
          "constants": [
            {
              "name": "AnnuityPalletId",
              "type": "[U8; 8]",
              "type_value": 320,
              "constants_value": "esc/annu",
              "docs": [
                " The annuity module id, used for deriving its sovereign account ID."
              ]
            },
            {
              "name": "EmissionPeriod",
              "type": "U32",
              "type_value": 4,
              "constants_value": "a0192800",
              "docs": [
                " The emission period for block rewards."
              ]
            }
          ],
          "errors": null,
          "errors_value": {
            "type": 321
          },
          "index": 11
        },
        {
          "name": "EscrowRewards",
          "prefix": "EscrowRewards",
          "storage": [
            {
              "name": "TotalStake",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "I128",
                "PlainTypeValue": 46
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The total stake deposited to this reward pool."
              ]
            },
            {
              "name": "TotalRewards",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:CurrencyId"
                  ],
                  "value": "I128",
                  "keys_id": 37,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The total unclaimed rewards distributed to this reward pool.",
                " NOTE: this is currently only used for integration tests."
              ]
            },
            {
              "name": "RewardPerToken",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:CurrencyId"
                  ],
                  "value": "I128",
                  "keys_id": 37,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Used to compute the rewards for a participant's stake."
              ]
            },
            {
              "name": "Stake",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "I128",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The stake of a participant in this reward pool."
              ]
            },
            {
              "name": "RewardTally",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:CurrencyId",
                    "[U8; 32]"
                  ],
                  "value": "I128",
                  "keys_id": 322,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Accounts for previous changes in stake size."
              ]
            }
          ],
          "events": [
            {
              "lookup": "0c00",
              "name": "DepositStake",
              "docs": null,
              "args": [
                "[U8; 32]",
                "I128"
              ],
              "args_type_name": [
                "RewardId",
                "SignedFixedPoint"
              ]
            },
            {
              "lookup": "0c01",
              "name": "DistributeReward",
              "docs": null,
              "args": [
                "interbtc_primitives:CurrencyId",
                "I128"
              ],
              "args_type_name": [
                "CurrencyId",
                "SignedFixedPoint"
              ]
            },
            {
              "lookup": "0c02",
              "name": "WithdrawStake",
              "docs": null,
              "args": [
                "[U8; 32]",
                "I128"
              ],
              "args_type_name": [
                "RewardId",
                "SignedFixedPoint"
              ]
            },
            {
              "lookup": "0c03",
              "name": "WithdrawReward",
              "docs": null,
              "args": [
                "[U8; 32]",
                "interbtc_primitives:CurrencyId",
                "I128"
              ],
              "args_type_name": [
                "RewardId",
                "CurrencyId",
                "SignedFixedPoint"
              ]
            }
          ],
          "events_value": {
            "type": 45
          },
          "constants": [
            {
              "name": "GetNativeCurrencyId",
              "type": "interbtc_primitives:CurrencyId",
              "type_value": 37,
              "constants_value": "000c",
              "docs": null
            },
            {
              "name": "GetWrappedCurrencyId",
              "type": "interbtc_primitives:CurrencyId",
              "type_value": 37,
              "constants_value": "000b",
              "docs": null
            }
          ],
          "errors": [
            {
              "name": "TryIntoIntError",
              "doc": [
                "Unable to convert value."
              ]
            },
            {
              "name": "InsufficientFunds",
              "doc": [
                "Balance not sufficient to withdraw stake."
              ]
            },
            {
              "name": "ZeroTotalStake",
              "doc": [
                "Cannot distribute rewards without stake."
              ]
            }
          ],
          "errors_value": {
            "type": 323
          },
          "index": 12
        },
        {
          "name": "VaultAnnuity",
          "prefix": "VaultAnnuity",
          "storage": [
            {
              "name": "RewardPerBlock",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 6
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": null
            }
          ],
          "calls": [
            {
              "lookup": "0d00",
              "name": "withdraw_rewards",
              "docs": null,
              "args": null
            },
            {
              "lookup": "0d01",
              "name": "update_rewards",
              "docs": null,
              "args": null
            }
          ],
          "calls_value": {
            "type": 172
          },
          "events": [
            {
              "lookup": "0d00",
              "name": "BlockReward",
              "docs": null,
              "args": [
                "U128"
              ],
              "args_type_name": [
                "BalanceOf"
              ]
            }
          ],
          "events_value": {
            "type": 48
          },
          "constants": [
            {
              "name": "AnnuityPalletId",
              "type": "[U8; 8]",
              "type_value": 320,
              "constants_value": "vlt/annu",
              "docs": [
                " The annuity module id, used for deriving its sovereign account ID."
              ]
            },
            {
              "name": "EmissionPeriod",
              "type": "U32",
              "type_value": 4,
              "constants_value": "a0192800",
              "docs": [
                " The emission period for block rewards."
              ]
            }
          ],
          "errors": null,
          "errors_value": {
            "type": 324
          },
          "index": 13
        },
        {
          "name": "VaultRewards",
          "prefix": "VaultRewards",
          "storage": [
            {
              "name": "TotalStake",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "I128",
                "PlainTypeValue": 46
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The total stake deposited to this reward pool."
              ]
            },
            {
              "name": "TotalRewards",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:CurrencyId"
                  ],
                  "value": "I128",
                  "keys_id": 37,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The total unclaimed rewards distributed to this reward pool.",
                " NOTE: this is currently only used for integration tests."
              ]
            },
            {
              "name": "RewardPerToken",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:CurrencyId"
                  ],
                  "value": "I128",
                  "keys_id": 37,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Used to compute the rewards for a participant's stake."
              ]
            },
            {
              "name": "Stake",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:VaultId"
                  ],
                  "value": "I128",
                  "keys_id": 50,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The stake of a participant in this reward pool."
              ]
            },
            {
              "name": "RewardTally",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:CurrencyId",
                    "interbtc_primitives:VaultId"
                  ],
                  "value": "I128",
                  "keys_id": 325,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Accounts for previous changes in stake size."
              ]
            }
          ],
          "events": [
            {
              "lookup": "0e00",
              "name": "DepositStake",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "I128"
              ],
              "args_type_name": [
                "RewardId",
                "SignedFixedPoint"
              ]
            },
            {
              "lookup": "0e01",
              "name": "DistributeReward",
              "docs": null,
              "args": [
                "interbtc_primitives:CurrencyId",
                "I128"
              ],
              "args_type_name": [
                "CurrencyId",
                "SignedFixedPoint"
              ]
            },
            {
              "lookup": "0e02",
              "name": "WithdrawStake",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "I128"
              ],
              "args_type_name": [
                "RewardId",
                "SignedFixedPoint"
              ]
            },
            {
              "lookup": "0e03",
              "name": "WithdrawReward",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "interbtc_primitives:CurrencyId",
                "I128"
              ],
              "args_type_name": [
                "RewardId",
                "CurrencyId",
                "SignedFixedPoint"
              ]
            }
          ],
          "events_value": {
            "type": 49
          },
          "constants": [
            {
              "name": "GetNativeCurrencyId",
              "type": "interbtc_primitives:CurrencyId",
              "type_value": 37,
              "constants_value": "000c",
              "docs": null
            },
            {
              "name": "GetWrappedCurrencyId",
              "type": "interbtc_primitives:CurrencyId",
              "type_value": 37,
              "constants_value": "000b",
              "docs": null
            }
          ],
          "errors": [
            {
              "name": "TryIntoIntError",
              "doc": [
                "Unable to convert value."
              ]
            },
            {
              "name": "InsufficientFunds",
              "doc": [
                "Balance not sufficient to withdraw stake."
              ]
            },
            {
              "name": "ZeroTotalStake",
              "doc": [
                "Cannot distribute rewards without stake."
              ]
            }
          ],
          "errors_value": {
            "type": 326
          },
          "index": 14
        },
        {
          "name": "VaultStaking",
          "prefix": "VaultStaking",
          "storage": [
            {
              "name": "TotalStake",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32",
                    "interbtc_primitives:VaultId"
                  ],
                  "value": "I128",
                  "keys_id": 327,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The total stake - this will increase on deposit and decrease on withdrawal."
              ]
            },
            {
              "name": "TotalCurrentStake",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32",
                    "interbtc_primitives:VaultId"
                  ],
                  "value": "I128",
                  "keys_id": 327,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The total stake - this will increase on deposit and decrease on withdrawal or slashing."
              ]
            },
            {
              "name": "TotalRewards",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:CurrencyId",
                    "Tuple:U32interbtc_primitives:VaultId"
                  ],
                  "value": "I128",
                  "keys_id": 328,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The total unclaimed rewards distributed to this reward pool.",
                " NOTE: this is currently only used for integration tests."
              ]
            },
            {
              "name": "RewardPerToken",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:CurrencyId",
                    "Tuple:U32interbtc_primitives:VaultId"
                  ],
                  "value": "I128",
                  "keys_id": 328,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Used to compute the rewards for a participant's stake."
              ]
            },
            {
              "name": "SlashPerToken",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32",
                    "interbtc_primitives:VaultId"
                  ],
                  "value": "I128",
                  "keys_id": 327,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Used to compute the amount to slash from a participant's stake."
              ]
            },
            {
              "name": "Stake",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32",
                    "Tuple:interbtc_primitives:VaultId[U8; 32]"
                  ],
                  "value": "I128",
                  "keys_id": 329,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The stake of a participant in this reward pool."
              ]
            },
            {
              "name": "RewardTally",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:CurrencyId",
                    "Tuple:U32interbtc_primitives:VaultId[U8; 32]"
                  ],
                  "value": "I128",
                  "keys_id": 331,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Accounts for previous changes in stake size."
              ]
            },
            {
              "name": "SlashTally",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32",
                    "Tuple:interbtc_primitives:VaultId[U8; 32]"
                  ],
                  "value": "I128",
                  "keys_id": 329,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Accounts for previous changes in stake size."
              ]
            },
            {
              "name": "Nonce",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:VaultId"
                  ],
                  "value": "U32",
                  "keys_id": 50,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000",
              "docs": [
                " The nonce of the current staking pool, used in force refunds.",
                " This is a strictly increasing value."
              ]
            }
          ],
          "events": [
            {
              "lookup": "0f00",
              "name": "DepositStake",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "[U8; 32]",
                "I128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "AccountId",
                "SignedFixedPoint"
              ]
            },
            {
              "lookup": "0f01",
              "name": "DistributeReward",
              "docs": null,
              "args": [
                "interbtc_primitives:CurrencyId",
                "interbtc_primitives:VaultId",
                "I128"
              ],
              "args_type_name": [
                "CurrencyId",
                "DefaultVaultId",
                "SignedFixedPoint"
              ]
            },
            {
              "lookup": "0f02",
              "name": "WithdrawStake",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "[U8; 32]",
                "I128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "AccountId",
                "SignedFixedPoint"
              ]
            },
            {
              "lookup": "0f03",
              "name": "WithdrawReward",
              "docs": null,
              "args": [
                "U32",
                "interbtc_primitives:CurrencyId",
                "interbtc_primitives:VaultId",
                "[U8; 32]",
                "I128"
              ],
              "args_type_name": [
                "Index",
                "CurrencyId",
                "DefaultVaultId",
                "AccountId",
                "SignedFixedPoint"
              ]
            },
            {
              "lookup": "0f04",
              "name": "ForceRefund",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId"
              ],
              "args_type_name": [
                "DefaultVaultId"
              ]
            },
            {
              "lookup": "0f05",
              "name": "IncreaseNonce",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U32"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "Index"
              ]
            }
          ],
          "events_value": {
            "type": 52
          },
          "constants": [
            {
              "name": "GetNativeCurrencyId",
              "type": "interbtc_primitives:CurrencyId",
              "type_value": 37,
              "constants_value": "000c",
              "docs": null
            }
          ],
          "errors": [
            {
              "name": "TryIntoIntError",
              "doc": [
                "Unable to convert value."
              ]
            },
            {
              "name": "InsufficientFunds",
              "doc": [
                "Balance not sufficient to withdraw stake."
              ]
            },
            {
              "name": "SlashZeroTotalStake",
              "doc": [
                "Cannot slash zero total stake."
              ]
            }
          ],
          "errors_value": {
            "type": 333
          },
          "index": 15
        },
        {
          "name": "Supply",
          "prefix": "Supply",
          "storage": [
            {
              "name": "StartHeight",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00",
              "docs": null
            },
            {
              "name": "LastEmission",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 6
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": null
            },
            {
              "name": "Inflation",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 73
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": null
            }
          ],
          "calls": [
            {
              "lookup": "1000",
              "name": "set_start_height_and_inflation",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "start_height",
                  "type": "U32",
                  "type_name": "BlockNumber"
                },
                {
                  "TypeName": "",
                  "name": "inflation",
                  "type": "U128",
                  "type_name": "UnsignedFixedPoint"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 173
          },
          "events": [
            {
              "lookup": "1000",
              "name": "Inflation",
              "docs": null,
              "args": [
                "U128"
              ],
              "args_type_name": [
                "BalanceOf"
              ]
            }
          ],
          "events_value": {
            "type": 53
          },
          "constants": [
            {
              "name": "SupplyPalletId",
              "type": "[U8; 8]",
              "type_value": 320,
              "constants_value": "mod/supl",
              "docs": [
                " The supply module id, used for deriving its sovereign account ID."
              ]
            },
            {
              "name": "InflationPeriod",
              "type": "U32",
              "type_value": 4,
              "constants_value": "a0192800",
              "docs": [
                " The period between inflation updates."
              ]
            }
          ],
          "errors": null,
          "errors_value": {
            "type": 334
          },
          "index": 16
        },
        {
          "name": "BTCRelay",
          "prefix": "BTCRelay",
          "storage": [
            {
              "name": "BlockHeaders",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "btc_relay:types:RichBlockHeader",
                  "keys_id": 55,
                  "value_id": 0
                }
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " Store Bitcoin block headers"
              ]
            },
            {
              "name": "Chains",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32"
                  ],
                  "value": "U32",
                  "keys_id": 4,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Priority queue of BlockChain elements, ordered by the maximum height (descending).",
                " The first index into this mapping (0) is considered to be the longest chain. The value",
                " of the entry is the index into `ChainsIndex` to retrieve the `BlockChain`."
              ]
            },
            {
              "name": "ChainsIndex",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32"
                  ],
                  "value": "bitcoin:types:BlockChain",
                  "keys_id": 4,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Auxiliary mapping of chains ids to `BlockChain` entries. The first index into this",
                " mapping (0) is considered to be the Bitcoin main chain."
              ]
            },
            {
              "name": "ChainsHashes",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32",
                    "U32"
                  ],
                  "value": "[U8; 32]",
                  "keys_id": 30,
                  "value_id": 0
                }
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " Stores a mapping from (chain_index, block_height) to block hash"
              ]
            },
            {
              "name": "BestBlock",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "[U8; 32]",
                "PlainTypeValue": 55
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " Store the current blockchain tip"
              ]
            },
            {
              "name": "BestBlockHeight",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " Store the height of the best block"
              ]
            },
            {
              "name": "StartBlockHeight",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " BTC height when the relay was initialized"
              ]
            },
            {
              "name": "ChainCounter",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " Increment-only counter used to track new BlockChain entries"
              ]
            },
            {
              "name": "StableBitcoinConfirmations",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " Global security parameter k for stable Bitcoin transactions"
              ]
            },
            {
              "name": "StableParachainConfirmations",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " Global security parameter k for stable Parachain transactions"
              ]
            },
            {
              "name": "DisableDifficultyCheck",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Bool",
                "PlainTypeValue": 68
              },
              "fallback": "0x00",
              "docs": [
                " Whether the module should perform difficulty checks."
              ]
            },
            {
              "name": "DisableInclusionCheck",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Bool",
                "PlainTypeValue": 68
              },
              "fallback": "0x00",
              "docs": [
                " Whether the module should perform inclusion checks."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1100",
              "name": "verify_and_validate_transaction",
              "docs": [
                "Verifies the inclusion of `tx_id` into the relay, and validates the given raw Bitcoin transaction, according",
                "to the supported transaction format (see \u003chttps://spec.interlay.io/intro/accepted-format.html\u003e)",
                "",
                "# Arguments",
                "",
                "* `raw_merkle_proof` - The raw merkle proof as returned by bitcoin `gettxoutproof`",
                "* `confirmations` - The number of confirmations needed to accept the proof. If `none`, the value stored in",
                "  the StableBitcoinConfirmations storage item is used.",
                "* `raw_tx` - raw Bitcoin transaction",
                "* `expected_btc` - expected amount of BTC (satoshis) sent to the recipient",
                "* `recipient_btc_address` - 20 byte Bitcoin address of recipient of the BTC in the 1st  / payment UTXO",
                "* `op_return_id` - 32 byte hash identifier expected in OP_RETURN (replay protection)"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "raw_merkle_proof",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                },
                {
                  "TypeName": "",
                  "name": "confirmations",
                  "type": "option\u003cU32\u003e",
                  "type_name": "Option\u003cu32\u003e"
                },
                {
                  "TypeName": "",
                  "name": "raw_tx",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                },
                {
                  "TypeName": "",
                  "name": "expected_btc",
                  "type": "I64",
                  "type_name": "Value"
                },
                {
                  "TypeName": "",
                  "name": "recipient_btc_address",
                  "type": "bitcoin:address:Address",
                  "type_name": "BtcAddress"
                },
                {
                  "TypeName": "",
                  "name": "op_return_id",
                  "type": "option\u003cH256\u003e",
                  "type_name": "Option\u003cH256\u003e"
                }
              ]
            },
            {
              "lookup": "1101",
              "name": "verify_transaction_inclusion",
              "docs": [
                "Verifies the inclusion of `tx_id`",
                "",
                "# Arguments",
                "",
                "* `tx_id` - The hash of the transaction to check for",
                "* `raw_merkle_proof` - The raw merkle proof as returned by bitcoin `gettxoutproof`",
                "* `confirmations` - The number of confirmations needed to accept the proof. If `none`, the value stored in",
                "  the `StableBitcoinConfirmations` storage item is used.",
                "",
                "# \u003cweight\u003e",
                "Key: C (len of chains), P (len of positions)",
                "- Storage Reads:",
                "\t- One storage read to check if inclusion check is disabled. O(1)",
                "\t- One storage read to retrieve best block height. O(1)",
                "\t- One storage read to check if transaction is in active fork. O(1)",
                "\t- One storage read to retrieve block header. O(1)",
                "\t- One storage read to check that parachain is not shutdown. O(1)",
                "\t- One storage read to check stable bitcoin confirmations. O(1)",
                "\t- One storage read to check stable parachain confirmations. O(1)",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "tx_id",
                  "type": "[U8; 32]",
                  "type_name": "H256Le"
                },
                {
                  "TypeName": "",
                  "name": "raw_merkle_proof",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                },
                {
                  "TypeName": "",
                  "name": "confirmations",
                  "type": "option\u003cU32\u003e",
                  "type_name": "Option\u003cu32\u003e"
                }
              ]
            },
            {
              "lookup": "1102",
              "name": "validate_transaction",
              "docs": [
                "Validates a given raw Bitcoin transaction, according to the supported transaction",
                "format (see \u003chttps://spec.interlay.io/intro/accepted-format.html\u003e)",
                "This DOES NOT check if the transaction is included in a block, nor does it guarantee that the",
                "transaction is fully valid according to the consensus (needs full node).",
                "",
                "# Arguments",
                "* `raw_tx` - raw Bitcoin transaction",
                "* `expected_btc` - expected amount of BTC (satoshis) sent to the recipient",
                "* `recipient_btc_address` - expected Bitcoin address of recipient (p2sh, p2pkh, p2wpkh)",
                "* `op_return_id` - 32 byte hash identifier expected in OP_RETURN (replay protection)"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "raw_tx",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                },
                {
                  "TypeName": "",
                  "name": "expected_btc",
                  "type": "I64",
                  "type_name": "Value"
                },
                {
                  "TypeName": "",
                  "name": "recipient_btc_address",
                  "type": "bitcoin:address:Address",
                  "type_name": "BtcAddress"
                },
                {
                  "TypeName": "",
                  "name": "op_return_id",
                  "type": "option\u003cH256\u003e",
                  "type_name": "Option\u003cH256\u003e"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 174
          },
          "events": [
            {
              "lookup": "1100",
              "name": "Initialized",
              "docs": null,
              "args": [
                "U32",
                "[U8; 32]",
                "[U8; 32]"
              ],
              "args_type_name": [
                "u32",
                "H256Le",
                "AccountId"
              ]
            },
            {
              "lookup": "1101",
              "name": "StoreMainChainHeader",
              "docs": null,
              "args": [
                "U32",
                "[U8; 32]",
                "[U8; 32]"
              ],
              "args_type_name": [
                "u32",
                "H256Le",
                "AccountId"
              ]
            },
            {
              "lookup": "1102",
              "name": "StoreForkHeader",
              "docs": null,
              "args": [
                "U32",
                "U32",
                "[U8; 32]",
                "[U8; 32]"
              ],
              "args_type_name": [
                "u32",
                "u32",
                "H256Le",
                "AccountId"
              ]
            },
            {
              "lookup": "1103",
              "name": "ChainReorg",
              "docs": null,
              "args": [
                "[U8; 32]",
                "U32",
                "U32"
              ],
              "args_type_name": [
                "H256Le",
                "u32",
                "u32"
              ]
            },
            {
              "lookup": "1104",
              "name": "ForkAheadOfMainChain",
              "docs": null,
              "args": [
                "U32",
                "U32",
                "U32"
              ],
              "args_type_name": [
                "u32",
                "u32",
                "u32"
              ]
            }
          ],
          "events_value": {
            "type": 54
          },
          "constants": [
            {
              "name": "ParachainBlocksPerBitcoinBlock",
              "type": "U32",
              "type_value": 4,
              "constants_value": "32000000",
              "docs": null
            }
          ],
          "errors": [
            {
              "name": "AlreadyInitialized",
              "doc": [
                "Already initialized"
              ]
            },
            {
              "name": "InvalidStartHeight",
              "doc": [
                "Start height must be start of difficulty period"
              ]
            },
            {
              "name": "MissingBlockHeight",
              "doc": [
                "Missing the block at this height"
              ]
            },
            {
              "name": "InvalidHeaderSize",
              "doc": [
                "Invalid block header size"
              ]
            },
            {
              "name": "DuplicateBlock",
              "doc": [
                "Block already stored"
              ]
            },
            {
              "name": "OutdatedBlock",
              "doc": [
                "Block already stored and is not head"
              ]
            },
            {
              "name": "PrevBlock",
              "doc": [
                "Previous block hash not found"
              ]
            },
            {
              "name": "InvalidChainID",
              "doc": [
                "Invalid chain ID"
              ]
            },
            {
              "name": "LowDiff",
              "doc": [
                "PoW hash does not meet difficulty target of header"
              ]
            },
            {
              "name": "DiffTargetHeader",
              "doc": [
                "Incorrect difficulty target specified in block header"
              ]
            },
            {
              "name": "MalformedTxid",
              "doc": [
                "Malformed transaction identifier"
              ]
            },
            {
              "name": "BitcoinConfirmations",
              "doc": [
                "Transaction has less confirmations of Bitcoin blocks than required"
              ]
            },
            {
              "name": "ParachainConfirmations",
              "doc": [
                "Transaction has less confirmations of Parachain blocks than required"
              ]
            },
            {
              "name": "OngoingFork",
              "doc": [
                "Current fork ongoing"
              ]
            },
            {
              "name": "MalformedMerkleProof",
              "doc": [
                "Merkle proof is malformed"
              ]
            },
            {
              "name": "InvalidMerkleProof",
              "doc": [
                "Invalid merkle proof"
              ]
            },
            {
              "name": "Shutdown",
              "doc": [
                "BTC Parachain has shut down"
              ]
            },
            {
              "name": "InvalidTxid",
              "doc": [
                "Transaction hash does not match given txid"
              ]
            },
            {
              "name": "InvalidPaymentAmount",
              "doc": [
                "Invalid payment amount"
              ]
            },
            {
              "name": "MalformedTransaction",
              "doc": [
                "Transaction has incorrect format"
              ]
            },
            {
              "name": "InvalidPayment",
              "doc": [
                "Incorrect recipient Bitcoin address"
              ]
            },
            {
              "name": "InvalidOutputFormat",
              "doc": [
                "Incorrect transaction output format"
              ]
            },
            {
              "name": "InvalidOpReturn",
              "doc": [
                "Incorrect identifier in OP_RETURN field"
              ]
            },
            {
              "name": "InvalidTxVersion",
              "doc": [
                "Invalid transaction version"
              ]
            },
            {
              "name": "UnknownErrorcode",
              "doc": [
                "Error code not applicable to blocks"
              ]
            },
            {
              "name": "ForkIdNotFound",
              "doc": [
                "Blockchain with requested ID not found"
              ]
            },
            {
              "name": "BlockNotFound",
              "doc": [
                "Block header not found for given hash"
              ]
            },
            {
              "name": "AlreadyReported",
              "doc": [
                "Error code already reported"
              ]
            },
            {
              "name": "UnauthorizedRelayer",
              "doc": [
                "Unauthorized staked relayer"
              ]
            },
            {
              "name": "ChainCounterOverflow",
              "doc": [
                "Overflow of chain counter"
              ]
            },
            {
              "name": "BlockHeightOverflow",
              "doc": [
                "Overflow of block height"
              ]
            },
            {
              "name": "ChainsUnderflow",
              "doc": [
                "Underflow of stored blockchains counter"
              ]
            },
            {
              "name": "EndOfFile",
              "doc": [
                "EndOfFile reached while parsing"
              ]
            },
            {
              "name": "MalformedHeader",
              "doc": [
                "Format of the header is invalid"
              ]
            },
            {
              "name": "InvalidBlockVersion",
              "doc": [
                "Invalid block header version"
              ]
            },
            {
              "name": "MalformedWitnessOutput",
              "doc": [
                "Format of the BIP141 witness transaction output is invalid"
              ]
            },
            {
              "name": "MalformedP2PKHOutput",
              "doc": null
            },
            {
              "name": "MalformedP2SHOutput",
              "doc": null
            },
            {
              "name": "MalformedOpReturnOutput",
              "doc": [
                "Format of the OP_RETURN transaction output is invalid"
              ]
            },
            {
              "name": "UnsupportedOutputFormat",
              "doc": null
            },
            {
              "name": "UnsupportedInputFormat",
              "doc": null
            },
            {
              "name": "InvalidBtcHash",
              "doc": [
                "User supplied an invalid address"
              ]
            },
            {
              "name": "InvalidScript",
              "doc": [
                "User supplied an invalid script"
              ]
            },
            {
              "name": "InvalidBtcAddress",
              "doc": [
                "Specified invalid Bitcoin address"
              ]
            },
            {
              "name": "ArithmeticOverflow",
              "doc": [
                "Arithmetic overflow"
              ]
            },
            {
              "name": "ArithmeticUnderflow",
              "doc": [
                "Arithmetic underflow"
              ]
            },
            {
              "name": "TryIntoIntError",
              "doc": [
                "TryInto failed on integer"
              ]
            },
            {
              "name": "InvalidTransaction",
              "doc": [
                "Transaction does meet the requirements to be considered valid"
              ]
            },
            {
              "name": "InvalidOpReturnTransaction",
              "doc": [
                "Transaction does meet the requirements to be a valid op-return payment"
              ]
            },
            {
              "name": "InvalidCompact",
              "doc": [
                "Invalid compact value in header"
              ]
            }
          ],
          "errors_value": {
            "type": 341
          },
          "index": 17
        },
        {
          "name": "Relay",
          "prefix": "Relay",
          "storage": [
            {
              "name": "TheftReports",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:VaultId",
                    "[U8; 32]"
                  ],
                  "value": "option\u003cNULL\u003e",
                  "keys_id": 342,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Mapping of Bitcoin transaction identifiers (SHA256 hashes) to account",
                " identifiers of Vaults accused of theft."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1200",
              "name": "initialize",
              "docs": [
                "One time function to initialize the BTC-Relay with the first block",
                "",
                "# Arguments",
                "",
                "* `block_header_bytes` - 80 byte raw Bitcoin block header.",
                "* `block_height` - starting Bitcoin block height of the submitted block header.",
                "",
                "# \u003cweight\u003e",
                "- Storage Reads:",
                "\t- One storage read to check that parachain is not shutdown. O(1)",
                "\t- One storage read to check if relayer authorization is disabled. O(1)",
                "\t- One storage read to check if relayer is authorized. O(1)",
                "- Storage Writes:",
                "    - One storage write to store block hash. O(1)",
                "    - One storage write to store block header. O(1)",
                "\t- One storage write to initialize main chain. O(1)",
                "    - One storage write to store best block hash. O(1)",
                "    - One storage write to store best block height. O(1)",
                "- Events:",
                "\t- One event for initialization.",
                "",
                "Total Complexity: O(1)",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "raw_block_header",
                  "type": "[U8; 80]",
                  "type_name": "RawBlockHeader"
                },
                {
                  "TypeName": "",
                  "name": "block_height",
                  "type": "U32",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "1201",
              "name": "store_block_header",
              "docs": [
                "Stores a single new block header",
                "",
                "# Arguments",
                "",
                "* `raw_block_header` - 80 byte raw Bitcoin block header.",
                "",
                "# \u003cweight\u003e",
                "Key: C (len of chains), P (len of positions)",
                "- Storage Reads:",
                "\t- One storage read to check that parachain is not shutdown. O(1)",
                "\t- One storage read to check if relayer authorization is disabled. O(1)",
                "\t- One storage read to check if relayer is authorized. O(1)",
                "\t- One storage read to check if block header is stored. O(1)",
                "\t- One storage read to retrieve parent block hash. O(1)",
                "\t- One storage read to check if difficulty check is disabled. O(1)",
                "\t- One storage read to retrieve last re-target. O(1)",
                "\t- One storage read to retrieve all Chains. O(C)",
                "- Storage Writes:",
                "    - One storage write to store block hash. O(1)",
                "    - One storage write to store block header. O(1)",
                "\t- One storage mutate to extend main chain. O(1)",
                "    - One storage write to store best block hash. O(1)",
                "    - One storage write to store best block height. O(1)",
                "- Notable Computation:",
                "\t- O(P) sort to reorg chains.",
                "- Events:",
                "\t- One event for block stored (fork or extension).",
                "",
                "Total Complexity: O(C + P)",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "raw_block_header",
                  "type": "[U8; 80]",
                  "type_name": "RawBlockHeader"
                }
              ]
            },
            {
              "lookup": "1202",
              "name": "report_vault_theft",
              "docs": [
                "Report misbehavior by a Vault, providing a fraud proof (malicious Bitcoin transaction",
                "and the corresponding transaction inclusion proof). This fully slashes the Vault.",
                "",
                "# Arguments",
                "",
                "* `origin`: Any signed user.",
                "* `vault_id`: The account of the vault to check.",
                "* `raw_merkle_proof`: The proof of tx inclusion.",
                "* `raw_tx`: The raw Bitcoin transaction."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "vault_id",
                  "type": "interbtc_primitives:VaultId",
                  "type_name": "DefaultVaultId"
                },
                {
                  "TypeName": "",
                  "name": "raw_merkle_proof",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                },
                {
                  "TypeName": "",
                  "name": "raw_tx",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "1203",
              "name": "report_vault_double_payment",
              "docs": [
                "Report Vault double payment, providing two fraud proofs (malicious Bitcoin transactions",
                "and the corresponding transaction inclusion proofs). This fully slashes the Vault.",
                "",
                "This can be used for any multiple of payments, i.e., a vault making two, three, four, etc. payments",
                "by proving just one double payment.",
                "",
                "# Arguments",
                "",
                "* `origin`: Any signed user.",
                "* `vault_id`: The account of the vault to check.",
                "* `raw_merkle_proofs`: The proofs of tx inclusion.",
                "* `raw_txs`: The raw Bitcoin transactions."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "vault_id",
                  "type": "interbtc_primitives:VaultId",
                  "type_name": "DefaultVaultId"
                },
                {
                  "TypeName": "",
                  "name": "raw_merkle_proofs",
                  "type": "Tuple:Vec\u003cU8\u003eVec\u003cU8\u003e",
                  "type_name": "(Vec\u003cu8\u003e, Vec\u003cu8\u003e)"
                },
                {
                  "TypeName": "",
                  "name": "raw_txs",
                  "type": "Tuple:Vec\u003cU8\u003eVec\u003cU8\u003e",
                  "type_name": "(Vec\u003cu8\u003e, Vec\u003cu8\u003e)"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 177
          },
          "events": [
            {
              "lookup": "1200",
              "name": "VaultTheft",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "[U8; 32]"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "H256Le"
              ]
            },
            {
              "lookup": "1201",
              "name": "VaultDoublePayment",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "[U8; 32]",
                "[U8; 32]"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "H256Le",
                "H256Le"
              ]
            }
          ],
          "events_value": {
            "type": 56
          },
          "errors": [
            {
              "name": "VaultAlreadyReported",
              "doc": [
                "Vault already reported"
              ]
            },
            {
              "name": "VaultNoInputToTransaction",
              "doc": [
                "Vault BTC address not in transaction input"
              ]
            },
            {
              "name": "ValidRedeemTransaction",
              "doc": [
                "Valid redeem transaction"
              ]
            },
            {
              "name": "ValidReplaceTransaction",
              "doc": [
                "Valid replace transaction"
              ]
            },
            {
              "name": "ValidRefundTransaction",
              "doc": [
                "Valid refund transaction"
              ]
            },
            {
              "name": "ValidMergeTransaction",
              "doc": [
                "Valid merge transaction"
              ]
            },
            {
              "name": "InvalidTransaction",
              "doc": [
                "Failed to parse transaction"
              ]
            },
            {
              "name": "TryIntoIntError",
              "doc": [
                "Unable to convert value"
              ]
            },
            {
              "name": "DuplicateTransaction",
              "doc": [
                "Expected two unique transactions"
              ]
            },
            {
              "name": "ExpectedDuplicate",
              "doc": [
                "Expected duplicate OP_RETURN ids"
              ]
            }
          ],
          "errors_value": {
            "type": 344
          },
          "index": 18
        },
        {
          "name": "Security",
          "prefix": "Security",
          "storage": [
            {
              "name": "ParachainStatus",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "security:types:StatusCode",
                "PlainTypeValue": 58
              },
              "fallback": "0x00",
              "docs": [
                " Integer/Enum defining the current state of the BTC-Parachain."
              ]
            },
            {
              "name": "Errors",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003csecurity:types:ErrorCode\u003e",
                "PlainTypeValue": 345
              },
              "fallback": "0x00",
              "docs": [
                " Set of ErrorCodes, indicating the reason for an \"Error\" ParachainStatus."
              ]
            },
            {
              "name": "Nonce",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U256",
                "PlainTypeValue": 337
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " Integer increment-only counter, used to prevent collisions when generating identifiers",
                " for e.g. issue, redeem or replace requests (for OP_RETURN field in Bitcoin)."
              ]
            },
            {
              "name": "ActiveBlockCount",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " Like frame_system::block_number, but this one only increments if the parachain status is RUNNING.",
                " This variable is used to keep track of durations, such as the issue/redeem/replace expiry. If the",
                " parachain is not RUNNING, no payment proofs can be submitted, and it wouldn't be fair to punish",
                " the user/vault. By using this variable we ensure that they have sufficient time to submit their",
                " proof."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1300",
              "name": "set_parachain_status",
              "docs": [
                "Set the parachain status code.",
                "",
                "# Arguments",
                "",
                "* `origin` - the dispatch origin of this call (must be _Root_)",
                "* `status_code` - the status code to set",
                "",
                "# Weight: `O(1)`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "status_code",
                  "type": "security:types:StatusCode",
                  "type_name": "StatusCode"
                }
              ]
            },
            {
              "lookup": "1301",
              "name": "insert_parachain_error",
              "docs": [
                "Insert a new parachain error.",
                "",
                "# Arguments",
                "",
                "* `origin` - the dispatch origin of this call (must be _Root_)",
                "* `error_code` - the error code to insert",
                "",
                "# Weight: `O(1)`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "error_code",
                  "type": "security:types:ErrorCode",
                  "type_name": "ErrorCode"
                }
              ]
            },
            {
              "lookup": "1302",
              "name": "remove_parachain_error",
              "docs": [
                "Remove a parachain error.",
                "",
                "# Arguments",
                "",
                "* `origin` - the dispatch origin of this call (must be _Root_)",
                "* `error_code` - the error code to remove",
                "",
                "# Weight: `O(1)`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "error_code",
                  "type": "security:types:ErrorCode",
                  "type_name": "ErrorCode"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 180
          },
          "events": [
            {
              "lookup": "1300",
              "name": "RecoverFromErrors",
              "docs": null,
              "args": [
                "security:types:StatusCode",
                "Vec\u003csecurity:types:ErrorCode\u003e"
              ],
              "args_type_name": [
                "StatusCode",
                "Vec\u003cErrorCode\u003e"
              ]
            },
            {
              "lookup": "1301",
              "name": "UpdateActiveBlock",
              "docs": null,
              "args": [
                "U32"
              ],
              "args_type_name": [
                "BlockNumber"
              ]
            }
          ],
          "events_value": {
            "type": 57
          },
          "errors": [
            {
              "name": "ParachainNotRunning",
              "doc": [
                "Parachain is not running."
              ]
            }
          ],
          "errors_value": {
            "type": 346
          },
          "index": 19
        },
        {
          "name": "VaultRegistry",
          "prefix": "VaultRegistry",
          "storage": [
            {
              "name": "MinimumCollateralVault",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:CurrencyId"
                  ],
                  "value": "U128",
                  "keys_id": 37,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The minimum collateral (e.g. DOT/KSM) a Vault needs to provide to register."
              ]
            },
            {
              "name": "PunishmentDelay",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " If a Vault fails to execute a correct redeem or replace, it is temporarily banned",
                " from further issue, redeem or replace requests. This value configures the duration",
                " of this ban (in number of blocks) ."
              ]
            },
            {
              "name": "SystemCollateralCeiling",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:VaultCurrencyPair"
                  ],
                  "value": "U128",
                  "keys_id": 51,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Determines the over-collateralization rate for collateral locked by Vaults, necessary for",
                " wrapped tokens. This threshold should be greater than the LiquidationCollateralThreshold."
              ]
            },
            {
              "name": "SecureCollateralThreshold",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:VaultCurrencyPair"
                  ],
                  "value": "U128",
                  "keys_id": 51,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Determines the over-collateralization rate for collateral locked by Vaults, necessary for",
                " wrapped tokens. This threshold should be greater than the LiquidationCollateralThreshold."
              ]
            },
            {
              "name": "PremiumRedeemThreshold",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:VaultCurrencyPair"
                  ],
                  "value": "U128",
                  "keys_id": 51,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Determines the rate for the collateral rate of Vaults, at which users receive a premium,",
                " allocated from the Vault's collateral, when performing a redeem with this Vault. This",
                " threshold should be greater than the LiquidationCollateralThreshold."
              ]
            },
            {
              "name": "LiquidationCollateralThreshold",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:VaultCurrencyPair"
                  ],
                  "value": "U128",
                  "keys_id": 51,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                "2044657465726d696e657320746865206c6f77657220626f756e6420666f722074686520636f6c6c61746572616c207261746520696e2069737375656420746f6b656e732e2049662061205661756c74e2809973",
                " collateral rate drops below this, automatic liquidation (forced Redeem) is triggered."
              ]
            },
            {
              "name": "LiquidationVault",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:VaultCurrencyPair"
                  ],
                  "value": "vault_registry:types:SystemVault",
                  "keys_id": 51,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": null
            },
            {
              "name": "Vaults",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:VaultId"
                  ],
                  "value": "vault_registry:types:Vault",
                  "keys_id": 50,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Mapping of Vaults, using the respective Vault account identifier as key."
              ]
            },
            {
              "name": "VaultBitcoinPublicKey",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "[U8; 33]",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Mapping of Vaults, using the respective Vault account identifier as key."
              ]
            },
            {
              "name": "ReservedAddresses",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "bitcoin:address:Address"
                  ],
                  "value": "interbtc_primitives:VaultId",
                  "keys_id": 64,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Mapping of reserved BTC addresses to the registered account"
              ]
            },
            {
              "name": "TotalUserVaultCollateral",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:VaultCurrencyPair"
                  ],
                  "value": "U128",
                  "keys_id": 51,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Total collateral used for collateral tokens issued by active vaults, excluding the liquidation vault"
              ]
            },
            {
              "name": "StorageVersion",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "vault_registry:types:Version",
                "PlainTypeValue": 352
              },
              "fallback": "0x00",
              "docs": [
                " Build storage at V1 (requires default 0)."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1400",
              "name": "register_vault",
              "docs": [
                "Initiates the registration procedure for a new Vault.",
                "The Vault locks up collateral, which is to be used in the issuing process.",
                "",
                "",
                "# Errors",
                "* `InsufficientVaultCollateralAmount` - if the collateral is below the minimum threshold",
                "* `VaultAlreadyRegistered` - if a vault is already registered for the origin account",
                "* `InsufficientCollateralAvailable` - if the vault does not own enough collateral"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "collateral",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "1401",
              "name": "deposit_collateral",
              "docs": [
                "Deposit collateral as a security against stealing the",
                "Bitcoin locked with the caller.",
                "",
                "# Arguments",
                "* `amount` - the amount of extra collateral to lock"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "1402",
              "name": "withdraw_collateral",
              "docs": [
                "Withdraws `amount` of the collateral from the amount locked by",
                "the vault corresponding to the origin account",
                "The collateral left after withdrawal must be more",
                "(free or used in collateral issued tokens) than MinimumCollateralVault",
                "and above the SecureCollateralThreshold. Collateral that is currently",
                "being used to back issued tokens remains locked until the Vault",
                "is used for a redeem request (full release can take multiple redeem requests).",
                "",
                "# Arguments",
                "* `amount` - the amount of collateral to withdraw",
                "",
                "# Errors",
                "* `VaultNotFound` - if no vault exists for the origin account",
                "* `InsufficientCollateralAvailable` - if the vault does not own enough collateral"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "1403",
              "name": "register_public_key",
              "docs": [
                "Registers a new Bitcoin address for the vault.",
                "",
                "# Arguments",
                "* `public_key` - the BTC public key of the vault to update"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "public_key",
                  "type": "[U8; 33]",
                  "type_name": "BtcPublicKey"
                }
              ]
            },
            {
              "lookup": "1404",
              "name": "register_address",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "btc_address",
                  "type": "bitcoin:address:Address",
                  "type_name": "BtcAddress"
                }
              ]
            },
            {
              "lookup": "1405",
              "name": "accept_new_issues",
              "docs": [
                "Configures whether or not the vault accepts new issues.",
                "",
                "# Arguments",
                "",
                "* `origin` - sender of the transaction (i.e. the vault)",
                "* `accept_new_issues` - true indicates that the vault accepts new issues",
                "",
                "# Weight: `O(1)`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "accept_new_issues",
                  "type": "Bool",
                  "type_name": "bool"
                }
              ]
            },
            {
              "lookup": "1406",
              "name": "report_undercollateralized_vault",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "vault_id",
                  "type": "interbtc_primitives:VaultId",
                  "type_name": "DefaultVaultId"
                }
              ]
            },
            {
              "lookup": "1407",
              "name": "set_minimum_collateral",
              "docs": [
                "Changes the minimum amount of collateral required for registration",
                "(only executable by the Root account)",
                "",
                "# Arguments",
                "* `currency_id` - the collateral's currency id",
                "* `minimum` - the new minimum collateral"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_id",
                  "type": "interbtc_primitives:CurrencyId",
                  "type_name": "CurrencyId"
                },
                {
                  "TypeName": "",
                  "name": "minimum",
                  "type": "U128",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "1408",
              "name": "set_system_collateral_ceiling",
              "docs": [
                "Changes the collateral ceiling for a currency (only executable by the Root account)",
                "",
                "# Arguments",
                "* `currency_pair` - the currency pair to change",
                "* `ceiling` - the new collateral ceiling"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "ceiling",
                  "type": "U128",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "1409",
              "name": "set_secure_collateral_threshold",
              "docs": [
                "Changes the secure threshold for a currency (only executable by the Root account)",
                "",
                "# Arguments",
                "* `currency_pair` - the currency pair to change",
                "* `threshold` - the new secure threshold"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "threshold",
                  "type": "U128",
                  "type_name": "UnsignedFixedPoint"
                }
              ]
            },
            {
              "lookup": "140a",
              "name": "set_premium_redeem_threshold",
              "docs": [
                "Changes the collateral premium redeem threshold for a currency (only executable by the Root account)",
                "",
                "# Arguments",
                "* `currency_pair` - the currency pair to change",
                "* `ceiling` - the new collateral ceiling"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "threshold",
                  "type": "U128",
                  "type_name": "UnsignedFixedPoint"
                }
              ]
            },
            {
              "lookup": "140b",
              "name": "set_liquidation_collateral_threshold",
              "docs": [
                "Changes the collateral liquidation threshold for a currency (only executable by the Root account)",
                "",
                "# Arguments",
                "* `currency_pair` - the currency pair to change",
                "* `ceiling` - the new collateral ceiling"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "threshold",
                  "type": "U128",
                  "type_name": "UnsignedFixedPoint"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 181
          },
          "events": [
            {
              "lookup": "1400",
              "name": "RegisterVault",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1401",
              "name": "DepositCollateral",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1402",
              "name": "WithdrawCollateral",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1403",
              "name": "IncreaseLockedCollateral",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultCurrencyPair",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultCurrencyPair",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1404",
              "name": "DecreaseLockedCollateral",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultCurrencyPair",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultCurrencyPair",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1405",
              "name": "UpdatePublicKey",
              "docs": null,
              "args": [
                "[U8; 32]",
                "[U8; 33]"
              ],
              "args_type_name": [
                "AccountId",
                "BtcPublicKey"
              ]
            },
            {
              "lookup": "1406",
              "name": "RegisterAddress",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "bitcoin:address:Address"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BtcAddress"
              ]
            },
            {
              "lookup": "1407",
              "name": "IncreaseToBeIssuedTokens",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1408",
              "name": "DecreaseToBeIssuedTokens",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1409",
              "name": "IssueTokens",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "140a",
              "name": "IncreaseToBeRedeemedTokens",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "140b",
              "name": "DecreaseToBeRedeemedTokens",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "140c",
              "name": "IncreaseToBeReplacedTokens",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "140d",
              "name": "DecreaseToBeReplacedTokens",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "140e",
              "name": "DecreaseTokens",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "AccountId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "140f",
              "name": "RedeemTokens",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1410",
              "name": "RedeemTokensPremium",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128",
                "U128",
                "[U8; 32]"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf",
                "AccountId"
              ]
            },
            {
              "lookup": "1411",
              "name": "RedeemTokensLiquidatedVault",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1412",
              "name": "RedeemTokensLiquidation",
              "docs": null,
              "args": [
                "[U8; 32]",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "AccountId",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1413",
              "name": "ReplaceTokens",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "interbtc_primitives:VaultId",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1414",
              "name": "LiquidateVault",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128",
                "U128",
                "U128",
                "U128",
                "U128",
                "vault_registry:types:VaultStatus",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf",
                "BalanceOf",
                "BalanceOf",
                "BalanceOf",
                "VaultStatus",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1415",
              "name": "BanVault",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U32"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BlockNumber"
              ]
            }
          ],
          "events_value": {
            "type": 61
          },
          "constants": [
            {
              "name": "PalletId",
              "type": "[U8; 8]",
              "type_value": 320,
              "constants_value": "mod/vreg",
              "docs": [
                " The vault module id, used for deriving its sovereign account ID."
              ]
            },
            {
              "name": "GetGriefingCollateralCurrencyId",
              "type": "interbtc_primitives:CurrencyId",
              "type_value": 37,
              "constants_value": "000c",
              "docs": [
                " Currency used for griefing collateral, e.g. DOT."
              ]
            }
          ],
          "errors": [
            {
              "name": "InsufficientCollateral",
              "doc": [
                "Not enough free collateral available."
              ]
            },
            {
              "name": "ExceedingVaultLimit",
              "doc": [
                "The amount of tokens to be issued is higher than the issuable amount by the vault"
              ]
            },
            {
              "name": "InsufficientTokensCommitted",
              "doc": [
                "The requested amount of tokens exceeds the amount available to this vault."
              ]
            },
            {
              "name": "VaultBanned",
              "doc": [
                "Action not allowed on banned vault."
              ]
            },
            {
              "name": "InsufficientVaultCollateralAmount",
              "doc": [
                "The provided collateral was insufficient - it must be above ``MinimumCollateralVault``."
              ]
            },
            {
              "name": "VaultAlreadyRegistered",
              "doc": [
                "Returned if a vault tries to register while already being registered"
              ]
            },
            {
              "name": "VaultNotFound",
              "doc": [
                "The specified vault does not exist."
              ]
            },
            {
              "name": "ReservedDepositAddress",
              "doc": [
                "The Bitcoin Address has already been registered"
              ]
            },
            {
              "name": "VaultNotBelowLiquidationThreshold",
              "doc": [
                "Attempted to liquidate a vault that is not undercollateralized."
              ]
            },
            {
              "name": "InvalidPublicKey",
              "doc": [
                "Deposit address could not be generated with the given public key."
              ]
            },
            {
              "name": "MaxNominationRatioViolation",
              "doc": [
                "The Max Nomination Ratio would be exceeded."
              ]
            },
            {
              "name": "CurrencyCeilingExceeded",
              "doc": [
                "The collateral ceiling would be exceeded for the vault's currency."
              ]
            },
            {
              "name": "VaultCommittedTheft",
              "doc": [
                "Vault is no longer usable as it was liquidated due to theft."
              ]
            },
            {
              "name": "VaultLiquidated",
              "doc": [
                "Vault is no longer usable as it was liquidated due to undercollateralization."
              ]
            },
            {
              "name": "NoBitcoinPublicKey",
              "doc": [
                "No bitcoin public key is registered for the vault."
              ]
            },
            {
              "name": "PublicKeyAlreadyRegistered",
              "doc": [
                "A bitcoin public key was already registered for this account."
              ]
            },
            {
              "name": "NoTokensIssued",
              "doc": [
                "Collateralization is infinite if no tokens are issued"
              ]
            },
            {
              "name": "NoVaultWithSufficientCollateral",
              "doc": null
            },
            {
              "name": "NoVaultWithSufficientTokens",
              "doc": null
            },
            {
              "name": "NoVaultUnderThePremiumRedeemThreshold",
              "doc": null
            },
            {
              "name": "InvalidCurrency",
              "doc": [
                "Failed attempt to modify vault's collateral because it was in the wrong currency"
              ]
            },
            {
              "name": "ThresholdNotSet",
              "doc": [
                "Threshold was not found for the given currency"
              ]
            },
            {
              "name": "CeilingNotSet",
              "doc": [
                "Ceiling was not found for the given currency"
              ]
            },
            {
              "name": "ArithmeticOverflow",
              "doc": null
            },
            {
              "name": "ArithmeticUnderflow",
              "doc": null
            },
            {
              "name": "TryIntoIntError",
              "doc": [
                "Unable to convert value"
              ]
            }
          ],
          "errors_value": {
            "type": 353
          },
          "index": 20
        },
        {
          "name": "Oracle",
          "prefix": "Oracle",
          "storage": [
            {
              "name": "Aggregate",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:oracle:Key"
                  ],
                  "value": "U128",
                  "keys_id": 72,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Current medianized value for the given key"
              ]
            },
            {
              "name": "RawValues",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:oracle:Key",
                    "[U8; 32]"
                  ],
                  "value": "oracle:TimestampedValue",
                  "keys_id": 354,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": null
            },
            {
              "name": "RawValuesUpdated",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:oracle:Key"
                  ],
                  "value": "Bool",
                  "keys_id": 72,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " if a key is present, it means the values have been updated"
              ]
            },
            {
              "name": "ValidUntil",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:oracle:Key"
                  ],
                  "value": "U64",
                  "keys_id": 72,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Time until which the aggregate is valid"
              ]
            },
            {
              "name": "MaxDelay",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U64",
                "PlainTypeValue": 8
              },
              "fallback": "0x0000000000000000",
              "docs": [
                " Maximum delay (milliseconds) for a reported value to be used"
              ]
            },
            {
              "name": "AuthorizedOracles",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "Vec\u003cU8\u003e",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": null
            },
            {
              "name": "StorageVersion",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "oracle:types:Version",
                "PlainTypeValue": 356
              },
              "fallback": "0x00",
              "docs": [
                " Build storage at V1 (requires default 0)."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1500",
              "name": "feed_values",
              "docs": [
                "Feeds data from the oracles, e.g., the exchange rates. This function",
                "is intended to be API-compatible with orml-oracle.",
                "",
                "# Arguments",
                "",
                "* `values` - a vector of (key, value) pairs to submit"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "values",
                  "type": "Vec\u003cTuple:interbtc_primitives:oracle:Keysp_arithmetic:fixed_point:FixedU128\u003e",
                  "type_name": "Vec\u003c(OracleKey, UnsignedFixedPoint)\u003e"
                }
              ]
            },
            {
              "lookup": "1501",
              "name": "insert_authorized_oracle",
              "docs": [
                "Adds an authorized oracle account (only executable by the Root account)",
                "",
                "# Arguments",
                "* `account_id` - the account Id of the oracle",
                "* `name` - a descriptive name for the oracle"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "account_id",
                  "type": "[U8; 32]",
                  "type_name": "AccountId"
                },
                {
                  "TypeName": "",
                  "name": "name",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "1502",
              "name": "remove_authorized_oracle",
              "docs": [
                "Removes an authorized oracle account (only executable by the Root account)",
                "",
                "# Arguments",
                "* `account_id` - the account Id of the oracle"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "account_id",
                  "type": "[U8; 32]",
                  "type_name": "AccountId"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 182
          },
          "events": [
            {
              "lookup": "1500",
              "name": "FeedValues",
              "docs": [
                "Event emitted when exchange rate is set"
              ],
              "args": [
                "[U8; 32]",
                "Vec\u003cTuple:interbtc_primitives:oracle:Keysp_arithmetic:fixed_point:FixedU128\u003e"
              ],
              "args_type_name": [
                "AccountId",
                "Vec\u003c(OracleKey, UnsignedFixedPoint)\u003e"
              ]
            }
          ],
          "events_value": {
            "type": 69
          },
          "errors": [
            {
              "name": "InvalidOracleSource",
              "doc": [
                "Not authorized to set exchange rate"
              ]
            },
            {
              "name": "MissingExchangeRate",
              "doc": [
                "Exchange rate not specified or has expired"
              ]
            },
            {
              "name": "TryIntoIntError",
              "doc": [
                "Unable to convert value"
              ]
            },
            {
              "name": "ArithmeticOverflow",
              "doc": [
                "Mathematical operation caused an overflow"
              ]
            },
            {
              "name": "ArithmeticUnderflow",
              "doc": [
                "Mathematical operation caused an underflow"
              ]
            }
          ],
          "errors_value": {
            "type": 357
          },
          "index": 21
        },
        {
          "name": "Issue",
          "prefix": "Issue",
          "storage": [
            {
              "name": "IssueRequests",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "H256"
                  ],
                  "value": "interbtc_primitives:issue:IssueRequest",
                  "keys_id": 9,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Users create issue requests to issue tokens. This mapping provides access",
                " from a unique hash `IssueId` to an `IssueRequest` struct."
              ]
            },
            {
              "name": "IssuePeriod",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " The time difference in number of blocks between an issue request is created",
                " and required completion time by a user. The issue period has an upper limit",
                " to prevent griefing of vault collateral."
              ]
            },
            {
              "name": "IssueBtcDustValue",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 6
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The minimum amount of btc that is required for issue requests; lower values would",
                " risk the rejection of payment on Bitcoin."
              ]
            },
            {
              "name": "StorageVersion",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "issue:types:Version",
                "PlainTypeValue": 360
              },
              "fallback": "0x00",
              "docs": [
                " Build storage at V1 (requires default 0)."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1600",
              "name": "request_issue",
              "docs": [
                "Request the issuance of tokens",
                "",
                "# Arguments",
                "",
                "* `origin` - sender of the transaction",
                "* `amount` - amount of BTC the user wants to convert to issued tokens. Note that the",
                "amount of issued tokens received will be less, because a fee is subtracted.",
                "* `vault` - address of the vault",
                "* `griefing_collateral` - amount of collateral"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                },
                {
                  "TypeName": "",
                  "name": "vault_id",
                  "type": "interbtc_primitives:VaultId",
                  "type_name": "DefaultVaultId"
                }
              ]
            },
            {
              "lookup": "1601",
              "name": "execute_issue",
              "docs": [
                "Finalize the issuance of tokens",
                "",
                "# Arguments",
                "",
                "* `origin` - sender of the transaction",
                "* `issue_id` - identifier of issue request as output from request_issue",
                "* `tx_block_height` - block number of collateral chain",
                "* `merkle_proof` - raw bytes",
                "* `raw_tx` - raw bytes"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "issue_id",
                  "type": "H256",
                  "type_name": "H256"
                },
                {
                  "TypeName": "",
                  "name": "merkle_proof",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                },
                {
                  "TypeName": "",
                  "name": "raw_tx",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "1602",
              "name": "cancel_issue",
              "docs": [
                "Cancel the issuance of tokens if expired",
                "",
                "# Arguments",
                "",
                "* `origin` - sender of the transaction",
                "* `issue_id` - identifier of issue request as output from request_issue"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "issue_id",
                  "type": "H256",
                  "type_name": "H256"
                }
              ]
            },
            {
              "lookup": "1603",
              "name": "set_issue_period",
              "docs": [
                "Set the default issue period for tx verification.",
                "",
                "# Arguments",
                "",
                "* `origin` - the dispatch origin of this call (must be _Root_)",
                "* `period` - default period for new requests",
                "",
                "# Weight: `O(1)`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "period",
                  "type": "U32",
                  "type_name": "BlockNumber"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 183
          },
          "events": [
            {
              "lookup": "1600",
              "name": "RequestIssue",
              "docs": null,
              "args": [
                "H256",
                "[U8; 32]",
                "U128",
                "U128",
                "U128",
                "interbtc_primitives:VaultId",
                "bitcoin:address:Address",
                "[U8; 33]"
              ],
              "args_type_name": [
                "H256",
                "AccountId",
                "BalanceOf",
                "BalanceOf",
                "BalanceOf",
                "DefaultVaultId",
                "BtcAddress",
                "BtcPublicKey"
              ]
            },
            {
              "lookup": "1601",
              "name": "IssueAmountChange",
              "docs": null,
              "args": [
                "H256",
                "U128",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "H256",
                "BalanceOf",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1602",
              "name": "ExecuteIssue",
              "docs": null,
              "args": [
                "H256",
                "[U8; 32]",
                "interbtc_primitives:VaultId",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "H256",
                "AccountId",
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1603",
              "name": "CancelIssue",
              "docs": null,
              "args": [
                "H256",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "H256",
                "AccountId",
                "BalanceOf"
              ]
            }
          ],
          "events_value": {
            "type": 74
          },
          "errors": [
            {
              "name": "IssueIdNotFound",
              "doc": [
                "Issue request not found."
              ]
            },
            {
              "name": "CommitPeriodExpired",
              "doc": [
                "Issue request has expired."
              ]
            },
            {
              "name": "TimeNotExpired",
              "doc": [
                "Issue request has not expired."
              ]
            },
            {
              "name": "IssueCompleted",
              "doc": [
                "Issue request already completed."
              ]
            },
            {
              "name": "IssueCancelled",
              "doc": [
                "Issue request already cancelled."
              ]
            },
            {
              "name": "VaultNotAcceptingNewIssues",
              "doc": [
                "Vault is not active."
              ]
            },
            {
              "name": "WaitingForRelayerInitialization",
              "doc": [
                "Relay is not initialized."
              ]
            },
            {
              "name": "InvalidExecutor",
              "doc": [
                "Not expected origin."
              ]
            },
            {
              "name": "AmountBelowDustAmount",
              "doc": [
                "Issue amount is too small."
              ]
            }
          ],
          "errors_value": {
            "type": 361
          },
          "index": 22
        },
        {
          "name": "Redeem",
          "prefix": "Redeem",
          "storage": [
            {
              "name": "RedeemPeriod",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " The time difference in number of blocks between a redeem request is created and required completion time by a",
                " vault. The redeem period has an upper limit to ensure the user gets their BTC in time and to potentially",
                " punish a vault for inactivity or stealing BTC."
              ]
            },
            {
              "name": "RedeemRequests",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "H256"
                  ],
                  "value": "interbtc_primitives:redeem:RedeemRequest",
                  "keys_id": 9,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Users create redeem requests to receive BTC in return for their previously issued tokens.",
                " This mapping provides access from a unique hash redeemId to a Redeem struct."
              ]
            },
            {
              "name": "RedeemBtcDustValue",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 6
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The minimum amount of btc that is accepted for redeem requests; any lower values would",
                " risk the bitcoin client to reject the payment"
              ]
            },
            {
              "name": "RedeemTransactionSize",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " the expected size in bytes of the redeem bitcoin transfer"
              ]
            },
            {
              "name": "StorageVersion",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "redeem:types:Version",
                "PlainTypeValue": 363
              },
              "fallback": "0x00",
              "docs": [
                " Build storage at V1 (requires default 0)."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1700",
              "name": "request_redeem",
              "docs": [
                "Initializes a request to burn issued tokens against a Vault with sufficient tokens. It will",
                "also ensure that the Parachain status is RUNNING.",
                "",
                "# Arguments",
                "",
                "* `origin` - sender of the transaction",
                "* `amount` - amount of issued tokens",
                "* `btc_address` - the address to receive BTC",
                "* `vault_id` - address of the vault"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "amount_wrapped",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                },
                {
                  "TypeName": "",
                  "name": "btc_address",
                  "type": "bitcoin:address:Address",
                  "type_name": "BtcAddress"
                },
                {
                  "TypeName": "",
                  "name": "vault_id",
                  "type": "interbtc_primitives:VaultId",
                  "type_name": "DefaultVaultId"
                }
              ]
            },
            {
              "lookup": "1701",
              "name": "liquidation_redeem",
              "docs": [
                "When a Vault is liquidated, its collateral is slashed up to 150% of the liquidated BTC value.",
                "To re-establish the physical 1:1 peg, the bridge allows users to burn issued tokens in return for",
                "collateral at a premium rate.",
                "",
                "# Arguments",
                "",
                "* `origin` - sender of the transaction",
                "* `collateral_currency` - currency to be received",
                "* `wrapped_currency` - currency of the wrapped token to burn",
                "* `amount_wrapped` - amount of issued tokens to burn"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currencies",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "amount_wrapped",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "1702",
              "name": "execute_redeem",
              "docs": [
                "A Vault calls this function after receiving an RequestRedeem event with their public key.",
                "Before calling the function, the Vault transfers the specific amount of BTC to the BTC address",
                "given in the original redeem request. The Vault completes the redeem with this function.",
                "",
                "# Arguments",
                "",
                "* `origin` - anyone executing this redeem request",
                "* `redeem_id` - identifier of redeem request as output from request_redeem",
                "* `tx_id` - transaction hash",
                "* `tx_block_height` - block number of collateral chain",
                "* `merkle_proof` - raw bytes",
                "* `raw_tx` - raw bytes"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "redeem_id",
                  "type": "H256",
                  "type_name": "H256"
                },
                {
                  "TypeName": "",
                  "name": "merkle_proof",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                },
                {
                  "TypeName": "",
                  "name": "raw_tx",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "1703",
              "name": "cancel_redeem",
              "docs": [
                "If a redeem request is not completed on time, the redeem request can be cancelled.",
                "The user that initially requested the redeem process calls this function to obtain",
                "746865205661756c74e280997320636f6c6c61746572616c20617320636f6d70656e736174696f6e20666f72206e6f7420726566756e64696e672074686520425443206261636b20746f20746865697220616464726573732e",
                "",
                "# Arguments",
                "",
                "* `origin` - sender of the transaction",
                "* `redeem_id` - identifier of redeem request as output from request_redeem",
                "* `reimburse` - specifying if the user wishes to be reimbursed in collateral",
                "and slash the Vault, or wishes to keep the tokens (and retry",
                "Redeem with another Vault)"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "redeem_id",
                  "type": "H256",
                  "type_name": "H256"
                },
                {
                  "TypeName": "",
                  "name": "reimburse",
                  "type": "Bool",
                  "type_name": "bool"
                }
              ]
            },
            {
              "lookup": "1704",
              "name": "set_redeem_period",
              "docs": [
                "Set the default redeem period for tx verification.",
                "",
                "# Arguments",
                "",
                "* `origin` - the dispatch origin of this call (must be _Root_)",
                "* `period` - default period for new requests",
                "",
                "# Weight: `O(1)`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "period",
                  "type": "U32",
                  "type_name": "BlockNumber"
                }
              ]
            },
            {
              "lookup": "1705",
              "name": "mint_tokens_for_reimbursed_redeem",
              "docs": [
                "Mint tokens for a redeem that was cancelled with reimburse=true. This is",
                "only possible if at the time of the cancel_redeem, the vault did not have",
                "sufficient collateral after being slashed to back the tokens that the user",
                "used to hold.",
                "",
                "# Arguments",
                "",
                "* `origin` - the dispatch origin of this call (must be _Root_)",
                "* `redeem_id` - identifier of redeem request as output from request_redeem",
                "",
                "# Weight: `O(1)`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "redeem_id",
                  "type": "H256",
                  "type_name": "H256"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 184
          },
          "events": [
            {
              "lookup": "1700",
              "name": "RequestRedeem",
              "docs": null,
              "args": [
                "H256",
                "[U8; 32]",
                "interbtc_primitives:VaultId",
                "U128",
                "U128",
                "U128",
                "bitcoin:address:Address",
                "U128"
              ],
              "args_type_name": [
                "H256",
                "AccountId",
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf",
                "BalanceOf",
                "BtcAddress",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1701",
              "name": "LiquidationRedeem",
              "docs": null,
              "args": [
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "AccountId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1702",
              "name": "ExecuteRedeem",
              "docs": null,
              "args": [
                "H256",
                "[U8; 32]",
                "interbtc_primitives:VaultId",
                "U128",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "H256",
                "AccountId",
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1703",
              "name": "CancelRedeem",
              "docs": null,
              "args": [
                "H256",
                "[U8; 32]",
                "interbtc_primitives:VaultId",
                "U128",
                "interbtc_primitives:redeem:RedeemRequestStatus"
              ],
              "args_type_name": [
                "H256",
                "AccountId",
                "DefaultVaultId",
                "BalanceOf",
                "RedeemRequestStatus"
              ]
            },
            {
              "lookup": "1704",
              "name": "MintTokensForReimbursedRedeem",
              "docs": null,
              "args": [
                "H256",
                "interbtc_primitives:VaultId",
                "U128"
              ],
              "args_type_name": [
                "H256",
                "DefaultVaultId",
                "BalanceOf"
              ]
            }
          ],
          "events_value": {
            "type": 75
          },
          "errors": [
            {
              "name": "AmountExceedsUserBalance",
              "doc": [
                "Account has insufficient balance."
              ]
            },
            {
              "name": "UnauthorizedRedeemer",
              "doc": [
                "Unexpected redeem account."
              ]
            },
            {
              "name": "UnauthorizedVault",
              "doc": [
                "Unexpected vault account."
              ]
            },
            {
              "name": "TimeNotExpired",
              "doc": [
                "Redeem request has not expired."
              ]
            },
            {
              "name": "RedeemCancelled",
              "doc": [
                "Redeem request already cancelled."
              ]
            },
            {
              "name": "RedeemCompleted",
              "doc": [
                "Redeem request already completed."
              ]
            },
            {
              "name": "RedeemIdNotFound",
              "doc": [
                "Redeem request not found."
              ]
            },
            {
              "name": "TryIntoIntError",
              "doc": [
                "Unable to convert value."
              ]
            },
            {
              "name": "AmountBelowDustAmount",
              "doc": [
                "Redeem amount is too small."
              ]
            }
          ],
          "errors_value": {
            "type": 364
          },
          "index": 23
        },
        {
          "name": "Replace",
          "prefix": "Replace",
          "storage": [
            {
              "name": "ReplaceRequests",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "H256"
                  ],
                  "value": "interbtc_primitives:replace:ReplaceRequest",
                  "keys_id": 9,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Vaults create replace requests to transfer locked collateral.",
                " This mapping provides access from a unique hash to a `ReplaceRequest`."
              ]
            },
            {
              "name": "ReplacePeriod",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " The time difference in number of blocks between when a replace request is created",
                " and required completion time by a vault. The replace period has an upper limit",
                " to prevent griefing of vault collateral."
              ]
            },
            {
              "name": "ReplaceBtcDustValue",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 6
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The minimum amount of btc that is accepted for replace requests; any lower values would",
                " risk the bitcoin client to reject the payment"
              ]
            },
            {
              "name": "StorageVersion",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "replace:types:Version",
                "PlainTypeValue": 367
              },
              "fallback": "0x00",
              "docs": [
                " Build storage at V1 (requires default 0)."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1800",
              "name": "request_replace",
              "docs": [
                "Request the replacement of a new vault ownership",
                "",
                "# Arguments",
                "",
                "* `origin` - sender of the transaction",
                "* `amount` - amount of issued tokens",
                "* `griefing_collateral` - amount of collateral"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "1801",
              "name": "withdraw_replace",
              "docs": [
                "Withdraw a request of vault replacement",
                "",
                "# Arguments",
                "",
                "* `origin` - sender of the transaction: the old vault"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "1802",
              "name": "accept_replace",
              "docs": [
                "Accept request of vault replacement",
                "",
                "# Arguments",
                "",
                "* `origin` - the initiator of the transaction: the new vault",
                "* `old_vault` - id of the old vault that we are (possibly partially) replacing",
                "* `collateral` - the collateral for replacement",
                "* `btc_address` - the address that old-vault should transfer the btc to"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                },
                {
                  "TypeName": "",
                  "name": "old_vault",
                  "type": "interbtc_primitives:VaultId",
                  "type_name": "DefaultVaultId"
                },
                {
                  "TypeName": "",
                  "name": "amount_btc",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                },
                {
                  "TypeName": "",
                  "name": "collateral",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                },
                {
                  "TypeName": "",
                  "name": "btc_address",
                  "type": "bitcoin:address:Address",
                  "type_name": "BtcAddress"
                }
              ]
            },
            {
              "lookup": "1803",
              "name": "execute_replace",
              "docs": [
                "Execute vault replacement",
                "",
                "# Arguments",
                "",
                "* `origin` - sender of the transaction: the new vault",
                "* `replace_id` - the ID of the replacement request",
                "* 'merkle_proof' - the merkle root of the block",
                "* `raw_tx` - the transaction id in bytes"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "replace_id",
                  "type": "H256",
                  "type_name": "H256"
                },
                {
                  "TypeName": "",
                  "name": "merkle_proof",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                },
                {
                  "TypeName": "",
                  "name": "raw_tx",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "1804",
              "name": "cancel_replace",
              "docs": [
                "Cancel vault replacement",
                "",
                "# Arguments",
                "",
                "* `origin` - sender of the transaction: the new vault",
                "* `replace_id` - the ID of the replacement request"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "replace_id",
                  "type": "H256",
                  "type_name": "H256"
                }
              ]
            },
            {
              "lookup": "1805",
              "name": "set_replace_period",
              "docs": [
                "Set the default replace period for tx verification.",
                "",
                "# Arguments",
                "",
                "* `origin` - the dispatch origin of this call (must be _Root_)",
                "* `period` - default period for new requests",
                "",
                "# Weight: `O(1)`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "period",
                  "type": "U32",
                  "type_name": "BlockNumber"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 185
          },
          "events": [
            {
              "lookup": "1800",
              "name": "RequestReplace",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1801",
              "name": "WithdrawReplace",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1802",
              "name": "AcceptReplace",
              "docs": null,
              "args": [
                "H256",
                "interbtc_primitives:VaultId",
                "interbtc_primitives:VaultId",
                "U128",
                "U128",
                "bitcoin:address:Address"
              ],
              "args_type_name": [
                "H256",
                "DefaultVaultId",
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf",
                "BtcAddress"
              ]
            },
            {
              "lookup": "1803",
              "name": "ExecuteReplace",
              "docs": null,
              "args": [
                "H256",
                "interbtc_primitives:VaultId",
                "interbtc_primitives:VaultId"
              ],
              "args_type_name": [
                "H256",
                "DefaultVaultId",
                "DefaultVaultId"
              ]
            },
            {
              "lookup": "1804",
              "name": "CancelReplace",
              "docs": null,
              "args": [
                "H256",
                "interbtc_primitives:VaultId",
                "interbtc_primitives:VaultId",
                "U128"
              ],
              "args_type_name": [
                "H256",
                "DefaultVaultId",
                "DefaultVaultId",
                "BalanceOf"
              ]
            }
          ],
          "events_value": {
            "type": 77
          },
          "errors": [
            {
              "name": "ReplaceAmountZero",
              "doc": [
                "Replace requires non-zero increase."
              ]
            },
            {
              "name": "AmountBelowDustAmount",
              "doc": [
                "Replace amount is too small."
              ]
            },
            {
              "name": "NoPendingRequest",
              "doc": [
                "No replace request found."
              ]
            },
            {
              "name": "UnauthorizedVault",
              "doc": [
                "Unexpected vault account."
              ]
            },
            {
              "name": "ReplaceSelfNotAllowed",
              "doc": [
                "Cannot replace self."
              ]
            },
            {
              "name": "VaultHasEnabledNomination",
              "doc": [
                "Cannot replace with nominated collateral."
              ]
            },
            {
              "name": "ReplacePeriodNotExpired",
              "doc": [
                "Replace request has not expired."
              ]
            },
            {
              "name": "ReplaceCompleted",
              "doc": [
                "Replace request already completed."
              ]
            },
            {
              "name": "ReplaceCancelled",
              "doc": [
                "Replace request already cancelled."
              ]
            },
            {
              "name": "ReplaceIdNotFound",
              "doc": [
                "Replace request not found."
              ]
            },
            {
              "name": "InvalidWrappedCurrency",
              "doc": [
                "Vault cannot replace different currency."
              ]
            }
          ],
          "errors_value": {
            "type": 368
          },
          "index": 24
        },
        {
          "name": "Fee",
          "prefix": "Fee",
          "storage": [
            {
              "name": "IssueFee",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 73
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " # Issue",
                " Fee share that users need to pay to issue tokens."
              ]
            },
            {
              "name": "IssueGriefingCollateral",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 73
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Default griefing collateral (e.g. DOT/KSM) as a percentage of the locked",
                " collateral of a Vault a user has to lock to issue tokens."
              ]
            },
            {
              "name": "RedeemFee",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 73
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " # Redeem",
                " Fee share that users need to pay to redeem tokens."
              ]
            },
            {
              "name": "RefundFee",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 73
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " # Refund",
                " Fee share that users need to pay to refund overpaid tokens."
              ]
            },
            {
              "name": "PremiumRedeemFee",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 73
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " # Vault Registry",
                " If users execute a redeem with a Vault flagged for premium redeem,",
                " they can earn a collateral premium, slashed from the Vault."
              ]
            },
            {
              "name": "PunishmentFee",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 73
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Fee that a Vault has to pay if it fails to execute redeem or replace requests",
                " (for redeem, on top of the slashed value of the request). The fee is",
                " paid in collateral based on the token amount at the current exchange rate."
              ]
            },
            {
              "name": "ReplaceGriefingCollateral",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 73
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " # Replace",
                " Default griefing collateral (e.g. DOT/KSM) as a percentage of the to-be-locked collateral",
                " of the new Vault. This collateral will be slashed and allocated to the replacing Vault",
                " if the to-be-replaced Vault does not transfer BTC on time."
              ]
            },
            {
              "name": "TheftFee",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 73
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " # Relayer",
                " Fee that is taken from a liquidated Vault on theft, used to pay the reporter."
              ]
            },
            {
              "name": "TheftFeeMax",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 6
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Upper bound to the reward that can be payed to a reporter on success."
              ]
            },
            {
              "name": "StorageVersion",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "fee:types:Version",
                "PlainTypeValue": 369
              },
              "fallback": "0x00",
              "docs": [
                " Build storage at V1 (requires default 0)."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1900",
              "name": "withdraw_rewards",
              "docs": [
                "Withdraw all rewards from the `origin` account in the `vault_id` staking pool.",
                "",
                "# Arguments",
                "",
                "* `origin` - signing account"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "vault_id",
                  "type": "interbtc_primitives:VaultId",
                  "type_name": "DefaultVaultId"
                },
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "option\u003cU32\u003e",
                  "type_name": "Option\u003cIndex\u003e"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 186
          },
          "constants": [
            {
              "name": "FeePalletId",
              "type": "[U8; 8]",
              "type_value": 320,
              "constants_value": "mod/fees",
              "docs": [
                " The fee module id, used for deriving its sovereign account ID."
              ]
            }
          ],
          "errors": [
            {
              "name": "TryIntoIntError",
              "doc": [
                "Unable to convert value."
              ]
            }
          ],
          "errors_value": {
            "type": 370
          },
          "index": 25
        },
        {
          "name": "Refund",
          "prefix": "Refund",
          "storage": [
            {
              "name": "RefundBtcDustValue",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U128",
                "PlainTypeValue": 6
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The minimum amount of btc that is accepted for refund requests (NOTE: too low",
                " values could result in the bitcoin client rejecting the payment)"
              ]
            },
            {
              "name": "RefundTransactionSize",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " the expected size in bytes of the redeem bitcoin transfer"
              ]
            },
            {
              "name": "RefundRequests",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "H256"
                  ],
                  "value": "interbtc_primitives:refund:RefundRequest",
                  "keys_id": 9,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " This mapping provides access from a unique hash refundId to a Refund struct."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1a00",
              "name": "execute_refund",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "refund_id",
                  "type": "H256",
                  "type_name": "H256"
                },
                {
                  "TypeName": "",
                  "name": "merkle_proof",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                },
                {
                  "TypeName": "",
                  "name": "raw_tx",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "1a01",
              "name": "set_refund_transaction_size",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "size",
                  "type": "U32",
                  "type_name": "u32"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 187
          },
          "events": [
            {
              "lookup": "1a00",
              "name": "RequestRefund",
              "docs": null,
              "args": [
                "H256",
                "[U8; 32]",
                "U128",
                "interbtc_primitives:VaultId",
                "bitcoin:address:Address",
                "H256",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "H256",
                "AccountId",
                "BalanceOf",
                "DefaultVaultId",
                "BtcAddress",
                "H256",
                "BalanceOf",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1a01",
              "name": "ExecuteRefund",
              "docs": null,
              "args": [
                "H256",
                "[U8; 32]",
                "interbtc_primitives:VaultId",
                "U128",
                "U128"
              ],
              "args_type_name": [
                "H256",
                "AccountId",
                "DefaultVaultId",
                "BalanceOf",
                "BalanceOf"
              ]
            }
          ],
          "events_value": {
            "type": 78
          },
          "errors": [
            {
              "name": "ArithmeticUnderflow",
              "doc": null
            },
            {
              "name": "ArithmeticOverflow",
              "doc": null
            },
            {
              "name": "NoRefundFoundForIssueId",
              "doc": null
            },
            {
              "name": "RefundIdNotFound",
              "doc": null
            },
            {
              "name": "RefundCompleted",
              "doc": null
            },
            {
              "name": "TryIntoIntError",
              "doc": null
            },
            {
              "name": "UnauthorizedVault",
              "doc": null
            }
          ],
          "errors_value": {
            "type": 372
          },
          "index": 26
        },
        {
          "name": "Nomination",
          "prefix": "Nomination",
          "storage": [
            {
              "name": "NominationEnabled",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Bool",
                "PlainTypeValue": 68
              },
              "fallback": "0x00",
              "docs": [
                " Flag indicating whether this feature is enabled"
              ]
            },
            {
              "name": "Vaults",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "interbtc_primitives:VaultId"
                  ],
                  "value": "Bool",
                  "keys_id": 50,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Map of Vaults who have enabled nomination"
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1b00",
              "name": "set_nomination_enabled",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "enabled",
                  "type": "Bool",
                  "type_name": "bool"
                }
              ]
            },
            {
              "lookup": "1b01",
              "name": "opt_in_to_nomination",
              "docs": [
                "Allow nomination for this vault"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                }
              ]
            },
            {
              "lookup": "1b02",
              "name": "opt_out_of_nomination",
              "docs": [
                "Disallow nomination for this vault"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_pair",
                  "type": "interbtc_primitives:VaultCurrencyPair",
                  "type_name": "DefaultVaultCurrencyPair"
                }
              ]
            },
            {
              "lookup": "1b03",
              "name": "deposit_collateral",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "vault_id",
                  "type": "interbtc_primitives:VaultId",
                  "type_name": "DefaultVaultId"
                },
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "U128",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "1b04",
              "name": "withdraw_collateral",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "vault_id",
                  "type": "interbtc_primitives:VaultId",
                  "type_name": "DefaultVaultId"
                },
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "U128",
                  "type_name": "BalanceOf"
                },
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "option\u003cU32\u003e",
                  "type_name": "Option\u003cIndex\u003e"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 188
          },
          "events": [
            {
              "lookup": "1b00",
              "name": "NominationOptIn",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId"
              ],
              "args_type_name": [
                "DefaultVaultId"
              ]
            },
            {
              "lookup": "1b01",
              "name": "NominationOptOut",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId"
              ],
              "args_type_name": [
                "DefaultVaultId"
              ]
            },
            {
              "lookup": "1b02",
              "name": "DepositCollateral",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "AccountId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1b03",
              "name": "WithdrawCollateral",
              "docs": null,
              "args": [
                "interbtc_primitives:VaultId",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "DefaultVaultId",
                "AccountId",
                "BalanceOf"
              ]
            }
          ],
          "events_value": {
            "type": 79
          },
          "errors": [
            {
              "name": "VaultAlreadyOptedInToNomination",
              "doc": [
                "Vault has already enabled nomination."
              ]
            },
            {
              "name": "VaultNotOptedInToNomination",
              "doc": [
                "Vault has not enabled nomination."
              ]
            },
            {
              "name": "VaultNotFound",
              "doc": [
                "Vault not found."
              ]
            },
            {
              "name": "CannotWithdrawCollateral",
              "doc": [
                "Account cannot withdraw."
              ]
            },
            {
              "name": "VaultNominationDisabled",
              "doc": [
                "Nomination is not enabled."
              ]
            },
            {
              "name": "DepositViolatesMaxNominationRatio",
              "doc": [
                "Nomination would overburden Vault."
              ]
            },
            {
              "name": "CollateralizationTooLow",
              "doc": [
                "Vault cannot withdraw."
              ]
            }
          ],
          "errors_value": {
            "type": 373
          },
          "index": 27
        },
        {
          "name": "Identity",
          "prefix": "Identity",
          "storage": [
            {
              "name": "IdentityOf",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "pallet_identity:types:Registration",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Information that is pertinent to identify the entity behind an account.",
                "",
                "2054574f582d4e4f54453a204f4b20e2809520604163636f756e7449646020697320612073656375726520686173682e"
              ]
            },
            {
              "name": "SuperOf",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "Tuple:[U8; 32]pallet_identity:types:Data",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " The super-identity of an alternative \"sub\" identity together with its name, within that",
                " context. If the account is not some other account's sub-identity, then just `None`."
              ]
            },
            {
              "name": "SubsOf",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "Tuple:U128frame_support:storage:bounded_vec:BoundedVec@379",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x0000000000000000000000000000000000",
              "docs": [
                " Alternative \"sub\" identities of this account.",
                "",
                " The first item is the deposit, the second is a vector of the accounts.",
                "",
                "2054574f582d4e4f54453a204f4b20e2809520604163636f756e7449646020697320612073656375726520686173682e"
              ]
            },
            {
              "name": "Registrars",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003coption\u003cpallet_identity:types:RegistrarInfo\u003e\u003e",
                "PlainTypeValue": 380
              },
              "fallback": "0x00",
              "docs": [
                " The set of registrars. Not expected to get very big as can only be added through a",
                " special origin (likely a council motion).",
                "",
                " The index into this can be cast to `RegistrarIndex` to get a valid value."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "2b00",
              "name": "add_registrar",
              "docs": [
                "Add a registrar to the system.",
                "",
                "The dispatch origin for this call must be `T::RegistrarOrigin`.",
                "",
                "- `account`: the account of the registrar.",
                "",
                "Emits `RegistrarAdded` if successful.",
                "",
                "# \u003cweight\u003e",
                "- `O(R)` where `R` registrar-count (governance-bounded and code-bounded).",
                "- One storage mutation (codec `O(R)`).",
                "- One event.",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "account",
                  "type": "[U8; 32]",
                  "type_name": "AccountId"
                }
              ]
            },
            {
              "lookup": "2b01",
              "name": "set_identity",
              "docs": [
                "Set an account's identity information and reserve the appropriate deposit.",
                "",
                "If the account already has identity information, the deposit is taken as part payment",
                "for the new deposit.",
                "",
                "The dispatch origin for this call must be _Signed_.",
                "",
                "- `info`: The identity information.",
                "",
                "Emits `IdentitySet` if successful.",
                "",
                "# \u003cweight\u003e",
                "- `O(X + X' + R)`",
                "  - where `X` additional-field-count (deposit-bounded and code-bounded)",
                "  - where `R` judgements-count (registrar-count-bounded)",
                "- One balance reserve operation.",
                "- One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`).",
                "- One event.",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "info",
                  "type": "pallet_identity:types:IdentityInfo",
                  "type_name": "Box\u003cIdentityInfo\u003cMaxAdditionalFields\u003e\u003e"
                }
              ]
            },
            {
              "lookup": "2b02",
              "name": "set_subs",
              "docs": [
                "Set the sub-accounts of the sender.",
                "",
                "Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned",
                "and an amount `SubAccountDeposit` will be reserved for each item in `subs`.",
                "",
                "The dispatch origin for this call must be _Signed_ and the sender must have a registered",
                "identity.",
                "",
                "- `subs`: The identity's (new) sub-accounts.",
                "",
                "# \u003cweight\u003e",
                "- `O(P + S)`",
                "  - where `P` old-subs-count (hard- and deposit-bounded).",
                "  - where `S` subs-count (hard- and deposit-bounded).",
                "- At most one balance operations.",
                "- DB:",
                "  - `P + S` storage mutations (codec complexity `O(1)`)",
                "  - One storage read (codec complexity `O(P)`).",
                "  - One storage write (codec complexity `O(S)`).",
                "  - One storage-exists (`IdentityOf::contains_key`).",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "subs",
                  "type": "Vec\u003cTuple:[U8; 32]pallet_identity:types:Data\u003e",
                  "type_name": "Vec\u003c(AccountId, Data)\u003e"
                }
              ]
            },
            {
              "lookup": "2b03",
              "name": "clear_identity",
              "docs": [
                "Clear an account's identity info and all sub-accounts and return all deposits.",
                "",
                "Payment: All reserved balances on the account are returned.",
                "",
                "The dispatch origin for this call must be _Signed_ and the sender must have a registered",
                "identity.",
                "",
                "Emits `IdentityCleared` if successful.",
                "",
                "# \u003cweight\u003e",
                "- `O(R + S + X)`",
                "  - where `R` registrar-count (governance-bounded).",
                "  - where `S` subs-count (hard- and deposit-bounded).",
                "  - where `X` additional-field-count (deposit-bounded and code-bounded).",
                "- One balance-unreserve operation.",
                "- `2` storage reads and `S + 2` storage deletions.",
                "- One event.",
                "# \u003c/weight\u003e"
              ],
              "args": null
            },
            {
              "lookup": "2b04",
              "name": "request_judgement",
              "docs": [
                "Request a judgement from a registrar.",
                "",
                "Payment: At most `max_fee` will be reserved for payment to the registrar if judgement",
                "given.",
                "",
                "The dispatch origin for this call must be _Signed_ and the sender must have a",
                "registered identity.",
                "",
                "- `reg_index`: The index of the registrar whose judgement is requested.",
                "- `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:",
                "",
                "```nocompile",
                "Self::registrars().get(reg_index).unwrap().fee",
                "```",
                "",
                "Emits `JudgementRequested` if successful.",
                "",
                "# \u003cweight\u003e",
                "- `O(R + X)`.",
                "- One balance-reserve operation.",
                "- Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.",
                "- One event.",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "reg_index",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "RegistrarIndex"
                },
                {
                  "TypeName": "",
                  "name": "max_fee",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "2b05",
              "name": "cancel_request",
              "docs": [
                "Cancel a previous request.",
                "",
                "Payment: A previously reserved deposit is returned on success.",
                "",
                "The dispatch origin for this call must be _Signed_ and the sender must have a",
                "registered identity.",
                "",
                "- `reg_index`: The index of the registrar whose judgement is no longer requested.",
                "",
                "Emits `JudgementUnrequested` if successful.",
                "",
                "# \u003cweight\u003e",
                "- `O(R + X)`.",
                "- One balance-reserve operation.",
                "- One storage mutation `O(R + X)`.",
                "- One event",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "reg_index",
                  "type": "U32",
                  "type_name": "RegistrarIndex"
                }
              ]
            },
            {
              "lookup": "2b06",
              "name": "set_fee",
              "docs": [
                "Set the fee required for a judgement to be requested from a registrar.",
                "",
                "The dispatch origin for this call must be _Signed_ and the sender must be the account",
                "of the registrar whose index is `index`.",
                "",
                "- `index`: the index of the registrar whose fee is to be set.",
                "- `fee`: the new fee.",
                "",
                "# \u003cweight\u003e",
                "- `O(R)`.",
                "- One storage mutation `O(R)`.",
                "2d2042656e63686d61726b3a20372e333135202b2052202a20302e33323920c2b57320286d696e207371756172657320616e616c7973697329",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "RegistrarIndex"
                },
                {
                  "TypeName": "",
                  "name": "fee",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "2b07",
              "name": "set_account_id",
              "docs": [
                "Change the account associated with a registrar.",
                "",
                "The dispatch origin for this call must be _Signed_ and the sender must be the account",
                "of the registrar whose index is `index`.",
                "",
                "- `index`: the index of the registrar whose fee is to be set.",
                "- `new`: the new account ID.",
                "",
                "# \u003cweight\u003e",
                "- `O(R)`.",
                "- One storage mutation `O(R)`.",
                "2d2042656e63686d61726b3a20382e383233202b2052202a20302e333220c2b57320286d696e207371756172657320616e616c7973697329",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "RegistrarIndex"
                },
                {
                  "TypeName": "",
                  "name": "new",
                  "type": "[U8; 32]",
                  "type_name": "AccountId"
                }
              ]
            },
            {
              "lookup": "2b08",
              "name": "set_fields",
              "docs": [
                "Set the field information for a registrar.",
                "",
                "The dispatch origin for this call must be _Signed_ and the sender must be the account",
                "of the registrar whose index is `index`.",
                "",
                "- `index`: the index of the registrar whose fee is to be set.",
                "- `fields`: the fields that the registrar concerns themselves with.",
                "",
                "# \u003cweight\u003e",
                "- `O(R)`.",
                "- One storage mutation `O(R)`.",
                "2d2042656e63686d61726b3a20372e343634202b2052202a20302e33323520c2b57320286d696e207371756172657320616e616c7973697329",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "RegistrarIndex"
                },
                {
                  "TypeName": "",
                  "name": "fields",
                  "type": "U64",
                  "type_name": "IdentityFields"
                }
              ]
            },
            {
              "lookup": "2b09",
              "name": "provide_judgement",
              "docs": [
                "Provide a judgement for an account's identity.",
                "",
                "The dispatch origin for this call must be _Signed_ and the sender must be the account",
                "of the registrar whose index is `reg_index`.",
                "",
                "- `reg_index`: the index of the registrar whose judgement is being made.",
                "- `target`: the account whose identity the judgement is upon. This must be an account",
                "  with a registered identity.",
                "- `judgement`: the judgement of the registrar of index `reg_index` about `target`.",
                "",
                "Emits `JudgementGiven` if successful.",
                "",
                "# \u003cweight\u003e",
                "- `O(R + X)`.",
                "- One balance-transfer operation.",
                "- Up to one account-lookup operation.",
                "- Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.",
                "- One event.",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "reg_index",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "RegistrarIndex"
                },
                {
                  "TypeName": "",
                  "name": "target",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                },
                {
                  "TypeName": "",
                  "name": "judgement",
                  "type": "pallet_identity:types:Judgement",
                  "type_name": "Judgement\u003cBalanceOf\u003e"
                }
              ]
            },
            {
              "lookup": "2b0a",
              "name": "kill_identity",
              "docs": [
                "Remove an account's identity and sub-account information and slash the deposits.",
                "",
                "Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by",
                "`Slash`. Verification request deposits are not returned; they should be cancelled",
                "manually using `cancel_request`.",
                "",
                "The dispatch origin for this call must match `T::ForceOrigin`.",
                "",
                "- `target`: the account whose identity the judgement is upon. This must be an account",
                "  with a registered identity.",
                "",
                "Emits `IdentityKilled` if successful.",
                "",
                "# \u003cweight\u003e",
                "- `O(R + S + X)`.",
                "- One balance-reserve operation.",
                "- `S + 2` storage mutations.",
                "- One event.",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "target",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                }
              ]
            },
            {
              "lookup": "2b0b",
              "name": "add_sub",
              "docs": [
                "Add the given account to the sender's subs.",
                "",
                "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated",
                "to the sender.",
                "",
                "The dispatch origin for this call must be _Signed_ and the sender must have a registered",
                "sub identity of `sub`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "sub",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                },
                {
                  "TypeName": "",
                  "name": "data",
                  "type": "pallet_identity:types:Data",
                  "type_name": "Data"
                }
              ]
            },
            {
              "lookup": "2b0c",
              "name": "rename_sub",
              "docs": [
                "Alter the associated name of the given sub-account.",
                "",
                "The dispatch origin for this call must be _Signed_ and the sender must have a registered",
                "sub identity of `sub`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "sub",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                },
                {
                  "TypeName": "",
                  "name": "data",
                  "type": "pallet_identity:types:Data",
                  "type_name": "Data"
                }
              ]
            },
            {
              "lookup": "2b0d",
              "name": "remove_sub",
              "docs": [
                "Remove the given account from the sender's subs.",
                "",
                "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated",
                "to the sender.",
                "",
                "The dispatch origin for this call must be _Signed_ and the sender must have a registered",
                "sub identity of `sub`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "sub",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                }
              ]
            },
            {
              "lookup": "2b0e",
              "name": "quit_sub",
              "docs": [
                "Remove the sender as a sub-account.",
                "",
                "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated",
                "to the sender (*not* the original depositor).",
                "",
                "The dispatch origin for this call must be _Signed_ and the sender must have a registered",
                "super-identity.",
                "",
                "NOTE: This should not normally be used, but is provided in the case that the non-",
                "controller of an account is maliciously registered as a sub-account."
              ],
              "args": null
            }
          ],
          "calls_value": {
            "type": 189
          },
          "events": [
            {
              "lookup": "2b00",
              "name": "IdentitySet",
              "docs": [
                "A name was set or reset (which will remove all judgements)."
              ],
              "args": [
                "[U8; 32]"
              ],
              "args_type_name": [
                "AccountId"
              ]
            },
            {
              "lookup": "2b01",
              "name": "IdentityCleared",
              "docs": [
                "A name was cleared, and the given balance returned."
              ],
              "args": [
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "AccountId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "2b02",
              "name": "IdentityKilled",
              "docs": [
                "A name was removed and the given balance slashed."
              ],
              "args": [
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "AccountId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "2b03",
              "name": "JudgementRequested",
              "docs": [
                "A judgement was asked from a registrar."
              ],
              "args": [
                "[U8; 32]",
                "U32"
              ],
              "args_type_name": [
                "AccountId",
                "RegistrarIndex"
              ]
            },
            {
              "lookup": "2b04",
              "name": "JudgementUnrequested",
              "docs": [
                "A judgement request was retracted."
              ],
              "args": [
                "[U8; 32]",
                "U32"
              ],
              "args_type_name": [
                "AccountId",
                "RegistrarIndex"
              ]
            },
            {
              "lookup": "2b05",
              "name": "JudgementGiven",
              "docs": [
                "A judgement was given by a registrar."
              ],
              "args": [
                "[U8; 32]",
                "U32"
              ],
              "args_type_name": [
                "AccountId",
                "RegistrarIndex"
              ]
            },
            {
              "lookup": "2b06",
              "name": "RegistrarAdded",
              "docs": [
                "A registrar was added."
              ],
              "args": [
                "U32"
              ],
              "args_type_name": [
                "RegistrarIndex"
              ]
            },
            {
              "lookup": "2b07",
              "name": "SubIdentityAdded",
              "docs": [
                "A sub-identity was added to an identity and the deposit paid."
              ],
              "args": [
                "[U8; 32]",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "AccountId",
                "AccountId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "2b08",
              "name": "SubIdentityRemoved",
              "docs": [
                "A sub-identity was removed from an identity and the deposit freed."
              ],
              "args": [
                "[U8; 32]",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "AccountId",
                "AccountId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "2b09",
              "name": "SubIdentityRevoked",
              "docs": [
                "A sub-identity was cleared, and the given deposit repatriated from the",
                "main identity account to the sub-identity account."
              ],
              "args": [
                "[U8; 32]",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "AccountId",
                "AccountId",
                "BalanceOf"
              ]
            }
          ],
          "events_value": {
            "type": 80
          },
          "constants": [
            {
              "name": "BasicDeposit",
              "type": "U128",
              "type_value": 6,
              "constants_value": "084cd2c2070000000000000000000000",
              "docs": [
                " The amount held on deposit for a registered identity"
              ]
            },
            {
              "name": "FieldDeposit",
              "type": "U128",
              "type_value": 6,
              "constants_value": "0293b4f0010000000000000000000000",
              "docs": [
                " The amount held on deposit per additional field for a registered identity."
              ]
            },
            {
              "name": "SubAccountDeposit",
              "type": "U128",
              "type_value": 6,
              "constants_value": "68425d8d010000000000000000000000",
              "docs": [
                " The amount held on deposit for a registered subaccount. This should account for the fact",
                " that one storage item's value will increase by the size of an account ID, and there will",
                " be another trie item whose value is the size of an account ID plus 32 bytes."
              ]
            },
            {
              "name": "MaxSubAccounts",
              "type": "U32",
              "type_value": 4,
              "constants_value": "64000000",
              "docs": [
                " The maximum number of sub-accounts allowed per identified account."
              ]
            },
            {
              "name": "MaxAdditionalFields",
              "type": "U32",
              "type_value": 4,
              "constants_value": "64000000",
              "docs": [
                " Maximum number of additional fields that may be stored in an ID. Needed to bound the I/O",
                " required to access an identity, but can be pretty high."
              ]
            },
            {
              "name": "MaxRegistrars",
              "type": "U32",
              "type_value": 4,
              "constants_value": "14000000",
              "docs": [
                " Maxmimum number of registrars allowed in the system. Needed to bound the complexity",
                " of, e.g., updating judgements."
              ]
            }
          ],
          "errors": [
            {
              "name": "TooManySubAccounts",
              "doc": [
                "Too many subs-accounts."
              ]
            },
            {
              "name": "NotFound",
              "doc": [
                "Account isn't found."
              ]
            },
            {
              "name": "NotNamed",
              "doc": [
                "Account isn't named."
              ]
            },
            {
              "name": "EmptyIndex",
              "doc": [
                "Empty index."
              ]
            },
            {
              "name": "FeeChanged",
              "doc": [
                "Fee is changed."
              ]
            },
            {
              "name": "NoIdentity",
              "doc": [
                "No identity found."
              ]
            },
            {
              "name": "StickyJudgement",
              "doc": [
                "Sticky judgement."
              ]
            },
            {
              "name": "JudgementGiven",
              "doc": [
                "Judgement given."
              ]
            },
            {
              "name": "InvalidJudgement",
              "doc": [
                "Invalid judgement."
              ]
            },
            {
              "name": "InvalidIndex",
              "doc": [
                "The index is invalid."
              ]
            },
            {
              "name": "InvalidTarget",
              "doc": [
                "The target is invalid."
              ]
            },
            {
              "name": "TooManyFields",
              "doc": [
                "Too many additional fields."
              ]
            },
            {
              "name": "TooManyRegistrars",
              "doc": [
                "Maximum amount of registrars reached. Cannot add any more."
              ]
            },
            {
              "name": "AlreadyClaimed",
              "doc": [
                "Account ID is already named."
              ]
            },
            {
              "name": "NotSub",
              "doc": [
                "Sender is not a sub-account."
              ]
            },
            {
              "name": "NotOwned",
              "doc": [
                "Sub-account isn't owned by sender."
              ]
            }
          ],
          "errors_value": {
            "type": 384
          },
          "index": 43
        },
        {
          "name": "Democracy",
          "prefix": "Democracy",
          "storage": [
            {
              "name": "PublicPropCount",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " The number of (public) proposals that have been made so far."
              ]
            },
            {
              "name": "PublicProps",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cTuple:U32H256[U8; 32]\u003e",
                "PlainTypeValue": 385
              },
              "fallback": "0x00",
              "docs": [
                " The public proposals. Unsorted. The second item is the proposal's hash."
              ]
            },
            {
              "name": "DepositOf",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "U32"
                  ],
                  "value": "Tuple:Vec\u003c[U8; 32]\u003eU128",
                  "keys_id": 4,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Those who have locked a deposit.",
                "",
                " TWOX-NOTE: Safe, as increasing integer keys are safe."
              ]
            },
            {
              "name": "Preimages",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Identity"
                  ],
                  "key_vec": [
                    "H256"
                  ],
                  "value": "democracy:PreimageStatus",
                  "keys_id": 9,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Map of hashes to the proposal preimage, along with who registered it and their deposit.",
                " The block number is the block at which it was deposited."
              ]
            },
            {
              "name": "ReferendumCount",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " The next free referendum index, aka the number of referenda started so far."
              ]
            },
            {
              "name": "LowestUnbaked",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " The lowest referendum index representing an unbaked referendum. Equal to",
                " `ReferendumCount` if there isn't a unbaked referendum."
              ]
            },
            {
              "name": "ReferendumInfoOf",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "U32"
                  ],
                  "value": "democracy:types:ReferendumInfo",
                  "keys_id": 4,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Information concerning any given referendum.",
                "",
                "2054574f582d4e4f54453a205341464520617320696e646578657320617265206e6f7420756e64657220616e2061747461636b6572e280997320636f6e74726f6c2e"
              ]
            },
            {
              "name": "VotingOf",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "[U8; 32]"
                  ],
                  "value": "Vec\u003cTuple:U32democracy:types:Vote\u003e",
                  "keys_id": 0,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " All votes for a particular voter. We store the balance for the number of votes that we",
                " have recorded.",
                "",
                " TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway."
              ]
            },
            {
              "name": "StorageVersion",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "democracy:Releases",
                "PlainTypeValue": 395
              },
              "fallback": "0x00",
              "docs": [
                " Storage version of the pallet.",
                "",
                " New networks start with last version."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1c00",
              "name": "propose",
              "docs": [
                "Propose a sensitive action to be taken.",
                "",
                "The dispatch origin of this call must be _Signed_ and the sender must",
                "have funds to cover the deposit.",
                "",
                "- `proposal_hash`: The hash of the proposal preimage.",
                "- `value`: The amount of deposit (must be at least `MinimumDeposit`).",
                "",
                "Emits `Proposed`.",
                "",
                "Weight: `O(p)`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "proposal_hash",
                  "type": "H256",
                  "type_name": "Hash"
                },
                {
                  "TypeName": "",
                  "name": "value",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                }
              ]
            },
            {
              "lookup": "1c01",
              "name": "second",
              "docs": [
                "Signals agreement with a particular proposal.",
                "",
                "The dispatch origin of this call must be _Signed_ and the sender",
                "must have funds to cover the deposit, equal to the original deposit.",
                "",
                "- `proposal`: The index of the proposal to second.",
                "- `seconds_upper_bound`: an upper bound on the current number of seconds on this proposal. Extrinsic is",
                "  weighted according to this value with no refund.",
                "",
                "Weight: `O(S)` where S is the number of seconds a proposal already has."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "proposal",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "PropIndex"
                },
                {
                  "TypeName": "",
                  "name": "seconds_upper_bound",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "1c02",
              "name": "vote",
              "docs": [
                "Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;",
                "otherwise it is a vote to keep the status quo.",
                "",
                "The dispatch origin of this call must be _Signed_.",
                "",
                "- `ref_index`: The index of the referendum to vote for.",
                "- `vote`: The vote configuration.",
                "",
                "Weight: `O(R)` where R is the number of referendums the voter has voted on."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "ref_index",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "ReferendumIndex"
                },
                {
                  "TypeName": "",
                  "name": "vote",
                  "type": "democracy:types:Vote",
                  "type_name": "Vote\u003cBalanceOf\u003e"
                }
              ]
            },
            {
              "lookup": "1c03",
              "name": "fast_track",
              "docs": [
                "Schedule the currently externally-proposed majority-carries referendum to be tabled",
                "immediately. If there is no externally-proposed referendum currently, or if there is one",
                "but it is not a majority-carries referendum then it fails.",
                "",
                "The dispatch of this call must be `FastTrackOrigin`.",
                "",
                "- `proposal_hash`: The hash of the current external proposal.",
                "- `delay`: The number of block after voting has ended in approval and this should be enacted. This doesn't",
                "  have a minimum amount.",
                "",
                "Emits `Started`.",
                "",
                "Weight: `O(1)`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "prop_index",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "PropIndex"
                },
                {
                  "TypeName": "",
                  "name": "delay",
                  "type": "U32",
                  "type_name": "BlockNumber"
                }
              ]
            },
            {
              "lookup": "1c04",
              "name": "cancel_referendum",
              "docs": [
                "Remove a referendum.",
                "",
                "The dispatch origin of this call must be _Root_.",
                "",
                "- `ref_index`: The index of the referendum to cancel.",
                "",
                "# Weight: `O(1)`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "ref_index",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "ReferendumIndex"
                }
              ]
            },
            {
              "lookup": "1c05",
              "name": "cancel_queued",
              "docs": [
                "Cancel a proposal queued for enactment.",
                "",
                "The dispatch origin of this call must be _Root_.",
                "",
                "- `which`: The index of the referendum to cancel.",
                "",
                "Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "which",
                  "type": "U32",
                  "type_name": "ReferendumIndex"
                }
              ]
            },
            {
              "lookup": "1c06",
              "name": "clear_public_proposals",
              "docs": [
                "Clears all public proposals.",
                "",
                "The dispatch origin of this call must be _Root_.",
                "",
                "Weight: `O(1)`."
              ],
              "args": null
            },
            {
              "lookup": "1c07",
              "name": "cancel_proposal",
              "docs": [
                "Remove a proposal.",
                "",
                "- `prop_index`: The index of the proposal to cancel.",
                "",
                "Weight: `O(p)` where `p = PublicProps::\u003cT\u003e::decode_len()`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "prop_index",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "PropIndex"
                }
              ]
            },
            {
              "lookup": "1c08",
              "name": "note_preimage",
              "docs": [
                "Register the preimage for an upcoming proposal. This doesn't require the proposal to be",
                "in the dispatch queue but does require a deposit, returned once enacted.",
                "",
                "The dispatch origin of this call must be _Signed_.",
                "",
                "- `encoded_proposal`: The preimage of a proposal.",
                "",
                "Emits `PreimageNoted`.",
                "",
                "Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "encoded_proposal",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "1c09",
              "name": "note_imminent_preimage",
              "docs": [
                "Register the preimage for an upcoming proposal. This requires the proposal to be",
                "in the dispatch queue. No deposit is needed. When this call is successful, i.e.",
                "the preimage has not been uploaded before and matches some imminent proposal,",
                "no fee is paid.",
                "",
                "The dispatch origin of this call must be _Signed_.",
                "",
                "- `encoded_proposal`: The preimage of a proposal.",
                "",
                "Emits `PreimageNoted`.",
                "",
                "Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "encoded_proposal",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            },
            {
              "lookup": "1c0a",
              "name": "reap_preimage",
              "docs": [
                "Remove an expired proposal preimage and collect the deposit.",
                "",
                "The dispatch origin of this call must be _Signed_.",
                "",
                "- `proposal_hash`: The preimage hash of a proposal.",
                "- `proposal_length_upper_bound`: an upper bound on length of the proposal. Extrinsic is weighted according",
                "  to this value with no refund.",
                "",
                "This will only work after `VotingPeriod` blocks from the time that the preimage was",
                "noted, if it's the same account doing it. If it's a different account, then it'll only",
                "work an additional `EnactmentPeriod` later.",
                "",
                "Emits `PreimageReaped`.",
                "",
                "Weight: `O(D)` where D is length of proposal."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "proposal_hash",
                  "type": "H256",
                  "type_name": "Hash"
                },
                {
                  "TypeName": "",
                  "name": "proposal_len_upper_bound",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "1c0b",
              "name": "remove_vote",
              "docs": [
                "Remove a vote for an ongoing referendum.",
                "",
                "The dispatch origin of this call must be _Signed_, and the signer must have a vote",
                "registered for referendum `index`.",
                "",
                "- `index`: The index of referendum of the vote to be removed.",
                "",
                "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.",
                "  Weight is calculated for the maximum number of vote."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "U32",
                  "type_name": "ReferendumIndex"
                }
              ]
            },
            {
              "lookup": "1c0c",
              "name": "enact_proposal",
              "docs": [
                "Enact a proposal from a referendum. For now we just make the weight be the maximum."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "proposal_hash",
                  "type": "H256",
                  "type_name": "Hash"
                },
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "U32",
                  "type_name": "ReferendumIndex"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 229
          },
          "events": [
            {
              "lookup": "1c00",
              "name": "Proposed",
              "docs": [
                "A motion has been proposed by a public account. \\[proposal_index, deposit\\]"
              ],
              "args": [
                "U32",
                "U128"
              ],
              "args_type_name": [
                "PropIndex",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1c01",
              "name": "Tabled",
              "docs": [
                "A public proposal has been tabled for referendum vote. \\[proposal_index, deposit,",
                "depositors\\]"
              ],
              "args": [
                "U32",
                "U128",
                "Vec\u003c[U8; 32]\u003e"
              ],
              "args_type_name": [
                "PropIndex",
                "BalanceOf",
                "Vec\u003cAccountId\u003e"
              ]
            },
            {
              "lookup": "1c02",
              "name": "Started",
              "docs": [
                "A referendum has begun. \\[ref_index, threshold\\]"
              ],
              "args": [
                "U32",
                "democracy:vote_threshold:VoteThreshold"
              ],
              "args_type_name": [
                "ReferendumIndex",
                "VoteThreshold"
              ]
            },
            {
              "lookup": "1c03",
              "name": "FastTrack",
              "docs": [
                "A referendum has been fast tracked. \\[ref_index\\]"
              ],
              "args": [
                "U32"
              ],
              "args_type_name": [
                "ReferendumIndex"
              ]
            },
            {
              "lookup": "1c04",
              "name": "Passed",
              "docs": [
                "A proposal has been approved by referendum. \\[ref_index\\]"
              ],
              "args": [
                "U32"
              ],
              "args_type_name": [
                "ReferendumIndex"
              ]
            },
            {
              "lookup": "1c05",
              "name": "NotPassed",
              "docs": [
                "A proposal has been rejected by referendum. \\[ref_index\\]"
              ],
              "args": [
                "U32"
              ],
              "args_type_name": [
                "ReferendumIndex"
              ]
            },
            {
              "lookup": "1c06",
              "name": "Cancelled",
              "docs": [
                "A referendum has been cancelled. \\[ref_index\\]"
              ],
              "args": [
                "U32"
              ],
              "args_type_name": [
                "ReferendumIndex"
              ]
            },
            {
              "lookup": "1c07",
              "name": "Executed",
              "docs": [
                "A proposal has been enacted. \\[ref_index, result\\]"
              ],
              "args": [
                "U32",
                "Results\u003cNULL,sp_runtime:DispatchError\u003e"
              ],
              "args_type_name": [
                "ReferendumIndex",
                "DispatchResult"
              ]
            },
            {
              "lookup": "1c08",
              "name": "PreimageNoted",
              "docs": [
                "A proposal's preimage was noted, and the deposit taken. \\[proposal_hash, who, deposit\\]"
              ],
              "args": [
                "H256",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "Hash",
                "AccountId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1c09",
              "name": "PreimageUsed",
              "docs": [
                "A proposal preimage was removed and used (the deposit was returned).",
                "\\[proposal_hash, provider, deposit\\]"
              ],
              "args": [
                "H256",
                "[U8; 32]",
                "U128"
              ],
              "args_type_name": [
                "Hash",
                "AccountId",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1c0a",
              "name": "PreimageInvalid",
              "docs": [
                "A proposal could not be executed because its preimage was invalid.",
                "\\[proposal_hash, ref_index\\]"
              ],
              "args": [
                "H256",
                "U32"
              ],
              "args_type_name": [
                "Hash",
                "ReferendumIndex"
              ]
            },
            {
              "lookup": "1c0b",
              "name": "PreimageMissing",
              "docs": [
                "A proposal could not be executed because its preimage was missing.",
                "\\[proposal_hash, ref_index\\]"
              ],
              "args": [
                "H256",
                "U32"
              ],
              "args_type_name": [
                "Hash",
                "ReferendumIndex"
              ]
            },
            {
              "lookup": "1c0c",
              "name": "PreimageReaped",
              "docs": [
                "A registered preimage was removed and the deposit collected by the reaper.",
                "\\[proposal_hash, provider, deposit, reaper\\]"
              ],
              "args": [
                "H256",
                "[U8; 32]",
                "U128",
                "[U8; 32]"
              ],
              "args_type_name": [
                "Hash",
                "AccountId",
                "BalanceOf",
                "AccountId"
              ]
            }
          ],
          "events_value": {
            "type": 81
          },
          "constants": [
            {
              "name": "EnactmentPeriod",
              "type": "U32",
              "type_value": 4,
              "constants_value": "201c0000",
              "docs": [
                " The period between a proposal being approved and enacted.",
                "",
                " It should generally be a little more than the unstake period to ensure that",
                " voting stakers have an opportunity to remove themselves from the system in the case",
                " where they are on the losing side of a vote."
              ]
            },
            {
              "name": "LaunchPeriod",
              "type": "U32",
              "type_value": 4,
              "constants_value": "e0c40000",
              "docs": [
                " How often (in blocks) new public referenda are launched."
              ]
            },
            {
              "name": "VotingPeriod",
              "type": "U32",
              "type_value": 4,
              "constants_value": "e0c40000",
              "docs": [
                " How often (in blocks) to check for new votes."
              ]
            },
            {
              "name": "MinimumDeposit",
              "type": "U128",
              "type_value": 6,
              "constants_value": "005039278c0400000000000000000000",
              "docs": [
                " The minimum amount to be used as a deposit for a public referendum proposal."
              ]
            },
            {
              "name": "FastTrackVotingPeriod",
              "type": "U32",
              "type_value": 4,
              "constants_value": "84030000",
              "docs": [
                " Minimum voting period allowed for a fast-track referendum."
              ]
            },
            {
              "name": "PreimageByteDeposit",
              "type": "U128",
              "type_value": 6,
              "constants_value": "12160500000000000000000000000000",
              "docs": [
                " The amount of balance that must be deposited per byte of preimage stored."
              ]
            },
            {
              "name": "MaxVotes",
              "type": "U32",
              "type_value": 4,
              "constants_value": "64000000",
              "docs": [
                " The maximum number of votes for an account.",
                "",
                " Also used to compute weight, an overly big value can",
                " lead to extrinsic with very big weight."
              ]
            },
            {
              "name": "MaxProposals",
              "type": "U32",
              "type_value": 4,
              "constants_value": "64000000",
              "docs": [
                " The maximum number of public proposals that can exist at any time."
              ]
            }
          ],
          "errors": [
            {
              "name": "ValueLow",
              "doc": [
                "Value too low"
              ]
            },
            {
              "name": "ProposalMissing",
              "doc": [
                "Proposal does not exist"
              ]
            },
            {
              "name": "DuplicateProposal",
              "doc": [
                "Proposal already made"
              ]
            },
            {
              "name": "DuplicatePreimage",
              "doc": [
                "Preimage already noted"
              ]
            },
            {
              "name": "NotImminent",
              "doc": [
                "Not imminent"
              ]
            },
            {
              "name": "TooEarly",
              "doc": [
                "Too early"
              ]
            },
            {
              "name": "Imminent",
              "doc": [
                "Imminent"
              ]
            },
            {
              "name": "PreimageMissing",
              "doc": [
                "Preimage not found"
              ]
            },
            {
              "name": "ReferendumInvalid",
              "doc": [
                "Vote given for invalid referendum"
              ]
            },
            {
              "name": "PreimageInvalid",
              "doc": [
                "Invalid preimage"
              ]
            },
            {
              "name": "NoneWaiting",
              "doc": [
                "No proposals waiting"
              ]
            },
            {
              "name": "NotProposer",
              "doc": [
                "The given account did not make this proposal."
              ]
            },
            {
              "name": "NotVoter",
              "doc": [
                "The given account did not vote on the referendum."
              ]
            },
            {
              "name": "InsufficientFunds",
              "doc": [
                "Too high a balance was provided that the account cannot afford."
              ]
            },
            {
              "name": "WrongUpperBound",
              "doc": [
                "Invalid upper bound."
              ]
            },
            {
              "name": "MaxVotesReached",
              "doc": [
                "Maximum number of votes reached."
              ]
            },
            {
              "name": "TooManyProposals",
              "doc": [
                "Maximum number of proposals reached."
              ]
            }
          ],
          "errors_value": {
            "type": 396
          },
          "index": 28
        },
        {
          "name": "TechnicalCommittee",
          "prefix": "TechnicalCommittee",
          "storage": [
            {
              "name": "Proposals",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cH256\u003e",
                "PlainTypeValue": 397
              },
              "fallback": "0x00",
              "docs": [
                " The hashes of the active proposals."
              ]
            },
            {
              "name": "ProposalOf",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Identity"
                  ],
                  "key_vec": [
                    "H256"
                  ],
                  "value": "Call",
                  "keys_id": 9,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Actual proposal for a given hash, if it's current."
              ]
            },
            {
              "name": "Voting",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Identity"
                  ],
                  "key_vec": [
                    "H256"
                  ],
                  "value": "pallet_collective:Votes",
                  "keys_id": 9,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Votes on a given proposal, if it is ongoing."
              ]
            },
            {
              "name": "ProposalCount",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " Proposals so far."
              ]
            },
            {
              "name": "Members",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003c[U8; 32]\u003e",
                "PlainTypeValue": 82
              },
              "fallback": "0x00",
              "docs": [
                " The current members of the collective. This is stored sorted (just by value)."
              ]
            },
            {
              "name": "Prime",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "[U8; 32]",
                "PlainTypeValue": 0
              },
              "fallback": "0x00",
              "docs": [
                " The prime member that helps determine the default vote behavior in case of absentations."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1d00",
              "name": "set_members",
              "docs": [
                "Set the collective's membership.",
                "",
                "- `new_members`: The new member list. Be nice to the chain and provide it sorted.",
                "- `prime`: The prime member whose vote sets the default.",
                "- `old_count`: The upper bound for the previous number of members in storage. Used for",
                "  weight estimation.",
                "",
                "Requires root origin.",
                "",
                "NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but",
                "      the weight estimations rely on it to estimate dispatchable weight.",
                "",
                "# WARNING:",
                "",
                "The `pallet-collective` can also be managed by logic outside of the pallet through the",
                "implementation of the trait [`ChangeMembers`].",
                "Any call to `set_members` must be careful that the member set doesn't get out of sync",
                "with other logic managing the member set.",
                "",
                "# \u003cweight\u003e",
                "## Weight",
                "- `O(MP + N)` where:",
                "  - `M` old-members-count (code- and governance-bounded)",
                "  - `N` new-members-count (code- and governance-bounded)",
                "  - `P` proposals-count (code-bounded)",
                "- DB:",
                "  - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the",
                "    members",
                "  - 1 storage read (codec `O(P)`) for reading the proposals",
                "  - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal",
                "  - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "new_members",
                  "type": "Vec\u003c[U8; 32]\u003e",
                  "type_name": "Vec\u003cAccountId\u003e"
                },
                {
                  "TypeName": "",
                  "name": "prime",
                  "type": "option\u003c[U8; 32]\u003e",
                  "type_name": "Option\u003cAccountId\u003e"
                },
                {
                  "TypeName": "",
                  "name": "old_count",
                  "type": "U32",
                  "type_name": "MemberCount"
                }
              ]
            },
            {
              "lookup": "1d01",
              "name": "execute",
              "docs": [
                "Dispatch a proposal from a member using the `Member` origin.",
                "",
                "Origin must be a member of the collective.",
                "",
                "# \u003cweight\u003e",
                "## Weight",
                "- `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching",
                "  `proposal`",
                "- DB: 1 read (codec `O(M)`) + DB access of `proposal`",
                "- 1 event",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "proposal",
                  "type": "Call",
                  "type_name": "Box\u003c\u003cT as Config\u003cI\u003e\u003e::Proposal\u003e"
                },
                {
                  "TypeName": "",
                  "name": "length_bound",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "1d02",
              "name": "propose",
              "docs": [
                "Add a new proposal to either be voted on or executed directly.",
                "",
                "Requires the sender to be member.",
                "",
                "`threshold` determines whether `proposal` is executed directly (`threshold \u003c 2`)",
                "or put up for voting.",
                "",
                "# \u003cweight\u003e",
                "## Weight",
                "- `O(B + M + P1)` or `O(B + M + P2)` where:",
                "  - `B` is `proposal` size in bytes (length-fee-bounded)",
                "  - `M` is members-count (code- and governance-bounded)",
                "  - branching is influenced by `threshold` where:",
                "    - `P1` is proposal execution complexity (`threshold \u003c 2`)",
                "    - `P2` is proposals-count (code-bounded) (`threshold \u003e= 2`)",
                "- DB:",
                "  - 1 storage read `is_member` (codec `O(M)`)",
                "  - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)",
                "  - DB accesses influenced by `threshold`:",
                "    - EITHER storage accesses done by `proposal` (`threshold \u003c 2`)",
                "    - OR proposal insertion (`threshold \u003c= 2`)",
                "      - 1 storage mutation `Proposals` (codec `O(P2)`)",
                "      - 1 storage mutation `ProposalCount` (codec `O(1)`)",
                "      - 1 storage write `ProposalOf` (codec `O(B)`)",
                "      - 1 storage write `Voting` (codec `O(M)`)",
                "  - 1 event",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "threshold",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "MemberCount"
                },
                {
                  "TypeName": "",
                  "name": "proposal",
                  "type": "Call",
                  "type_name": "Box\u003c\u003cT as Config\u003cI\u003e\u003e::Proposal\u003e"
                },
                {
                  "TypeName": "",
                  "name": "length_bound",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "1d03",
              "name": "vote",
              "docs": [
                "Add an aye or nay vote for the sender to the given proposal.",
                "",
                "Requires the sender to be a member.",
                "",
                "Transaction fees will be waived if the member is voting on any particular proposal",
                "for the first time and the call is successful. Subsequent vote changes will charge a",
                "fee.",
                "# \u003cweight\u003e",
                "## Weight",
                "- `O(M)` where `M` is members-count (code- and governance-bounded)",
                "- DB:",
                "  - 1 storage read `Members` (codec `O(M)`)",
                "  - 1 storage mutation `Voting` (codec `O(M)`)",
                "- 1 event",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "proposal",
                  "type": "H256",
                  "type_name": "Hash"
                },
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "ProposalIndex"
                },
                {
                  "TypeName": "",
                  "name": "approve",
                  "type": "Bool",
                  "type_name": "bool"
                }
              ]
            },
            {
              "lookup": "1d04",
              "name": "close",
              "docs": [
                "Close a vote that is either approved, disapproved or whose voting period has ended.",
                "",
                "May be called by any signed account in order to finish voting and close the proposal.",
                "",
                "If called before the end of the voting period it will only close the vote if it is",
                "has enough votes to be approved or disapproved.",
                "",
                "If called after the end of the voting period abstentions are counted as rejections",
                "unless there is a prime member set and the prime member cast an approval.",
                "",
                "If the close operation completes successfully with disapproval, the transaction fee will",
                "be waived. Otherwise execution of the approved operation will be charged to the caller.",
                "",
                "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed",
                "proposal.",
                "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via",
                "`storage::read` so it is `size_of::\u003cu32\u003e() == 4` larger than the pure length.",
                "",
                "# \u003cweight\u003e",
                "## Weight",
                "- `O(B + M + P1 + P2)` where:",
                "  - `B` is `proposal` size in bytes (length-fee-bounded)",
                "  - `M` is members-count (code- and governance-bounded)",
                "  - `P1` is the complexity of `proposal` preimage.",
                "  - `P2` is proposal-count (code-bounded)",
                "- DB:",
                " - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)",
                " - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec",
                "   `O(P2)`)",
                " - any mutations done while executing `proposal` (`P1`)",
                "- up to 3 events",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "proposal_hash",
                  "type": "H256",
                  "type_name": "Hash"
                },
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "ProposalIndex"
                },
                {
                  "TypeName": "",
                  "name": "proposal_weight_bound",
                  "type": "compact\u003cU64\u003e",
                  "type_name": "Weight"
                },
                {
                  "TypeName": "",
                  "name": "length_bound",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "1d05",
              "name": "disapprove_proposal",
              "docs": [
                "Disapprove a proposal, close, and remove it from the system, regardless of its current",
                "state.",
                "",
                "Must be called by the Root origin.",
                "",
                "Parameters:",
                "* `proposal_hash`: The hash of the proposal that should be disapproved.",
                "",
                "# \u003cweight\u003e",
                "Complexity: O(P) where P is the number of max proposals",
                "DB Weight:",
                "* Reads: Proposals",
                "* Writes: Voting, Proposals, ProposalOf",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "proposal_hash",
                  "type": "H256",
                  "type_name": "Hash"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 231
          },
          "events": [
            {
              "lookup": "1d00",
              "name": "Proposed",
              "docs": [
                "A motion (given hash) has been proposed (by given account) with a threshold (given",
                "`MemberCount`)."
              ],
              "args": [
                "[U8; 32]",
                "U32",
                "H256",
                "U32"
              ],
              "args_type_name": [
                "AccountId",
                "ProposalIndex",
                "Hash",
                "MemberCount"
              ]
            },
            {
              "lookup": "1d01",
              "name": "Voted",
              "docs": [
                "A motion (given hash) has been voted on by given account, leaving",
                "a tally (yes votes and no votes given respectively as `MemberCount`)."
              ],
              "args": [
                "[U8; 32]",
                "H256",
                "Bool",
                "U32",
                "U32"
              ],
              "args_type_name": [
                "AccountId",
                "Hash",
                "bool",
                "MemberCount",
                "MemberCount"
              ]
            },
            {
              "lookup": "1d02",
              "name": "Approved",
              "docs": [
                "A motion was approved by the required threshold."
              ],
              "args": [
                "H256"
              ],
              "args_type_name": [
                "Hash"
              ]
            },
            {
              "lookup": "1d03",
              "name": "Disapproved",
              "docs": [
                "A motion was not approved by the required threshold."
              ],
              "args": [
                "H256"
              ],
              "args_type_name": [
                "Hash"
              ]
            },
            {
              "lookup": "1d04",
              "name": "Executed",
              "docs": [
                "A motion was executed; result will be `Ok` if it returned without error."
              ],
              "args": [
                "H256",
                "Results\u003cNULL,sp_runtime:DispatchError\u003e"
              ],
              "args_type_name": [
                "Hash",
                "DispatchResult"
              ]
            },
            {
              "lookup": "1d05",
              "name": "MemberExecuted",
              "docs": [
                "A single member did some action; result will be `Ok` if it returned without error."
              ],
              "args": [
                "H256",
                "Results\u003cNULL,sp_runtime:DispatchError\u003e"
              ],
              "args_type_name": [
                "Hash",
                "DispatchResult"
              ]
            },
            {
              "lookup": "1d06",
              "name": "Closed",
              "docs": [
                "A proposal was closed because its threshold was reached or after its duration was up."
              ],
              "args": [
                "H256",
                "U32",
                "U32"
              ],
              "args_type_name": [
                "Hash",
                "MemberCount",
                "MemberCount"
              ]
            }
          ],
          "events_value": {
            "type": 84
          },
          "errors": [
            {
              "name": "NotMember",
              "doc": [
                "Account is not a member"
              ]
            },
            {
              "name": "DuplicateProposal",
              "doc": [
                "Duplicate proposals not allowed"
              ]
            },
            {
              "name": "ProposalMissing",
              "doc": [
                "Proposal must exist"
              ]
            },
            {
              "name": "WrongIndex",
              "doc": [
                "Mismatched index"
              ]
            },
            {
              "name": "DuplicateVote",
              "doc": [
                "Duplicate vote ignored"
              ]
            },
            {
              "name": "AlreadyInitialized",
              "doc": [
                "Members are already initialized!"
              ]
            },
            {
              "name": "TooEarly",
              "doc": [
                "The close call was made too early, before the end of the voting."
              ]
            },
            {
              "name": "TooManyProposals",
              "doc": [
                "There can only be a maximum of `MaxProposals` active proposals."
              ]
            },
            {
              "name": "WrongProposalWeight",
              "doc": [
                "The given weight bound for the proposal was too low."
              ]
            },
            {
              "name": "WrongProposalLength",
              "doc": [
                "The given length bound for the proposal was too low."
              ]
            }
          ],
          "errors_value": {
            "type": 399
          },
          "index": 29
        },
        {
          "name": "TechnicalMembership",
          "prefix": "TechnicalMembership",
          "storage": [
            {
              "name": "Members",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003c[U8; 32]\u003e",
                "PlainTypeValue": 82
              },
              "fallback": "0x00",
              "docs": [
                " The current membership, stored as an ordered Vec."
              ]
            },
            {
              "name": "Prime",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "[U8; 32]",
                "PlainTypeValue": 0
              },
              "fallback": "0x00",
              "docs": [
                " The current prime member, if one exists."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1e00",
              "name": "add_member",
              "docs": [
                "Add a member `who` to the set.",
                "",
                "May only be called from `T::AddOrigin`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "who",
                  "type": "[U8; 32]",
                  "type_name": "AccountId"
                }
              ]
            },
            {
              "lookup": "1e01",
              "name": "remove_member",
              "docs": [
                "Remove a member `who` from the set.",
                "",
                "May only be called from `T::RemoveOrigin`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "who",
                  "type": "[U8; 32]",
                  "type_name": "AccountId"
                }
              ]
            },
            {
              "lookup": "1e02",
              "name": "swap_member",
              "docs": [
                "Swap out one member `remove` for another `add`.",
                "",
                "May only be called from `T::SwapOrigin`.",
                "",
                "Prime membership is *not* passed from `remove` to `add`, if extant."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "remove",
                  "type": "[U8; 32]",
                  "type_name": "AccountId"
                },
                {
                  "TypeName": "",
                  "name": "add",
                  "type": "[U8; 32]",
                  "type_name": "AccountId"
                }
              ]
            },
            {
              "lookup": "1e03",
              "name": "reset_members",
              "docs": [
                "Change the membership to a new set, disregarding the existing membership. Be nice and",
                "pass `members` pre-sorted.",
                "",
                "May only be called from `T::ResetOrigin`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "members",
                  "type": "Vec\u003c[U8; 32]\u003e",
                  "type_name": "Vec\u003cAccountId\u003e"
                }
              ]
            },
            {
              "lookup": "1e04",
              "name": "change_key",
              "docs": [
                "Swap out the sending member for some other key `new`.",
                "",
                "May only be called from `Signed` origin of a current member.",
                "",
                "Prime membership is passed from the origin account to `new`, if extant."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "new",
                  "type": "[U8; 32]",
                  "type_name": "AccountId"
                }
              ]
            },
            {
              "lookup": "1e05",
              "name": "set_prime",
              "docs": [
                "Set the prime member. Must be a current member.",
                "",
                "May only be called from `T::PrimeOrigin`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "who",
                  "type": "[U8; 32]",
                  "type_name": "AccountId"
                }
              ]
            },
            {
              "lookup": "1e06",
              "name": "clear_prime",
              "docs": [
                "Remove the prime member if it exists.",
                "",
                "May only be called from `T::PrimeOrigin`."
              ],
              "args": null
            }
          ],
          "calls_value": {
            "type": 233
          },
          "events": [
            {
              "lookup": "1e00",
              "name": "MemberAdded",
              "docs": [
                "The given member was added; see the transaction for who."
              ],
              "args": null
            },
            {
              "lookup": "1e01",
              "name": "MemberRemoved",
              "docs": [
                "The given member was removed; see the transaction for who."
              ],
              "args": null
            },
            {
              "lookup": "1e02",
              "name": "MembersSwapped",
              "docs": [
                "Two members were swapped; see the transaction for who."
              ],
              "args": null
            },
            {
              "lookup": "1e03",
              "name": "MembersReset",
              "docs": [
                "The membership was reset; see the transaction for who the new set is."
              ],
              "args": null
            },
            {
              "lookup": "1e04",
              "name": "KeyChanged",
              "docs": [
                "One of the members' keys changed."
              ],
              "args": null
            },
            {
              "lookup": "1e05",
              "name": "Dummy",
              "docs": [
                "Phantom member, never used."
              ],
              "args": null
            }
          ],
          "events_value": {
            "type": 85
          },
          "errors": [
            {
              "name": "AlreadyMember",
              "doc": [
                "Already a member."
              ]
            },
            {
              "name": "NotMember",
              "doc": [
                "Not a member."
              ]
            }
          ],
          "errors_value": {
            "type": 400
          },
          "index": 30
        },
        {
          "name": "Treasury",
          "prefix": "Treasury",
          "storage": [
            {
              "name": "ProposalCount",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " Number of proposals that have been made."
              ]
            },
            {
              "name": "Proposals",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "U32"
                  ],
                  "value": "pallet_treasury:Proposal",
                  "keys_id": 4,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Proposals that have been made."
              ]
            },
            {
              "name": "Approvals",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cU32\u003e",
                "PlainTypeValue": 402
              },
              "fallback": "0x00",
              "docs": [
                " Proposal indices that have been approved but not yet awarded."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "1f00",
              "name": "propose_spend",
              "docs": [
                "Put forward a suggestion for spending. A deposit proportional to the value",
                "is reserved and slashed if the proposal is rejected. It is returned once the",
                "proposal is awarded.",
                "",
                "# \u003cweight\u003e",
                "- Complexity: O(1)",
                "- DbReads: `ProposalCount`, `origin account`",
                "- DbWrites: `ProposalCount`, `Proposals`, `origin account`",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "value",
                  "type": "compact\u003cU128\u003e",
                  "type_name": "BalanceOf"
                },
                {
                  "TypeName": "",
                  "name": "beneficiary",
                  "type": "[U8; 32]",
                  "type_name": "Address"
                }
              ]
            },
            {
              "lookup": "1f01",
              "name": "reject_proposal",
              "docs": [
                "Reject a proposed spend. The original deposit will be slashed.",
                "",
                "May only be called from `T::RejectOrigin`.",
                "",
                "# \u003cweight\u003e",
                "- Complexity: O(1)",
                "- DbReads: `Proposals`, `rejected proposer account`",
                "- DbWrites: `Proposals`, `rejected proposer account`",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "proposal_id",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "ProposalIndex"
                }
              ]
            },
            {
              "lookup": "1f02",
              "name": "approve_proposal",
              "docs": [
                "Approve a proposal. At a later time, the proposal will be allocated to the beneficiary",
                "and the original deposit will be returned.",
                "",
                "May only be called from `T::ApproveOrigin`.",
                "",
                "# \u003cweight\u003e",
                "- Complexity: O(1).",
                "- DbReads: `Proposals`, `Approvals`",
                "- DbWrite: `Approvals`",
                "# \u003c/weight\u003e"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "proposal_id",
                  "type": "compact\u003cU32\u003e",
                  "type_name": "ProposalIndex"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 234
          },
          "events": [
            {
              "lookup": "1f00",
              "name": "Proposed",
              "docs": [
                "New proposal."
              ],
              "args": [
                "U32"
              ],
              "args_type_name": [
                "ProposalIndex"
              ]
            },
            {
              "lookup": "1f01",
              "name": "Spending",
              "docs": [
                "We have ended a spend period and will now allocate funds."
              ],
              "args": [
                "U128"
              ],
              "args_type_name": [
                "BalanceOf"
              ]
            },
            {
              "lookup": "1f02",
              "name": "Awarded",
              "docs": [
                "Some funds have been allocated."
              ],
              "args": [
                "U32",
                "U128",
                "[U8; 32]"
              ],
              "args_type_name": [
                "ProposalIndex",
                "BalanceOf",
                "AccountId"
              ]
            },
            {
              "lookup": "1f03",
              "name": "Rejected",
              "docs": [
                "A proposal was rejected; funds were slashed."
              ],
              "args": [
                "U32",
                "U128"
              ],
              "args_type_name": [
                "ProposalIndex",
                "BalanceOf"
              ]
            },
            {
              "lookup": "1f04",
              "name": "Burnt",
              "docs": [
                "Some of our funds have been burnt."
              ],
              "args": [
                "U128"
              ],
              "args_type_name": [
                "BalanceOf"
              ]
            },
            {
              "lookup": "1f05",
              "name": "Rollover",
              "docs": [
                "Spending has finished; this is the amount that rolls over until next spend."
              ],
              "args": [
                "U128"
              ],
              "args_type_name": [
                "BalanceOf"
              ]
            },
            {
              "lookup": "1f06",
              "name": "Deposit",
              "docs": [
                "Some funds have been deposited."
              ],
              "args": [
                "U128"
              ],
              "args_type_name": [
                "BalanceOf"
              ]
            }
          ],
          "events_value": {
            "type": 86
          },
          "constants": [
            {
              "name": "ProposalBond",
              "type": "U32",
              "type_value": 404,
              "constants_value": "50c30000",
              "docs": [
                " Fraction of a proposal's value that should be bonded in order to place the proposal.",
                " An accepted proposal gets these back. A rejected proposal does not."
              ]
            },
            {
              "name": "ProposalBondMinimum",
              "type": "U128",
              "type_value": 6,
              "constants_value": "05000000000000000000000000000000",
              "docs": [
                " Minimum amount of funds that should be placed in a deposit for making a proposal."
              ]
            },
            {
              "name": "ProposalBondMaximum",
              "type": "option\u003cU128\u003e",
              "type_value": 405,
              "constants_value": "00",
              "docs": [
                " Maximum amount of funds that should be placed in a deposit for making a proposal."
              ]
            },
            {
              "name": "SpendPeriod",
              "type": "U32",
              "type_value": 4,
              "constants_value": "e0c40000",
              "docs": [
                " Period between successive spends."
              ]
            },
            {
              "name": "Burn",
              "type": "U32",
              "type_value": 404,
              "constants_value": "00000000",
              "docs": [
                " Percentage of spare funds (if any) that are burnt per spend period."
              ]
            },
            {
              "name": "PalletId",
              "type": "[U8; 8]",
              "type_value": 320,
              "constants_value": "mod/trsy",
              "docs": [
                " The treasury's pallet id, used for deriving its sovereign account ID."
              ]
            },
            {
              "name": "MaxApprovals",
              "type": "U32",
              "type_value": 4,
              "constants_value": "64000000",
              "docs": [
                " The maximum number of approvals that can wait in the spending queue.",
                "",
                " NOTE: This parameter is also used within the Bounties Pallet extension if enabled."
              ]
            }
          ],
          "errors": [
            {
              "name": "InsufficientProposersBalance",
              "doc": [
                "Proposer's balance is too low."
              ]
            },
            {
              "name": "InvalidIndex",
              "doc": [
                "No proposal or bounty at that index."
              ]
            },
            {
              "name": "TooManyApprovals",
              "doc": [
                "Too many approvals in the queue."
              ]
            }
          ],
          "errors_value": {
            "type": 406
          },
          "index": 31
        },
        {
          "name": "ParachainSystem",
          "prefix": "ParachainSystem",
          "storage": [
            {
              "name": "PendingValidationCode",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cU8\u003e",
                "PlainTypeValue": 10
              },
              "fallback": "0x00",
              "docs": [
                " In case of a scheduled upgrade, this storage field contains the validation code to be applied.",
                "",
                " As soon as the relay chain gives us the go-ahead signal, we will overwrite the [`:code`][well_known_keys::CODE]",
                " which will result the next block process with the new validation code. This concludes the upgrade process.",
                "",
                " [well_known_keys::CODE]: sp_core::storage::well_known_keys::CODE"
              ]
            },
            {
              "name": "NewValidationCode",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cU8\u003e",
                "PlainTypeValue": 10
              },
              "fallback": "0x00",
              "docs": [
                " Validation code that is set by the parachain and is to be communicated to collator and",
                " consequently the relay-chain.",
                "",
                " This will be cleared in `on_initialize` of each new block if no other pallet already set",
                " the value."
              ]
            },
            {
              "name": "ValidationData",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "polkadot_primitives:v1:PersistedValidationData",
                "PlainTypeValue": 237
              },
              "fallback": "0x00",
              "docs": [
                " The [`PersistedValidationData`] set for this block.",
                " This value is expected to be set only once per block and it's never stored",
                " in the trie."
              ]
            },
            {
              "name": "DidSetValidationCode",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Bool",
                "PlainTypeValue": 68
              },
              "fallback": "0x00",
              "docs": [
                " Were the validation data set to notify the relay chain?"
              ]
            },
            {
              "name": "UpgradeRestrictionSignal",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "option\u003cpolkadot_primitives:v1:UpgradeRestriction\u003e",
                "PlainTypeValue": 407
              },
              "fallback": "0x00",
              "docs": [
                " An option which indicates if the relay-chain restricts signalling a validation code upgrade.",
                " In other words, if this is `Some` and [`NewValidationCode`] is `Some` then the produced",
                " candidate will be invalid.",
                "",
                " This storage item is a mirror of the corresponding value for the current parachain from the",
                " relay-chain. This value is ephemeral which means it doesn't hit the storage. This value is",
                " set after the inherent."
              ]
            },
            {
              "name": "RelayStateProof",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cVec\u003cU8\u003e\u003e",
                "PlainTypeValue": 239
              },
              "fallback": "0x00",
              "docs": [
                " The state proof for the last relay parent block.",
                "",
                " This field is meant to be updated each block with the validation data inherent. Therefore,",
                " before processing of the inherent, e.g. in `on_initialize` this data may be stale.",
                "",
                " This data is also absent from the genesis."
              ]
            },
            {
              "name": "RelevantMessagingState",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "cumulus_pallet_parachain_system:relay_state_snapshot:MessagingStateSnapshot",
                "PlainTypeValue": 409
              },
              "fallback": "0x00",
              "docs": [
                " The snapshot of some state related to messaging relevant to the current parachain as per",
                " the relay parent.",
                "",
                " This field is meant to be updated each block with the validation data inherent. Therefore,",
                " before processing of the inherent, e.g. in `on_initialize` this data may be stale.",
                "",
                " This data is also absent from the genesis."
              ]
            },
            {
              "name": "HostConfiguration",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "polkadot_primitives:v1:AbridgedHostConfiguration",
                "PlainTypeValue": 413
              },
              "fallback": "0x00",
              "docs": [
                " The parachain host configuration that was obtained from the relay parent.",
                "",
                " This field is meant to be updated each block with the validation data inherent. Therefore,",
                " before processing of the inherent, e.g. in `on_initialize` this data may be stale.",
                "",
                " This data is also absent from the genesis."
              ]
            },
            {
              "name": "LastDmqMqcHead",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "H256",
                "PlainTypeValue": 414
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "docs": [
                " The last downward message queue chain head we have observed.",
                "",
                " This value is loaded before and saved after processing inbound downward messages carried",
                " by the system inherent."
              ]
            },
            {
              "name": "LastHrmpMqcHeads",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cTuple:U32H256\u003e",
                "PlainTypeValue": 415
              },
              "fallback": "0x00",
              "docs": [
                " The message queue chain heads we have observed per each channel incoming channel.",
                "",
                " This value is loaded before and saved after processing inbound downward messages carried",
                " by the system inherent."
              ]
            },
            {
              "name": "ProcessedDownwardMessages",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " Number of downward messages processed in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block."
              ]
            },
            {
              "name": "HrmpWatermark",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " HRMP watermark that was set in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block."
              ]
            },
            {
              "name": "HrmpOutboundMessages",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cpolkadot_core_primitives:OutboundHrmpMessage\u003e",
                "PlainTypeValue": 418
              },
              "fallback": "0x00",
              "docs": [
                " HRMP messages that were sent in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block."
              ]
            },
            {
              "name": "UpwardMessages",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cVec\u003cU8\u003e\u003e",
                "PlainTypeValue": 142
              },
              "fallback": "0x00",
              "docs": [
                " Upward messages that were sent in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block."
              ]
            },
            {
              "name": "PendingUpwardMessages",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cVec\u003cU8\u003e\u003e",
                "PlainTypeValue": 142
              },
              "fallback": "0x00",
              "docs": [
                " Upward messages that are still pending and not yet send to the relay chain."
              ]
            },
            {
              "name": "AnnouncedHrmpMessagesPerCandidate",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00000000",
              "docs": [
                " The number of HRMP messages we observed in `on_initialize` and thus used that number for",
                " announcing the weight of `on_initialize` and `on_finalize`."
              ]
            },
            {
              "name": "ReservedXcmpWeightOverride",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "U64",
                "PlainTypeValue": 8
              },
              "fallback": "0x00",
              "docs": [
                " The weight we reserve at the beginning of the block for processing XCMP messages. This",
                " overrides the amount set in the Config trait."
              ]
            },
            {
              "name": "ReservedDmpWeightOverride",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "U64",
                "PlainTypeValue": 8
              },
              "fallback": "0x00",
              "docs": [
                " The weight we reserve at the beginning of the block for processing DMP messages. This",
                " overrides the amount set in the Config trait."
              ]
            },
            {
              "name": "AuthorizedUpgrade",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "H256",
                "PlainTypeValue": 9
              },
              "fallback": "0x00",
              "docs": [
                " The next authorized upgrade, if there is one."
              ]
            },
            {
              "name": "CustomValidationHeadData",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cU8\u003e",
                "PlainTypeValue": 10
              },
              "fallback": "0x00",
              "docs": [
                " A custom head data that should be returned as result of `validate_block`.",
                "",
                " See [`Pallet::set_custom_validation_head_data`] for more information."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "2000",
              "name": "set_validation_data",
              "docs": [
                "Set the current validation data.",
                "",
                "This should be invoked exactly once per block. It will panic at the finalization",
                "phase if the call was not invoked.",
                "",
                "The dispatch origin for this call must be `Inherent`",
                "",
                "As a side effect, this function upgrades the current validation function",
                "if the appropriate time has come."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "data",
                  "type": "cumulus_primitives_parachain_inherent:ParachainInherentData",
                  "type_name": "ParachainInherentData"
                }
              ]
            },
            {
              "lookup": "2001",
              "name": "sudo_send_upward_message",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "message",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "UpwardMessage"
                }
              ]
            },
            {
              "lookup": "2002",
              "name": "authorize_upgrade",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "code_hash",
                  "type": "H256",
                  "type_name": "Hash"
                }
              ]
            },
            {
              "lookup": "2003",
              "name": "enact_authorized_upgrade",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "code",
                  "type": "Vec\u003cU8\u003e",
                  "type_name": "Bytes"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 235
          },
          "events": [
            {
              "lookup": "2000",
              "name": "ValidationFunctionStored",
              "docs": [
                "The validation function has been scheduled to apply."
              ],
              "args": null
            },
            {
              "lookup": "2001",
              "name": "ValidationFunctionApplied",
              "docs": [
                "The validation function was applied as of the contained relay chain block number."
              ],
              "args": [
                "U32"
              ],
              "args_type_name": [
                "RelayChainBlockNumber"
              ]
            },
            {
              "lookup": "2002",
              "name": "ValidationFunctionDiscarded",
              "docs": [
                "The relay-chain aborted the upgrade process."
              ],
              "args": null
            },
            {
              "lookup": "2003",
              "name": "UpgradeAuthorized",
              "docs": [
                "An upgrade has been authorized."
              ],
              "args": [
                "H256"
              ],
              "args_type_name": [
                "Hash"
              ]
            },
            {
              "lookup": "2004",
              "name": "DownwardMessagesReceived",
              "docs": [
                "Some downward messages have been received and will be processed.",
                "\\[ count \\]"
              ],
              "args": [
                "U32"
              ],
              "args_type_name": [
                "u32"
              ]
            },
            {
              "lookup": "2005",
              "name": "DownwardMessagesProcessed",
              "docs": [
                "Downward messages were processed using the given weight.",
                "\\[ weight_used, result_mqc_head \\]"
              ],
              "args": [
                "U64",
                "H256"
              ],
              "args_type_name": [
                "Weight",
                "relay_chain::Hash"
              ]
            }
          ],
          "events_value": {
            "type": 87
          },
          "errors": [
            {
              "name": "OverlappingUpgrades",
              "doc": [
                "Attempt to upgrade validation function while existing upgrade pending"
              ]
            },
            {
              "name": "ProhibitedByPolkadot",
              "doc": [
                "Polkadot currently prohibits this parachain from upgrading its validation function"
              ]
            },
            {
              "name": "TooBig",
              "doc": [
                "The supplied validation function has compiled into a blob larger than Polkadot is",
                "willing to run"
              ]
            },
            {
              "name": "ValidationDataNotAvailable",
              "doc": [
                "The inherent which supplies the validation data did not run this block"
              ]
            },
            {
              "name": "HostConfigurationNotAvailable",
              "doc": [
                "The inherent which supplies the host configuration did not run this block"
              ]
            },
            {
              "name": "NotScheduled",
              "doc": [
                "No validation function upgrade is currently scheduled."
              ]
            },
            {
              "name": "NothingAuthorized",
              "doc": [
                "No code upgrade has been authorized."
              ]
            },
            {
              "name": "Unauthorized",
              "doc": [
                "The given code upgrade has not been authorized."
              ]
            }
          ],
          "errors_value": {
            "type": 420
          },
          "index": 32
        },
        {
          "name": "ParachainInfo",
          "prefix": "ParachainInfo",
          "storage": [
            {
              "name": "ParachainId",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 91
              },
              "fallback": "0x64000000",
              "docs": null
            }
          ],
          "errors": null,
          "errors_value": null,
          "index": 33
        },
        {
          "name": "Authorship",
          "prefix": "Authorship",
          "storage": [
            {
              "name": "Uncles",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cpallet_authorship:UncleEntryItem\u003e",
                "PlainTypeValue": 421
              },
              "fallback": "0x00",
              "docs": [
                " Uncles"
              ]
            },
            {
              "name": "Author",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "[U8; 32]",
                "PlainTypeValue": 0
              },
              "fallback": "0x00",
              "docs": [
                " Author of current block."
              ]
            },
            {
              "name": "DidSetUncles",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Bool",
                "PlainTypeValue": 68
              },
              "fallback": "0x00",
              "docs": [
                " Whether uncles were already set in this block."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "2200",
              "name": "set_uncles",
              "docs": [
                "Provide a set of uncles."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "new_uncles",
                  "type": "Vec\u003csp_runtime:generic:header:Header\u003e",
                  "type_name": "Vec\u003cHeader\u003e"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 248
          },
          "constants": [
            {
              "name": "UncleGenerations",
              "type": "U32",
              "type_value": 4,
              "constants_value": "00000000",
              "docs": [
                " The number of blocks back we should accept uncles.",
                " This means that we will deal with uncle-parents that are",
                " `UncleGenerations + 1` before `now`."
              ]
            }
          ],
          "errors": [
            {
              "name": "InvalidUncleParent",
              "doc": [
                "The uncle parent not in the chain."
              ]
            },
            {
              "name": "UnclesAlreadySet",
              "doc": [
                "Uncles already set in the block."
              ]
            },
            {
              "name": "TooManyUncles",
              "doc": [
                "Too many uncles."
              ]
            },
            {
              "name": "GenesisUncle",
              "doc": [
                "The uncle is genesis."
              ]
            },
            {
              "name": "TooHighUncle",
              "doc": [
                "The uncle is too high in chain."
              ]
            },
            {
              "name": "UncleAlreadyIncluded",
              "doc": [
                "The uncle is already included."
              ]
            },
            {
              "name": "OldUncle",
              "doc": [
                "The uncle isn't recent enough to be included."
              ]
            }
          ],
          "errors_value": {
            "type": 423
          },
          "index": 34
        },
        {
          "name": "Aura",
          "prefix": "Aura",
          "storage": [
            {
              "name": "Authorities",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003csp_consensus_aura:sr25519:app_sr25519:Public\u003e",
                "PlainTypeValue": 424
              },
              "fallback": "0x00",
              "docs": [
                " The current authority set."
              ]
            },
            {
              "name": "CurrentSlot",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U64",
                "PlainTypeValue": 428
              },
              "fallback": "0x0000000000000000",
              "docs": [
                " The current slot of this block.",
                "",
                " This will be set in `on_initialize`."
              ]
            }
          ],
          "errors": null,
          "errors_value": null,
          "index": 35
        },
        {
          "name": "AuraExt",
          "prefix": "AuraExt",
          "storage": [
            {
              "name": "Authorities",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003csp_consensus_aura:sr25519:app_sr25519:Public\u003e",
                "PlainTypeValue": 427
              },
              "fallback": "0x00",
              "docs": [
                " Serves as cache for the authorities.",
                "",
                " The authorities in AuRa are overwritten in `on_initialize` when we switch to a new session,",
                " but we require the old authorities to verify the seal when validating a PoV. This will always",
                " be updated to the latest AuRa authorities in `on_finalize`."
              ]
            }
          ],
          "errors": null,
          "errors_value": null,
          "index": 36
        },
        {
          "name": "XcmpQueue",
          "prefix": "XcmpQueue",
          "storage": [
            {
              "name": "InboundXcmpStatus",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003ccumulus_pallet_xcmp_queue:InboundChannelDetails\u003e",
                "PlainTypeValue": 429
              },
              "fallback": "0x00",
              "docs": [
                " Status of the inbound XCMP channels."
              ]
            },
            {
              "name": "InboundXcmpMessages",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "U32",
                    "U32"
                  ],
                  "value": "Vec\u003cU8\u003e",
                  "keys_id": 435,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Inbound aggregate XCMP messages. It can only be one per ParaId/block."
              ]
            },
            {
              "name": "OutboundXcmpStatus",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003ccumulus_pallet_xcmp_queue:OutboundChannelDetails\u003e",
                "PlainTypeValue": 436
              },
              "fallback": "0x00",
              "docs": [
                " The non-empty XCMP channels in order of becoming non-empty, and the index of the first",
                " and last outbound message. If the two indices are equal, then it indicates an empty",
                " queue and there must be a non-`Ok` `OutboundStatus`. We assume queues grow no greater",
                " than 65535 items. Queue indices for normal messages begin at one; zero is reserved in",
                " case of the need to send a high-priority signal message this block.",
                " The bool is true if there is a signal message waiting to be sent."
              ]
            },
            {
              "name": "OutboundXcmpMessages",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "U32",
                    "U16"
                  ],
                  "value": "Vec\u003cU8\u003e",
                  "keys_id": 439,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " The messages outbound in a given XCMP channel."
              ]
            },
            {
              "name": "SignalMessages",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32"
                  ],
                  "value": "Vec\u003cU8\u003e",
                  "keys_id": 91,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " Any signal messages waiting to be sent."
              ]
            },
            {
              "name": "QueueConfig",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "cumulus_pallet_xcmp_queue:QueueConfigData",
                "PlainTypeValue": 440
              },
              "fallback": "0x020000000500000001000000a086010000000000020000000000000000c817a804000000",
              "docs": [
                " The configuration which controls the dynamics of the outbound queue."
              ]
            },
            {
              "name": "Overweight",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat"
                  ],
                  "key_vec": [
                    "U64"
                  ],
                  "value": "Tuple:U32U32Vec\u003cU8\u003e",
                  "keys_id": 8,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " The messages that exceeded max individual message weight budget.",
                "",
                " These message stay in this storage map until they are manually dispatched via",
                " `service_overweight`."
              ]
            },
            {
              "name": "OverweightCount",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U64",
                "PlainTypeValue": 8
              },
              "fallback": "0x0000000000000000",
              "docs": [
                " The number of overweight messages ever recorded in `Overweight`. Also doubles as the next",
                " available free overweight index."
              ]
            },
            {
              "name": "QueueSuspended",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Bool",
                "PlainTypeValue": 68
              },
              "fallback": "0x00",
              "docs": [
                " Whether or not the XCMP queue is suspended from executing incoming XCMs or not."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "2500",
              "name": "service_overweight",
              "docs": [
                "Services a single overweight XCM.",
                "",
                "- `origin`: Must pass `ExecuteOverweightOrigin`.",
                "- `index`: The index of the overweight XCM to service",
                "- `weight_limit`: The amount of weight that XCM execution may take.",
                "",
                "Errors:",
                "- `BadOverweightIndex`: XCM under `index` is not found in the `Overweight` storage map.",
                "- `BadXcm`: XCM under `index` cannot be properly decoded into a valid XCM format.",
                "- `WeightOverLimit`: XCM execution may use greater `weight_limit`.",
                "",
                "Events:",
                "- `OverweightServiced`: On success."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "U64",
                  "type_name": "OverweightIndex"
                },
                {
                  "TypeName": "",
                  "name": "weight_limit",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            },
            {
              "lookup": "2501",
              "name": "suspend_xcm_execution",
              "docs": [
                "Suspends all XCM executions for the XCMP queue, regardless of the sender's origin.",
                "",
                "- `origin`: Must pass `ControllerOrigin`."
              ],
              "args": null
            },
            {
              "lookup": "2502",
              "name": "resume_xcm_execution",
              "docs": [
                "Resumes all XCM executions for the XCMP queue.",
                "",
                "Note that this function doesn't change the status of the in/out bound channels.",
                "",
                "- `origin`: Must pass `ControllerOrigin`."
              ],
              "args": null
            },
            {
              "lookup": "2503",
              "name": "update_suspend_threshold",
              "docs": [
                "Overwrites the number of pages of messages which must be in the queue for the other side to be told to",
                "suspend their sending.",
                "",
                "- `origin`: Must pass `Root`.",
                "- `new`: Desired value for `QueueConfigData.suspend_value`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "new",
                  "type": "U32",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "2504",
              "name": "update_drop_threshold",
              "docs": [
                "Overwrites the number of pages of messages which must be in the queue after which we drop any further",
                "messages from the channel.",
                "",
                "- `origin`: Must pass `Root`.",
                "- `new`: Desired value for `QueueConfigData.drop_threshold`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "new",
                  "type": "U32",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "2505",
              "name": "update_resume_threshold",
              "docs": [
                "Overwrites the number of pages of messages which the queue must be reduced to before it signals that",
                "message sending may recommence after it has been suspended.",
                "",
                "- `origin`: Must pass `Root`.",
                "- `new`: Desired value for `QueueConfigData.resume_threshold`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "new",
                  "type": "U32",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "2506",
              "name": "update_threshold_weight",
              "docs": [
                "Overwrites the amount of remaining weight under which we stop processing messages.",
                "",
                "- `origin`: Must pass `Root`.",
                "- `new`: Desired value for `QueueConfigData.threshold_weight`"
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "new",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            },
            {
              "lookup": "2507",
              "name": "update_weight_restrict_decay",
              "docs": [
                "Overwrites the speed to which the available weight approaches the maximum weight.",
                "A lower number results in a faster progression. A value of 1 makes the entire weight available initially.",
                "",
                "- `origin`: Must pass `Root`.",
                "- `new`: Desired value for `QueueConfigData.weight_restrict_decay`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "new",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            },
            {
              "lookup": "2508",
              "name": "update_xcmp_max_individual_weight",
              "docs": [
                "Overwrite the maximum amount of weight any individual message may consume.",
                "Messages above this weight go into the overweight queue and may only be serviced explicitly.",
                "",
                "- `origin`: Must pass `Root`.",
                "- `new`: Desired value for `QueueConfigData.xcmp_max_individual_weight`."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "new",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 252
          },
          "events": [
            {
              "lookup": "2500",
              "name": "Success",
              "docs": [
                "Some XCM was executed ok."
              ],
              "args": [
                "option\u003cH256\u003e"
              ],
              "args_type_name": [
                "Option\u003cHash\u003e"
              ]
            },
            {
              "lookup": "2501",
              "name": "Fail",
              "docs": [
                "Some XCM failed."
              ],
              "args": [
                "option\u003cH256\u003e",
                "xcm:v2:traits:Error"
              ],
              "args_type_name": [
                "Option\u003cHash\u003e",
                "XcmError"
              ]
            },
            {
              "lookup": "2502",
              "name": "BadVersion",
              "docs": [
                "Bad XCM version used."
              ],
              "args": [
                "option\u003cH256\u003e"
              ],
              "args_type_name": [
                "Option\u003cHash\u003e"
              ]
            },
            {
              "lookup": "2503",
              "name": "BadFormat",
              "docs": [
                "Bad XCM format used."
              ],
              "args": [
                "option\u003cH256\u003e"
              ],
              "args_type_name": [
                "Option\u003cHash\u003e"
              ]
            },
            {
              "lookup": "2504",
              "name": "UpwardMessageSent",
              "docs": [
                "An upward message was sent to the relay chain."
              ],
              "args": [
                "option\u003cH256\u003e"
              ],
              "args_type_name": [
                "Option\u003cHash\u003e"
              ]
            },
            {
              "lookup": "2505",
              "name": "XcmpMessageSent",
              "docs": [
                "An HRMP message was sent to a sibling parachain."
              ],
              "args": [
                "option\u003cH256\u003e"
              ],
              "args_type_name": [
                "Option\u003cHash\u003e"
              ]
            },
            {
              "lookup": "2506",
              "name": "OverweightEnqueued",
              "docs": [
                "An XCM exceeded the individual message weight budget."
              ],
              "args": [
                "U32",
                "U32",
                "U64",
                "U64"
              ],
              "args_type_name": [
                "ParaId",
                "RelayBlockNumber",
                "OverweightIndex",
                "Weight"
              ]
            },
            {
              "lookup": "2507",
              "name": "OverweightServiced",
              "docs": [
                "An XCM from the overweight queue was executed with the given actual weight used."
              ],
              "args": [
                "U64",
                "U64"
              ],
              "args_type_name": [
                "OverweightIndex",
                "Weight"
              ]
            }
          ],
          "events_value": {
            "type": 88
          },
          "errors": [
            {
              "name": "FailedToSend",
              "doc": [
                "Failed to send XCM message."
              ]
            },
            {
              "name": "BadXcmOrigin",
              "doc": [
                "Bad XCM origin."
              ]
            },
            {
              "name": "BadXcm",
              "doc": [
                "Bad XCM data."
              ]
            },
            {
              "name": "BadOverweightIndex",
              "doc": [
                "Bad overweight index."
              ]
            },
            {
              "name": "WeightOverLimit",
              "doc": [
                "Provided weight is possibly not enough to execute the message."
              ]
            }
          ],
          "errors_value": {
            "type": 442
          },
          "index": 37
        },
        {
          "name": "PolkadotXcm",
          "prefix": "PolkadotXcm",
          "storage": [
            {
              "name": "QueryCounter",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U64",
                "PlainTypeValue": 8
              },
              "fallback": "0x0000000000000000",
              "docs": [
                " The latest available query index."
              ]
            },
            {
              "name": "Queries",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U64"
                  ],
                  "value": "pallet_xcm:pallet:QueryStatus",
                  "keys_id": 8,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " The ongoing queries."
              ]
            },
            {
              "name": "AssetTraps",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Identity"
                  ],
                  "key_vec": [
                    "H256"
                  ],
                  "value": "U32",
                  "keys_id": 9,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000",
              "docs": [
                " The existing asset traps.",
                "",
                " Key is the blake2 256 hash of (origin, versioned `MultiAssets`) pair. Value is the number of",
                " times this pair has been trapped (usually just 1 if it exists at all)."
              ]
            },
            {
              "name": "SafeXcmVersion",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "U32",
                "PlainTypeValue": 4
              },
              "fallback": "0x00",
              "docs": [
                " Default version to encode XCM when latest version of destination is unknown. If `None`,",
                " then the destinations whose XCM version is unknown are considered unreachable."
              ]
            },
            {
              "name": "SupportedVersion",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32",
                    "xcm:VersionedMultiLocation"
                  ],
                  "value": "U32",
                  "keys_id": 447,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " The Latest versions that we know various locations support."
              ]
            },
            {
              "name": "VersionNotifiers",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32",
                    "xcm:VersionedMultiLocation"
                  ],
                  "value": "U64",
                  "keys_id": 447,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " All locations that we have requested version notifications from."
              ]
            },
            {
              "name": "VersionNotifyTargets",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Twox64Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32",
                    "xcm:VersionedMultiLocation"
                  ],
                  "value": "Tuple:U64U64U32",
                  "keys_id": 447,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " The target locations that are subscribed to our version changes, as well as the most recent",
                " of our versions we informed them of."
              ]
            },
            {
              "name": "VersionDiscoveryQueue",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "Vec\u003cTuple:xcm:VersionedMultiLocationU32\u003e",
                "PlainTypeValue": 449
              },
              "fallback": "0x00",
              "docs": [
                " Destinations whose latest XCM version we would like to know. Duplicates not allowed, and",
                " the `u32` counter is the number of times that a send to the destination has been attempted,",
                " which is used as a prioritization."
              ]
            },
            {
              "name": "CurrentMigration",
              "modifier": "Optional",
              "type": {
                "origin": "PlainType",
                "plain_type": "pallet_xcm:pallet:VersionMigrationStage",
                "PlainTypeValue": 452
              },
              "fallback": "0x00",
              "docs": [
                " The current migration's stage, if any."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "2600",
              "name": "send",
              "docs": null,
              "args": [
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "message",
                  "type": "xcm:VersionedXcm",
                  "type_name": "Box\u003cVersionedXcm\u003c()\u003e\u003e"
                }
              ]
            },
            {
              "lookup": "2601",
              "name": "teleport_assets",
              "docs": [
                "Teleport some assets from the local chain to some destination chain.",
                "",
                "Fee payment on the destination side is made from the first asset listed in the `assets` vector and",
                "fee-weight is calculated locally and thus remote weights are assumed to be equal to",
                "local weights.",
                "",
                "- `origin`: Must be capable of withdrawing the `assets` and executing XCM.",
                "- `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send",
                "  from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.",
                "- `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be",
                "  an `AccountId32` value.",
                "- `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the",
                "  `dest` side. May not be empty.",
                "- `fee_asset_item`: The index into `assets` of the item which should be used to pay",
                "  fees."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "beneficiary",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "assets",
                  "type": "xcm:VersionedMultiAssets",
                  "type_name": "Box\u003cVersionedMultiAssets\u003e"
                },
                {
                  "TypeName": "",
                  "name": "fee_asset_item",
                  "type": "U32",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "2602",
              "name": "reserve_transfer_assets",
              "docs": [
                "Transfer some assets from the local chain to the sovereign account of a destination chain and forward",
                "a notification XCM.",
                "",
                "Fee payment on the destination side is made from the first asset listed in the `assets` vector and",
                "fee-weight is calculated locally and thus remote weights are assumed to be equal to",
                "local weights.",
                "",
                "- `origin`: Must be capable of withdrawing the `assets` and executing XCM.",
                "- `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send",
                "  from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.",
                "- `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be",
                "  an `AccountId32` value.",
                "- `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the",
                "  `dest` side.",
                "- `fee_asset_item`: The index into `assets` of the item which should be used to pay",
                "  fees."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "beneficiary",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "assets",
                  "type": "xcm:VersionedMultiAssets",
                  "type_name": "Box\u003cVersionedMultiAssets\u003e"
                },
                {
                  "TypeName": "",
                  "name": "fee_asset_item",
                  "type": "U32",
                  "type_name": "u32"
                }
              ]
            },
            {
              "lookup": "2603",
              "name": "execute",
              "docs": [
                "Execute an XCM message from a local, signed, origin.",
                "",
                "An event is deposited indicating whether `msg` could be executed completely or only",
                "partially.",
                "",
                "No more than `max_weight` will be used in its attempted execution. If this is less than the",
                "maximum amount of weight that the message could take to be executed, then no execution",
                "attempt will be made.",
                "",
                "NOTE: A successful return to this does *not* imply that the `msg` was executed successfully",
                "to completion; only that *some* of it was executed."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "message",
                  "type": "xcm:VersionedXcm@265",
                  "type_name": "Box\u003cVersionedXcm\u003c\u003cT as SysConfig\u003e::Call\u003e\u003e"
                },
                {
                  "TypeName": "",
                  "name": "max_weight",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            },
            {
              "lookup": "2604",
              "name": "force_xcm_version",
              "docs": [
                "Extoll that a particular destination can be communicated with through a particular",
                "version of XCM.",
                "",
                "- `origin`: Must be Root.",
                "- `location`: The destination that is being described.",
                "- `xcm_version`: The latest version of XCM that `location` supports."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "location",
                  "type": "xcm:v1:multilocation:MultiLocation",
                  "type_name": "Box\u003cMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "xcm_version",
                  "type": "U32",
                  "type_name": "XcmVersion"
                }
              ]
            },
            {
              "lookup": "2605",
              "name": "force_default_xcm_version",
              "docs": [
                "Set a safe XCM version (the version that XCM should be encoded with if the most recent",
                "version a destination can accept is unknown).",
                "",
                "- `origin`: Must be Root.",
                "- `maybe_xcm_version`: The default XCM encoding version, or `None` to disable."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "maybe_xcm_version",
                  "type": "option\u003cU32\u003e",
                  "type_name": "Option\u003cXcmVersion\u003e"
                }
              ]
            },
            {
              "lookup": "2606",
              "name": "force_subscribe_version_notify",
              "docs": [
                "Ask a location to notify us regarding their XCM version and any changes to it.",
                "",
                "- `origin`: Must be Root.",
                "- `location`: The location to which we should subscribe for XCM version notifications."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "location",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                }
              ]
            },
            {
              "lookup": "2607",
              "name": "force_unsubscribe_version_notify",
              "docs": [
                "Require that a particular destination should no longer notify us regarding any XCM",
                "version changes.",
                "",
                "- `origin`: Must be Root.",
                "- `location`: The location to which we are currently subscribed for XCM version",
                "  notifications which we no longer desire."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "location",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                }
              ]
            },
            {
              "lookup": "2608",
              "name": "limited_reserve_transfer_assets",
              "docs": [
                "Transfer some assets from the local chain to the sovereign account of a destination chain and forward",
                "a notification XCM.",
                "",
                "Fee payment on the destination side is made from the first asset listed in the `assets` vector.",
                "",
                "- `origin`: Must be capable of withdrawing the `assets` and executing XCM.",
                "- `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send",
                "  from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.",
                "- `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be",
                "  an `AccountId32` value.",
                "- `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the",
                "  `dest` side.",
                "- `fee_asset_item`: The index into `assets` of the item which should be used to pay",
                "  fees.",
                "- `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "beneficiary",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "assets",
                  "type": "xcm:VersionedMultiAssets",
                  "type_name": "Box\u003cVersionedMultiAssets\u003e"
                },
                {
                  "TypeName": "",
                  "name": "fee_asset_item",
                  "type": "U32",
                  "type_name": "u32"
                },
                {
                  "TypeName": "",
                  "name": "weight_limit",
                  "type": "xcm:v2:WeightLimit",
                  "type_name": "WeightLimit"
                }
              ]
            },
            {
              "lookup": "2609",
              "name": "limited_teleport_assets",
              "docs": [
                "Teleport some assets from the local chain to some destination chain.",
                "",
                "Fee payment on the destination side is made from the first asset listed in the `assets` vector.",
                "",
                "- `origin`: Must be capable of withdrawing the `assets` and executing XCM.",
                "- `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send",
                "  from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.",
                "- `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be",
                "  an `AccountId32` value.",
                "- `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the",
                "  `dest` side. May not be empty.",
                "- `fee_asset_item`: The index into `assets` of the item which should be used to pay",
                "  fees.",
                "- `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "beneficiary",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "assets",
                  "type": "xcm:VersionedMultiAssets",
                  "type_name": "Box\u003cVersionedMultiAssets\u003e"
                },
                {
                  "TypeName": "",
                  "name": "fee_asset_item",
                  "type": "U32",
                  "type_name": "u32"
                },
                {
                  "TypeName": "",
                  "name": "weight_limit",
                  "type": "xcm:v2:WeightLimit",
                  "type_name": "WeightLimit"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 253
          },
          "events": [
            {
              "lookup": "2600",
              "name": "Attempted",
              "docs": [
                "Execution of an XCM message was attempted.",
                "",
                "\\[ outcome \\]"
              ],
              "args": [
                "xcm:v2:traits:Outcome"
              ],
              "args_type_name": [
                "xcm::latest::Outcome"
              ]
            },
            {
              "lookup": "2601",
              "name": "Sent",
              "docs": [
                "A XCM message was sent.",
                "",
                "\\[ origin, destination, message \\]"
              ],
              "args": [
                "xcm:v1:multilocation:MultiLocation",
                "xcm:v1:multilocation:MultiLocation",
                "Vec\u003cxcm:v2:Instruction\u003e"
              ],
              "args_type_name": [
                "MultiLocation",
                "MultiLocation",
                "Xcm\u003c()\u003e"
              ]
            },
            {
              "lookup": "2602",
              "name": "UnexpectedResponse",
              "docs": [
                "Query response received which does not match a registered query. This may be because a",
                "matching query was never registered, it may be because it is a duplicate response, or",
                "because the query timed out.",
                "",
                "\\[ origin location, id \\]"
              ],
              "args": [
                "xcm:v1:multilocation:MultiLocation",
                "U64"
              ],
              "args_type_name": [
                "MultiLocation",
                "QueryId"
              ]
            },
            {
              "lookup": "2603",
              "name": "ResponseReady",
              "docs": [
                "Query response has been received and is ready for taking with `take_response`. There is",
                "no registered notification call.",
                "",
                "\\[ id, response \\]"
              ],
              "args": [
                "U64",
                "xcm:v2:Response"
              ],
              "args_type_name": [
                "QueryId",
                "Response"
              ]
            },
            {
              "lookup": "2604",
              "name": "Notified",
              "docs": [
                "Query response has been received and query is removed. The registered notification has",
                "been dispatched and executed successfully.",
                "",
                "\\[ id, pallet index, call index \\]"
              ],
              "args": [
                "U64",
                "U8",
                "U8"
              ],
              "args_type_name": [
                "QueryId",
                "u8",
                "u8"
              ]
            },
            {
              "lookup": "2605",
              "name": "NotifyOverweight",
              "docs": [
                "Query response has been received and query is removed. The registered notification could",
                "not be dispatched because the dispatch weight is greater than the maximum weight",
                "originally budgeted by this runtime for the query result.",
                "",
                "\\[ id, pallet index, call index, actual weight, max budgeted weight \\]"
              ],
              "args": [
                "U64",
                "U8",
                "U8",
                "U64",
                "U64"
              ],
              "args_type_name": [
                "QueryId",
                "u8",
                "u8",
                "Weight",
                "Weight"
              ]
            },
            {
              "lookup": "2606",
              "name": "NotifyDispatchError",
              "docs": [
                "Query response has been received and query is removed. There was a general error with",
                "dispatching the notification call.",
                "",
                "\\[ id, pallet index, call index \\]"
              ],
              "args": [
                "U64",
                "U8",
                "U8"
              ],
              "args_type_name": [
                "QueryId",
                "u8",
                "u8"
              ]
            },
            {
              "lookup": "2607",
              "name": "NotifyDecodeFailed",
              "docs": [
                "Query response has been received and query is removed. The dispatch was unable to be",
                "decoded into a `Call`; this might be due to dispatch function having a signature which",
                "is not `(origin, QueryId, Response)`.",
                "",
                "\\[ id, pallet index, call index \\]"
              ],
              "args": [
                "U64",
                "U8",
                "U8"
              ],
              "args_type_name": [
                "QueryId",
                "u8",
                "u8"
              ]
            },
            {
              "lookup": "2608",
              "name": "InvalidResponder",
              "docs": [
                "Expected query response has been received but the origin location of the response does",
                "not match that expected. The query remains registered for a later, valid, response to",
                "be received and acted upon.",
                "",
                "\\[ origin location, id, expected location \\]"
              ],
              "args": [
                "xcm:v1:multilocation:MultiLocation",
                "U64",
                "option\u003cxcm:v1:multilocation:MultiLocation\u003e"
              ],
              "args_type_name": [
                "MultiLocation",
                "QueryId",
                "Option\u003cMultiLocation\u003e"
              ]
            },
            {
              "lookup": "2609",
              "name": "InvalidResponderVersion",
              "docs": [
                "Expected query response has been received but the expected origin location placed in",
                "storage by this runtime previously cannot be decoded. The query remains registered.",
                "",
                "This is unexpected (since a location placed in storage in a previously executing",
                "runtime should be readable prior to query timeout) and dangerous since the possibly",
                "valid response will be dropped. Manual governance intervention is probably going to be",
                "needed.",
                "",
                "\\[ origin location, id \\]"
              ],
              "args": [
                "xcm:v1:multilocation:MultiLocation",
                "U64"
              ],
              "args_type_name": [
                "MultiLocation",
                "QueryId"
              ]
            },
            {
              "lookup": "260a",
              "name": "ResponseTaken",
              "docs": [
                "Received query response has been read and removed.",
                "",
                "\\[ id \\]"
              ],
              "args": [
                "U64"
              ],
              "args_type_name": [
                "QueryId"
              ]
            },
            {
              "lookup": "260b",
              "name": "AssetsTrapped",
              "docs": [
                "Some assets have been placed in an asset trap.",
                "",
                "\\[ hash, origin, assets \\]"
              ],
              "args": [
                "H256",
                "xcm:v1:multilocation:MultiLocation",
                "xcm:VersionedMultiAssets"
              ],
              "args_type_name": [
                "H256",
                "MultiLocation",
                "VersionedMultiAssets"
              ]
            },
            {
              "lookup": "260c",
              "name": "VersionChangeNotified",
              "docs": [
                "An XCM version change notification message has been attempted to be sent.",
                "",
                "\\[ destination, result \\]"
              ],
              "args": [
                "xcm:v1:multilocation:MultiLocation",
                "U32"
              ],
              "args_type_name": [
                "MultiLocation",
                "XcmVersion"
              ]
            },
            {
              "lookup": "260d",
              "name": "SupportedVersionChanged",
              "docs": [
                "The supported version of a location has been changed. This might be through an",
                "automatic notification or a manual intervention.",
                "",
                "\\[ location, XCM version \\]"
              ],
              "args": [
                "xcm:v1:multilocation:MultiLocation",
                "U32"
              ],
              "args_type_name": [
                "MultiLocation",
                "XcmVersion"
              ]
            },
            {
              "lookup": "260e",
              "name": "NotifyTargetSendFail",
              "docs": [
                "A given location which had a version change subscription was dropped owing to an error",
                "sending the notification to it.",
                "",
                "\\[ location, query ID, error \\]"
              ],
              "args": [
                "xcm:v1:multilocation:MultiLocation",
                "U64",
                "xcm:v2:traits:Error"
              ],
              "args_type_name": [
                "MultiLocation",
                "QueryId",
                "XcmError"
              ]
            },
            {
              "lookup": "260f",
              "name": "NotifyTargetMigrationFail",
              "docs": [
                "A given location which had a version change subscription was dropped owing to an error",
                "migrating the location to our new XCM format.",
                "",
                "\\[ location, query ID \\]"
              ],
              "args": [
                "xcm:VersionedMultiLocation",
                "U64"
              ],
              "args_type_name": [
                "VersionedMultiLocation",
                "QueryId"
              ]
            }
          ],
          "events_value": {
            "type": 92
          },
          "errors": [
            {
              "name": "Unreachable",
              "doc": [
                "The desired destination was unreachable, generally because there is a no way of routing",
                "to it."
              ]
            },
            {
              "name": "SendFailure",
              "doc": [
                "There was some other issue (i.e. not to do with routing) in sending the message. Perhaps",
                "a lack of space for buffering the message."
              ]
            },
            {
              "name": "Filtered",
              "doc": [
                "The message execution fails the filter."
              ]
            },
            {
              "name": "UnweighableMessage",
              "doc": [
                "The message's weight could not be determined."
              ]
            },
            {
              "name": "DestinationNotInvertible",
              "doc": [
                "The destination `MultiLocation` provided cannot be inverted."
              ]
            },
            {
              "name": "Empty",
              "doc": [
                "The assets to be sent are empty."
              ]
            },
            {
              "name": "CannotReanchor",
              "doc": [
                "Could not re-anchor the assets to declare the fees for the destination chain."
              ]
            },
            {
              "name": "TooManyAssets",
              "doc": [
                "Too many assets have been attempted for transfer."
              ]
            },
            {
              "name": "InvalidOrigin",
              "doc": [
                "Origin is invalid for sending."
              ]
            },
            {
              "name": "BadVersion",
              "doc": [
                "The version of the `Versioned` value used is not able to be interpreted."
              ]
            },
            {
              "name": "BadLocation",
              "doc": [
                "The given location could not be used (e.g. because it cannot be expressed in the",
                "desired version of XCM)."
              ]
            },
            {
              "name": "NoSubscription",
              "doc": [
                "The referenced subscription could not be found."
              ]
            },
            {
              "name": "AlreadySubscribed",
              "doc": [
                "The location is invalid since it already has a subscription from us."
              ]
            }
          ],
          "errors_value": {
            "type": 453
          },
          "index": 38
        },
        {
          "name": "CumulusXcm",
          "prefix": "",
          "storage": null,
          "calls_value": {
            "type": 278
          },
          "events": [
            {
              "lookup": "2700",
              "name": "InvalidFormat",
              "docs": [
                "Downward message is invalid XCM.",
                "\\[ id \\]"
              ],
              "args": [
                "[U8; 8]"
              ],
              "args_type_name": [
                "[u8; 8]"
              ]
            },
            {
              "lookup": "2701",
              "name": "UnsupportedVersion",
              "docs": [
                "Downward message is unsupported version of XCM.",
                "\\[ id \\]"
              ],
              "args": [
                "[U8; 8]"
              ],
              "args_type_name": [
                "[u8; 8]"
              ]
            },
            {
              "lookup": "2702",
              "name": "ExecutedDownward",
              "docs": [
                "Downward message executed with the given outcome.",
                "\\[ id, outcome \\]"
              ],
              "args": [
                "[U8; 8]",
                "xcm:v2:traits:Outcome"
              ],
              "args_type_name": [
                "[u8; 8]",
                "Outcome"
              ]
            }
          ],
          "events_value": {
            "type": 129
          },
          "errors": null,
          "errors_value": {
            "type": 454
          },
          "index": 39
        },
        {
          "name": "DmpQueue",
          "prefix": "DmpQueue",
          "storage": [
            {
              "name": "Configuration",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "U64",
                "PlainTypeValue": 455
              },
              "fallback": "0x00e40b5402000000",
              "docs": [
                " The configuration."
              ]
            },
            {
              "name": "PageIndex",
              "modifier": "Default",
              "type": {
                "origin": "PlainType",
                "plain_type": "cumulus_pallet_dmp_queue:PageIndexData",
                "PlainTypeValue": 456
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " The page index."
              ]
            },
            {
              "name": "Pages",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U32"
                  ],
                  "value": "Vec\u003cTuple:U32Vec\u003cU8\u003e\u003e",
                  "keys_id": 4,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " The queue pages."
              ]
            },
            {
              "name": "Overweight",
              "modifier": "Optional",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "U64"
                  ],
                  "value": "Tuple:U32Vec\u003cU8\u003e",
                  "keys_id": 8,
                  "value_id": 0
                }
              },
              "fallback": "0x00",
              "docs": [
                " The overweight messages."
              ]
            }
          ],
          "calls": [
            {
              "lookup": "2800",
              "name": "service_overweight",
              "docs": [
                "Service a single overweight message.",
                "",
                "- `origin`: Must pass `ExecuteOverweightOrigin`.",
                "- `index`: The index of the overweight message to service.",
                "- `weight_limit`: The amount of weight that message execution may take.",
                "",
                "Errors:",
                "- `Unknown`: Message of `index` is unknown.",
                "- `OverLimit`: Message execution may use greater than `weight_limit`.",
                "",
                "Events:",
                "- `OverweightServiced`: On success."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "index",
                  "type": "U64",
                  "type_name": "OverweightIndex"
                },
                {
                  "TypeName": "",
                  "name": "weight_limit",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 279
          },
          "events": [
            {
              "lookup": "2800",
              "name": "InvalidFormat",
              "docs": [
                "Downward message is invalid XCM.",
                "\\[ id \\]"
              ],
              "args": [
                "[U8; 32]"
              ],
              "args_type_name": [
                "MessageId"
              ]
            },
            {
              "lookup": "2801",
              "name": "UnsupportedVersion",
              "docs": [
                "Downward message is unsupported version of XCM.",
                "\\[ id \\]"
              ],
              "args": [
                "[U8; 32]"
              ],
              "args_type_name": [
                "MessageId"
              ]
            },
            {
              "lookup": "2802",
              "name": "ExecutedDownward",
              "docs": [
                "Downward message executed with the given outcome.",
                "\\[ id, outcome \\]"
              ],
              "args": [
                "[U8; 32]",
                "xcm:v2:traits:Outcome"
              ],
              "args_type_name": [
                "MessageId",
                "Outcome"
              ]
            },
            {
              "lookup": "2803",
              "name": "WeightExhausted",
              "docs": [
                "The weight limit for handling downward messages was reached.",
                "\\[ id, remaining, required \\]"
              ],
              "args": [
                "[U8; 32]",
                "U64",
                "U64"
              ],
              "args_type_name": [
                "MessageId",
                "Weight",
                "Weight"
              ]
            },
            {
              "lookup": "2804",
              "name": "OverweightEnqueued",
              "docs": [
                "Downward message is overweight and was placed in the overweight queue.",
                "\\[ id, index, required \\]"
              ],
              "args": [
                "[U8; 32]",
                "U64",
                "U64"
              ],
              "args_type_name": [
                "MessageId",
                "OverweightIndex",
                "Weight"
              ]
            },
            {
              "lookup": "2805",
              "name": "OverweightServiced",
              "docs": [
                "Downward message from the overweight queue was executed.",
                "\\[ index, used \\]"
              ],
              "args": [
                "U64",
                "U64"
              ],
              "args_type_name": [
                "OverweightIndex",
                "Weight"
              ]
            }
          ],
          "events_value": {
            "type": 130
          },
          "errors": [
            {
              "name": "Unknown",
              "doc": [
                "The message index given is unknown."
              ]
            },
            {
              "name": "OverLimit",
              "doc": [
                "The amount of weight given is possibly not enough for executing the message."
              ]
            }
          ],
          "errors_value": {
            "type": 459
          },
          "index": 40
        },
        {
          "name": "XTokens",
          "prefix": "XTokens",
          "storage": null,
          "calls": [
            {
              "lookup": "2900",
              "name": "transfer",
              "docs": [
                "Transfer native currencies.",
                "",
                "`dest_weight` is the weight for XCM execution on the dest chain, and",
                "it would be charged from the transferred assets. If set below",
                "requirements, the execution may fail and assets wouldn't be",
                "received.",
                "",
                "It's a no-op if any error on local XCM execution or message sending.",
                "Note sending assets out per se doesn't guarantee they would be",
                "received. Receiving depends on if the XCM message could be delivered",
                "by the network, and if the receiving chain would handle",
                "messages correctly."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_id",
                  "type": "interbtc_primitives:CurrencyId",
                  "type_name": "CurrencyId"
                },
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "U128",
                  "type_name": "Balance"
                },
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "dest_weight",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            },
            {
              "lookup": "2901",
              "name": "transfer_multiasset",
              "docs": [
                "Transfer `MultiAsset`.",
                "",
                "`dest_weight` is the weight for XCM execution on the dest chain, and",
                "it would be charged from the transferred assets. If set below",
                "requirements, the execution may fail and assets wouldn't be",
                "received.",
                "",
                "It's a no-op if any error on local XCM execution or message sending.",
                "Note sending assets out per se doesn't guarantee they would be",
                "received. Receiving depends on if the XCM message could be delivered",
                "by the network, and if the receiving chain would handle",
                "messages correctly."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "asset",
                  "type": "xcm:VersionedMultiAsset",
                  "type_name": "Box\u003cVersionedMultiAsset\u003e"
                },
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "dest_weight",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            },
            {
              "lookup": "2902",
              "name": "transfer_with_fee",
              "docs": [
                "Transfer native currencies specifying the fee and amount as",
                "separate.",
                "",
                "`dest_weight` is the weight for XCM execution on the dest chain, and",
                "it would be charged from the transferred assets. If set below",
                "requirements, the execution may fail and assets wouldn't be",
                "received.",
                "",
                "`fee` is the amount to be spent to pay for execution in destination",
                "chain. Both fee and amount will be subtracted form the callers",
                "balance.",
                "",
                "If `fee` is not high enough to cover for the execution costs in the",
                "destination chain, then the assets will be trapped in the",
                "destination chain",
                "",
                "It's a no-op if any error on local XCM execution or message sending.",
                "Note sending assets out per se doesn't guarantee they would be",
                "received. Receiving depends on if the XCM message could be delivered",
                "by the network, and if the receiving chain would handle",
                "messages correctly."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currency_id",
                  "type": "interbtc_primitives:CurrencyId",
                  "type_name": "CurrencyId"
                },
                {
                  "TypeName": "",
                  "name": "amount",
                  "type": "U128",
                  "type_name": "Balance"
                },
                {
                  "TypeName": "",
                  "name": "fee",
                  "type": "U128",
                  "type_name": "Balance"
                },
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "dest_weight",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            },
            {
              "lookup": "2903",
              "name": "transfer_multiasset_with_fee",
              "docs": [
                "Transfer `MultiAsset` specifying the fee and amount as separate.",
                "",
                "`dest_weight` is the weight for XCM execution on the dest chain, and",
                "it would be charged from the transferred assets. If set below",
                "requirements, the execution may fail and assets wouldn't be",
                "received.",
                "",
                "`fee` is the multiasset to be spent to pay for execution in",
                "destination chain. Both fee and amount will be subtracted form the",
                "callers balance For now we only accept fee and asset having the same",
                "`MultiLocation` id.",
                "",
                "If `fee` is not high enough to cover for the execution costs in the",
                "destination chain, then the assets will be trapped in the",
                "destination chain",
                "",
                "It's a no-op if any error on local XCM execution or message sending.",
                "Note sending assets out per se doesn't guarantee they would be",
                "received. Receiving depends on if the XCM message could be delivered",
                "by the network, and if the receiving chain would handle",
                "messages correctly."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "asset",
                  "type": "xcm:VersionedMultiAsset",
                  "type_name": "Box\u003cVersionedMultiAsset\u003e"
                },
                {
                  "TypeName": "",
                  "name": "fee",
                  "type": "xcm:VersionedMultiAsset",
                  "type_name": "Box\u003cVersionedMultiAsset\u003e"
                },
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "dest_weight",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            },
            {
              "lookup": "2904",
              "name": "transfer_multicurrencies",
              "docs": [
                "Transfer several currencies specifying the item to be used as fee",
                "",
                "`dest_weight` is the weight for XCM execution on the dest chain, and",
                "it would be charged from the transferred assets. If set below",
                "requirements, the execution may fail and assets wouldn't be",
                "received.",
                "",
                "`fee_item` is index of the currencies tuple that we want to use for",
                "payment",
                "",
                "It's a no-op if any error on local XCM execution or message sending.",
                "Note sending assets out per se doesn't guarantee they would be",
                "received. Receiving depends on if the XCM message could be delivered",
                "by the network, and if the receiving chain would handle",
                "messages correctly."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "currencies",
                  "type": "Vec\u003cTuple:interbtc_primitives:CurrencyIdU128\u003e",
                  "type_name": "Vec\u003c(CurrencyId, Balance)\u003e"
                },
                {
                  "TypeName": "",
                  "name": "fee_item",
                  "type": "U32",
                  "type_name": "u32"
                },
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "dest_weight",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            },
            {
              "lookup": "2905",
              "name": "transfer_multiassets",
              "docs": [
                "Transfer several `MultiAsset` specifying the item to be used as fee",
                "",
                "`dest_weight` is the weight for XCM execution on the dest chain, and",
                "it would be charged from the transferred assets. If set below",
                "requirements, the execution may fail and assets wouldn't be",
                "received.",
                "",
                "`fee_item` is index of the MultiAssets that we want to use for",
                "payment",
                "",
                "It's a no-op if any error on local XCM execution or message sending.",
                "Note sending assets out per se doesn't guarantee they would be",
                "received. Receiving depends on if the XCM message could be delivered",
                "by the network, and if the receiving chain would handle",
                "messages correctly."
              ],
              "args": [
                {
                  "TypeName": "",
                  "name": "assets",
                  "type": "xcm:VersionedMultiAssets",
                  "type_name": "Box\u003cVersionedMultiAssets\u003e"
                },
                {
                  "TypeName": "",
                  "name": "fee_item",
                  "type": "U32",
                  "type_name": "u32"
                },
                {
                  "TypeName": "",
                  "name": "dest",
                  "type": "xcm:VersionedMultiLocation",
                  "type_name": "Box\u003cVersionedMultiLocation\u003e"
                },
                {
                  "TypeName": "",
                  "name": "dest_weight",
                  "type": "U64",
                  "type_name": "Weight"
                }
              ]
            }
          ],
          "calls_value": {
            "type": 280
          },
          "events": [
            {
              "lookup": "2900",
              "name": "TransferredMultiAssets",
              "docs": [
                "Transferred `MultiAsset` with fee."
              ],
              "args": [
                "[U8; 32]",
                "Vec\u003cxcm:v1:multiasset:MultiAsset\u003e",
                "xcm:v1:multiasset:MultiAsset",
                "xcm:v1:multilocation:MultiLocation"
              ],
              "args_type_name": [
                "AccountId",
                "MultiAssets",
                "MultiAsset",
                "MultiLocation"
              ]
            }
          ],
          "events_value": {
            "type": 131
          },
          "constants": [
            {
              "name": "SelfLocation",
              "type": "xcm:v1:multilocation:MultiLocation",
              "type_value": 94,
              "constants_value": "010100b120",
              "docs": [
                " Self chain location."
              ]
            },
            {
              "name": "BaseXcmWeight",
              "type": "U64",
              "type_value": 8,
              "constants_value": "00c2eb0b00000000",
              "docs": [
                " Base XCM weight.",
                "",
                " The actually weight for an XCM message is `T::BaseXcmWeight +",
                " T::Weigher::weight(\u0026msg)`."
              ]
            }
          ],
          "errors": [
            {
              "name": "AssetHasNoReserve",
              "doc": [
                "Asset has no reserve location."
              ]
            },
            {
              "name": "NotCrossChainTransfer",
              "doc": [
                "Not cross-chain transfer."
              ]
            },
            {
              "name": "InvalidDest",
              "doc": [
                "Invalid transfer destination."
              ]
            },
            {
              "name": "NotCrossChainTransferableCurrency",
              "doc": [
                "Currency is not cross-chain transferable."
              ]
            },
            {
              "name": "UnweighableMessage",
              "doc": [
                "The message's weight could not be determined."
              ]
            },
            {
              "name": "XcmExecutionFailed",
              "doc": [
                "XCM execution failed."
              ]
            },
            {
              "name": "CannotReanchor",
              "doc": [
                "Could not re-anchor the assets to declare the fees for the",
                "destination chain."
              ]
            },
            {
              "name": "InvalidAncestry",
              "doc": [
                "Could not get ancestry of asset reserve location."
              ]
            },
            {
              "name": "InvalidAsset",
              "doc": [
                "The MultiAsset is invalid."
              ]
            },
            {
              "name": "DestinationNotInvertible",
              "doc": [
                "The destination `MultiLocation` provided cannot be inverted."
              ]
            },
            {
              "name": "BadVersion",
              "doc": [
                "The version of the `Versioned` value used is not able to be",
                "interpreted."
              ]
            },
            {
              "name": "DistinctReserveForAssetAndFee",
              "doc": [
                "We tried sending distinct asset and fee but they have different",
                "reserve chains."
              ]
            },
            {
              "name": "ZeroFee",
              "doc": [
                "The fee is zero."
              ]
            },
            {
              "name": "ZeroAmount",
              "doc": [
                "The transfering asset amount is zero."
              ]
            },
            {
              "name": "TooManyAssetsBeingSent",
              "doc": [
                "The number of assets to be sent is over the maximum."
              ]
            },
            {
              "name": "AssetIndexNonExistent",
              "doc": [
                "The specified index does not exist in a MultiAssets struct."
              ]
            },
            {
              "name": "FeeNotEnough",
              "doc": [
                "Fee is not enough."
              ]
            },
            {
              "name": "NotSupportedMultiLocation",
              "doc": [
                "Not supported MultiLocation"
              ]
            }
          ],
          "errors_value": {
            "type": 460
          },
          "index": 41
        },
        {
          "name": "UnknownTokens",
          "prefix": "UnknownTokens",
          "storage": [
            {
              "name": "ConcreteFungibleBalances",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "xcm:v1:multilocation:MultiLocation",
                    "xcm:v1:multilocation:MultiLocation"
                  ],
                  "value": "U128",
                  "keys_id": 461,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Concrete fungible balances under a given location and a concrete",
                " fungible id.",
                "",
                " double_map: who, asset_id =\u003e u128"
              ]
            },
            {
              "name": "AbstractFungibleBalances",
              "modifier": "Default",
              "type": {
                "origin": "Map",
                "n_map_type": {
                  "hashers": [
                    "Blake2_128Concat",
                    "Blake2_128Concat"
                  ],
                  "key_vec": [
                    "xcm:v1:multilocation:MultiLocation",
                    "Vec\u003cU8\u003e"
                  ],
                  "value": "U128",
                  "keys_id": 462,
                  "value_id": 0
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "docs": [
                " Abstract fungible balances under a given location and a abstract",
                " fungible id.",
                "",
                " double_map: who, asset_id =\u003e u128"
              ]
            }
          ],
          "events": [
            {
              "lookup": "2a00",
              "name": "Deposited",
              "docs": [
                "Deposit success."
              ],
              "args": [
                "xcm:v1:multiasset:MultiAsset",
                "xcm:v1:multilocation:MultiLocation"
              ],
              "args_type_name": [
                "MultiAsset",
                "MultiLocation"
              ]
            },
            {
              "lookup": "2a01",
              "name": "Withdrawn",
              "docs": [
                "Withdraw success."
              ],
              "args": [
                "xcm:v1:multiasset:MultiAsset",
                "xcm:v1:multilocation:MultiLocation"
              ],
              "args_type_name": [
                "MultiAsset",
                "MultiLocation"
              ]
            }
          ],
          "events_value": {
            "type": 132
          },
          "errors": [
            {
              "name": "BalanceTooLow",
              "doc": [
                "The balance is too low."
              ]
            },
            {
              "name": "BalanceOverflow",
              "doc": [
                "The operation will cause balance to overflow."
              ]
            },
            {
              "name": "UnhandledAsset",
              "doc": [
                "Unhandled asset."
              ]
            }
          ],
          "errors_value": {
            "type": 463
          },
          "index": 42
        }
      ]
    }
  }
}