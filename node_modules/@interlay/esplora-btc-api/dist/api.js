"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Blockstream Esplora API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxApi = exports.TxApiFactory = exports.TxApiFp = exports.TxApiAxiosParamCreator = exports.ScripthashApi = exports.ScripthashApiFactory = exports.ScripthashApiFp = exports.ScripthashApiAxiosParamCreator = exports.MempoolApi = exports.MempoolApiFactory = exports.MempoolApiFp = exports.MempoolApiAxiosParamCreator = exports.FeeEstimatesApi = exports.FeeEstimatesApiFactory = exports.FeeEstimatesApiFp = exports.FeeEstimatesApiAxiosParamCreator = exports.BlockApi = exports.BlockApiFactory = exports.BlockApiFp = exports.BlockApiAxiosParamCreator = exports.AddressApi = exports.AddressApiFactory = exports.AddressApiFp = exports.AddressApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("./base");
/**
 * AddressApi - axios parameter creator
 * @export
 */
const AddressApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get information about an address.
         * @param {string} address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress: (address, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling getAddress.');
            }
            const localVarPath = `/address/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get transaction history for the specified address, sorted with newest first.
         * @param {string} address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressTxHistory: (address, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling getAddressTxHistory.');
            }
            const localVarPath = `/address/{address}/txs`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get unconfirmed transaction history for the specified address.
         * @param {string} address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressTxMempool: (address, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling getAddressTxMempool.');
            }
            const localVarPath = `/address/{address}/txs/mempool`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get the list of unspent transaction outputs associated with the address.
         * @param {string} address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressUtxo: (address, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling getAddressUtxo.');
            }
            const localVarPath = `/address/{address}/utxo`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AddressApiAxiosParamCreator = AddressApiAxiosParamCreator;
/**
 * AddressApi - functional programming interface
 * @export
 */
const AddressApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get information about an address.
         * @param {string} address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress(address, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AddressApiAxiosParamCreator(configuration).getAddress(address, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get transaction history for the specified address, sorted with newest first.
         * @param {string} address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressTxHistory(address, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AddressApiAxiosParamCreator(configuration).getAddressTxHistory(address, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get unconfirmed transaction history for the specified address.
         * @param {string} address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressTxMempool(address, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AddressApiAxiosParamCreator(configuration).getAddressTxMempool(address, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get the list of unspent transaction outputs associated with the address.
         * @param {string} address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressUtxo(address, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AddressApiAxiosParamCreator(configuration).getAddressUtxo(address, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
exports.AddressApiFp = AddressApiFp;
/**
 * AddressApi - factory interface
 * @export
 */
const AddressApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Get information about an address.
         * @param {string} address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress(address, options) {
            return exports.AddressApiFp(configuration).getAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get transaction history for the specified address, sorted with newest first.
         * @param {string} address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressTxHistory(address, options) {
            return exports.AddressApiFp(configuration).getAddressTxHistory(address, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get unconfirmed transaction history for the specified address.
         * @param {string} address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressTxMempool(address, options) {
            return exports.AddressApiFp(configuration).getAddressTxMempool(address, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the list of unspent transaction outputs associated with the address.
         * @param {string} address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressUtxo(address, options) {
            return exports.AddressApiFp(configuration).getAddressUtxo(address, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AddressApiFactory = AddressApiFactory;
/**
 * AddressApi - object-oriented interface
 * @export
 * @class AddressApi
 * @extends {BaseAPI}
 */
class AddressApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get information about an address.
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    getAddress(address, options) {
        return exports.AddressApiFp(this.configuration).getAddress(address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get transaction history for the specified address, sorted with newest first.
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    getAddressTxHistory(address, options) {
        return exports.AddressApiFp(this.configuration).getAddressTxHistory(address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get unconfirmed transaction history for the specified address.
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    getAddressTxMempool(address, options) {
        return exports.AddressApiFp(this.configuration).getAddressTxMempool(address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the list of unspent transaction outputs associated with the address.
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    getAddressUtxo(address, options) {
        return exports.AddressApiFp(this.configuration).getAddressUtxo(address, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AddressApi = AddressApi;
/**
 * BlockApi - axios parameter creator
 * @export
 */
const BlockApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns information about a block.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock: (hash, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new base_1.RequiredError('hash', 'Required parameter hash was null or undefined when calling getBlock.');
            }
            const localVarPath = `/block/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the hash of the block currently at height.
         * @param {number} height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockAtHeight: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new base_1.RequiredError('height', 'Required parameter height was null or undefined when calling getBlockAtHeight.');
            }
            const localVarPath = `/block-height/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the raw block representation in binary.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockRaw: (hash, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new base_1.RequiredError('hash', 'Required parameter hash was null or undefined when calling getBlockRaw.');
            }
            const localVarPath = `/block/{hash}/raw`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the block status.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockStatus: (hash, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new base_1.RequiredError('hash', 'Required parameter hash was null or undefined when calling getBlockStatus.');
            }
            const localVarPath = `/block/{hash}/status`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the transaction at index :index within the specified block.
         * @param {string} hash
         * @param {number} index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockTxByIndex: (hash, index, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new base_1.RequiredError('hash', 'Required parameter hash was null or undefined when calling getBlockTxByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new base_1.RequiredError('index', 'Required parameter index was null or undefined when calling getBlockTxByIndex.');
            }
            const localVarPath = `/block/{hash}/txid/{index}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a list of all txids in the block.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockTxids: (hash, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new base_1.RequiredError('hash', 'Required parameter hash was null or undefined when calling getBlockTxids.');
            }
            const localVarPath = `/block/{hash}/txids`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the hash of the last block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastBlockHash: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/blocks/tip/hash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the height of the last block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastBlockHeight: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/blocks/tip/height`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BlockApiAxiosParamCreator = BlockApiAxiosParamCreator;
/**
 * BlockApi - functional programming interface
 * @export
 */
const BlockApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Returns information about a block.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(hash, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlockApiAxiosParamCreator(configuration).getBlock(hash, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the hash of the block currently at height.
         * @param {number} height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockAtHeight(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlockApiAxiosParamCreator(configuration).getBlockAtHeight(height, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the raw block representation in binary.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockRaw(hash, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlockApiAxiosParamCreator(configuration).getBlockRaw(hash, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the block status.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockStatus(hash, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlockApiAxiosParamCreator(configuration).getBlockStatus(hash, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the transaction at index :index within the specified block.
         * @param {string} hash
         * @param {number} index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockTxByIndex(hash, index, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlockApiAxiosParamCreator(configuration).getBlockTxByIndex(hash, index, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a list of all txids in the block.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockTxids(hash, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlockApiAxiosParamCreator(configuration).getBlockTxids(hash, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the hash of the last block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastBlockHash(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlockApiAxiosParamCreator(configuration).getLastBlockHash(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the height of the last block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastBlockHeight(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlockApiAxiosParamCreator(configuration).getLastBlockHeight(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
exports.BlockApiFp = BlockApiFp;
/**
 * BlockApi - factory interface
 * @export
 */
const BlockApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Returns information about a block.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(hash, options) {
            return exports.BlockApiFp(configuration).getBlock(hash, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the hash of the block currently at height.
         * @param {number} height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockAtHeight(height, options) {
            return exports.BlockApiFp(configuration).getBlockAtHeight(height, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the raw block representation in binary.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockRaw(hash, options) {
            return exports.BlockApiFp(configuration).getBlockRaw(hash, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the block status.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockStatus(hash, options) {
            return exports.BlockApiFp(configuration).getBlockStatus(hash, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the transaction at index :index within the specified block.
         * @param {string} hash
         * @param {number} index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockTxByIndex(hash, index, options) {
            return exports.BlockApiFp(configuration).getBlockTxByIndex(hash, index, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a list of all txids in the block.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockTxids(hash, options) {
            return exports.BlockApiFp(configuration).getBlockTxids(hash, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the hash of the last block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastBlockHash(options) {
            return exports.BlockApiFp(configuration).getLastBlockHash(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the height of the last block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastBlockHeight(options) {
            return exports.BlockApiFp(configuration).getLastBlockHeight(options).then((request) => request(axios, basePath));
        },
    };
};
exports.BlockApiFactory = BlockApiFactory;
/**
 * BlockApi - object-oriented interface
 * @export
 * @class BlockApi
 * @extends {BaseAPI}
 */
class BlockApi extends base_1.BaseAPI {
    /**
     *
     * @summary Returns information about a block.
     * @param {string} hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    getBlock(hash, options) {
        return exports.BlockApiFp(this.configuration).getBlock(hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the hash of the block currently at height.
     * @param {number} height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    getBlockAtHeight(height, options) {
        return exports.BlockApiFp(this.configuration).getBlockAtHeight(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the raw block representation in binary.
     * @param {string} hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    getBlockRaw(hash, options) {
        return exports.BlockApiFp(this.configuration).getBlockRaw(hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the block status.
     * @param {string} hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    getBlockStatus(hash, options) {
        return exports.BlockApiFp(this.configuration).getBlockStatus(hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the transaction at index :index within the specified block.
     * @param {string} hash
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    getBlockTxByIndex(hash, index, options) {
        return exports.BlockApiFp(this.configuration).getBlockTxByIndex(hash, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a list of all txids in the block.
     * @param {string} hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    getBlockTxids(hash, options) {
        return exports.BlockApiFp(this.configuration).getBlockTxids(hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the hash of the last block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    getLastBlockHash(options) {
        return exports.BlockApiFp(this.configuration).getLastBlockHash(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the height of the last block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    getLastBlockHeight(options) {
        return exports.BlockApiFp(this.configuration).getLastBlockHeight(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BlockApi = BlockApi;
/**
 * FeeEstimatesApi - axios parameter creator
 * @export
 */
const FeeEstimatesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get an object where the key is the confirmation target (in number of blocks) and the value is the estimated feerate (in sat/vB).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeEstimates: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/fee-estimates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FeeEstimatesApiAxiosParamCreator = FeeEstimatesApiAxiosParamCreator;
/**
 * FeeEstimatesApi - functional programming interface
 * @export
 */
const FeeEstimatesApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get an object where the key is the confirmation target (in number of blocks) and the value is the estimated feerate (in sat/vB).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeEstimates(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.FeeEstimatesApiAxiosParamCreator(configuration).getFeeEstimates(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
exports.FeeEstimatesApiFp = FeeEstimatesApiFp;
/**
 * FeeEstimatesApi - factory interface
 * @export
 */
const FeeEstimatesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Get an object where the key is the confirmation target (in number of blocks) and the value is the estimated feerate (in sat/vB).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeEstimates(options) {
            return exports.FeeEstimatesApiFp(configuration).getFeeEstimates(options).then((request) => request(axios, basePath));
        },
    };
};
exports.FeeEstimatesApiFactory = FeeEstimatesApiFactory;
/**
 * FeeEstimatesApi - object-oriented interface
 * @export
 * @class FeeEstimatesApi
 * @extends {BaseAPI}
 */
class FeeEstimatesApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get an object where the key is the confirmation target (in number of blocks) and the value is the estimated feerate (in sat/vB).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeEstimatesApi
     */
    getFeeEstimates(options) {
        return exports.FeeEstimatesApiFp(this.configuration).getFeeEstimates(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FeeEstimatesApi = FeeEstimatesApi;
/**
 * MempoolApi - axios parameter creator
 * @export
 */
const MempoolApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get mempool backlog statistics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMempool: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/mempool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a list of the last 10 transactions to enter the mempool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMempoolRecent: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/mempool/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get the full list of txids in the mempool as an array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMempoolTxids: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/mempool/txids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.MempoolApiAxiosParamCreator = MempoolApiAxiosParamCreator;
/**
 * MempoolApi - functional programming interface
 * @export
 */
const MempoolApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get mempool backlog statistics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMempool(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.MempoolApiAxiosParamCreator(configuration).getMempool(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get a list of the last 10 transactions to enter the mempool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMempoolRecent(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.MempoolApiAxiosParamCreator(configuration).getMempoolRecent(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get the full list of txids in the mempool as an array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMempoolTxids(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.MempoolApiAxiosParamCreator(configuration).getMempoolTxids(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
exports.MempoolApiFp = MempoolApiFp;
/**
 * MempoolApi - factory interface
 * @export
 */
const MempoolApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Get mempool backlog statistics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMempool(options) {
            return exports.MempoolApiFp(configuration).getMempool(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a list of the last 10 transactions to enter the mempool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMempoolRecent(options) {
            return exports.MempoolApiFp(configuration).getMempoolRecent(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the full list of txids in the mempool as an array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMempoolTxids(options) {
            return exports.MempoolApiFp(configuration).getMempoolTxids(options).then((request) => request(axios, basePath));
        },
    };
};
exports.MempoolApiFactory = MempoolApiFactory;
/**
 * MempoolApi - object-oriented interface
 * @export
 * @class MempoolApi
 * @extends {BaseAPI}
 */
class MempoolApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get mempool backlog statistics.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MempoolApi
     */
    getMempool(options) {
        return exports.MempoolApiFp(this.configuration).getMempool(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a list of the last 10 transactions to enter the mempool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MempoolApi
     */
    getMempoolRecent(options) {
        return exports.MempoolApiFp(this.configuration).getMempoolRecent(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the full list of txids in the mempool as an array.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MempoolApi
     */
    getMempoolTxids(options) {
        return exports.MempoolApiFp(this.configuration).getMempoolTxids(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.MempoolApi = MempoolApi;
/**
 * ScripthashApi - axios parameter creator
 * @export
 */
const ScripthashApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get confirmed transaction history for the specified address/scripthash, sorted by newest first.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTxsByScripthash: (hash, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new base_1.RequiredError('hash', 'Required parameter hash was null or undefined when calling getRecentTxsByScripthash.');
            }
            const localVarPath = `/scripthash/{hash}/txs/chain`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get confirmed transaction history for the specified address/scripthash, sorted by newest first.
         * @param {string} hash
         * @param {string} lastSeenTxid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsBeforeTxidByScripthash: (hash, lastSeenTxid, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new base_1.RequiredError('hash', 'Required parameter hash was null or undefined when calling getTxsBeforeTxidByScripthash.');
            }
            // verify required parameter 'lastSeenTxid' is not null or undefined
            if (lastSeenTxid === null || lastSeenTxid === undefined) {
                throw new base_1.RequiredError('lastSeenTxid', 'Required parameter lastSeenTxid was null or undefined when calling getTxsBeforeTxidByScripthash.');
            }
            const localVarPath = `/scripthash/{hash}/txs/chain/{lastSeenTxid}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"lastSeenTxid"}}`, encodeURIComponent(String(lastSeenTxid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get transaction history for the specified address/scripthash, sorted with newest first. Can be used to query by op_return
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsByScripthash: (hash, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new base_1.RequiredError('hash', 'Required parameter hash was null or undefined when calling getTxsByScripthash.');
            }
            const localVarPath = `/scripthash/{hash}/txs`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ScripthashApiAxiosParamCreator = ScripthashApiAxiosParamCreator;
/**
 * ScripthashApi - functional programming interface
 * @export
 */
const ScripthashApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get confirmed transaction history for the specified address/scripthash, sorted by newest first.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTxsByScripthash(hash, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ScripthashApiAxiosParamCreator(configuration).getRecentTxsByScripthash(hash, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get confirmed transaction history for the specified address/scripthash, sorted by newest first.
         * @param {string} hash
         * @param {string} lastSeenTxid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsBeforeTxidByScripthash(hash, lastSeenTxid, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ScripthashApiAxiosParamCreator(configuration).getTxsBeforeTxidByScripthash(hash, lastSeenTxid, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get transaction history for the specified address/scripthash, sorted with newest first. Can be used to query by op_return
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsByScripthash(hash, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ScripthashApiAxiosParamCreator(configuration).getTxsByScripthash(hash, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
exports.ScripthashApiFp = ScripthashApiFp;
/**
 * ScripthashApi - factory interface
 * @export
 */
const ScripthashApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Get confirmed transaction history for the specified address/scripthash, sorted by newest first.
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTxsByScripthash(hash, options) {
            return exports.ScripthashApiFp(configuration).getRecentTxsByScripthash(hash, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get confirmed transaction history for the specified address/scripthash, sorted by newest first.
         * @param {string} hash
         * @param {string} lastSeenTxid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsBeforeTxidByScripthash(hash, lastSeenTxid, options) {
            return exports.ScripthashApiFp(configuration).getTxsBeforeTxidByScripthash(hash, lastSeenTxid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get transaction history for the specified address/scripthash, sorted with newest first. Can be used to query by op_return
         * @param {string} hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsByScripthash(hash, options) {
            return exports.ScripthashApiFp(configuration).getTxsByScripthash(hash, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ScripthashApiFactory = ScripthashApiFactory;
/**
 * ScripthashApi - object-oriented interface
 * @export
 * @class ScripthashApi
 * @extends {BaseAPI}
 */
class ScripthashApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get confirmed transaction history for the specified address/scripthash, sorted by newest first.
     * @param {string} hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScripthashApi
     */
    getRecentTxsByScripthash(hash, options) {
        return exports.ScripthashApiFp(this.configuration).getRecentTxsByScripthash(hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get confirmed transaction history for the specified address/scripthash, sorted by newest first.
     * @param {string} hash
     * @param {string} lastSeenTxid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScripthashApi
     */
    getTxsBeforeTxidByScripthash(hash, lastSeenTxid, options) {
        return exports.ScripthashApiFp(this.configuration).getTxsBeforeTxidByScripthash(hash, lastSeenTxid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get transaction history for the specified address/scripthash, sorted with newest first. Can be used to query by op_return
     * @param {string} hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScripthashApi
     */
    getTxsByScripthash(hash, options) {
        return exports.ScripthashApiFp(this.configuration).getTxsByScripthash(hash, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ScripthashApi = ScripthashApi;
/**
 * TxApi - axios parameter creator
 * @export
 */
const TxApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns the spending status of all transaction outputs.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTxOutspends: (txId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'txId' is not null or undefined
            if (txId === null || txId === undefined) {
                throw new base_1.RequiredError('txId', 'Required parameter txId was null or undefined when calling getAllTxOutspends.');
            }
            const localVarPath = `/tx/{txId}/outspends`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns information about the transaction.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx: (txId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'txId' is not null or undefined
            if (txId === null || txId === undefined) {
                throw new base_1.RequiredError('txId', 'Required parameter txId was null or undefined when calling getTx.');
            }
            const localVarPath = `/tx/{txId}`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the raw transaction in hex.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxHex: (txId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'txId' is not null or undefined
            if (txId === null || txId === undefined) {
                throw new base_1.RequiredError('txId', 'Required parameter txId was null or undefined when calling getTxHex.');
            }
            const localVarPath = `/tx/{txId}/hex`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a merkle inclusion proof for the transaction using bitcoind\'s merkleblock format.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxMerkleBlockProof: (txId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'txId' is not null or undefined
            if (txId === null || txId === undefined) {
                throw new base_1.RequiredError('txId', 'Required parameter txId was null or undefined when calling getTxMerkleBlockProof.');
            }
            const localVarPath = `/tx/{txId}/merkleblock-proof`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a merkle inclusion proof for the transaction using Electrum\'s blockchain.transaction.get_merkle format.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxMerkleProof: (txId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'txId' is not null or undefined
            if (txId === null || txId === undefined) {
                throw new base_1.RequiredError('txId', 'Required parameter txId was null or undefined when calling getTxMerkleProof.');
            }
            const localVarPath = `/tx/{txId}/merkle-proof`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the spending status of a transaction output.
         * @param {string} txId
         * @param {number} vout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxOutspend: (txId, vout, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'txId' is not null or undefined
            if (txId === null || txId === undefined) {
                throw new base_1.RequiredError('txId', 'Required parameter txId was null or undefined when calling getTxOutspend.');
            }
            // verify required parameter 'vout' is not null or undefined
            if (vout === null || vout === undefined) {
                throw new base_1.RequiredError('vout', 'Required parameter vout was null or undefined when calling getTxOutspend.');
            }
            const localVarPath = `/tx/{txId}/outspend/{vout}`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)))
                .replace(`{${"vout"}}`, encodeURIComponent(String(vout)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the raw transaction as binary data.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxRaw: (txId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'txId' is not null or undefined
            if (txId === null || txId === undefined) {
                throw new base_1.RequiredError('txId', 'Required parameter txId was null or undefined when calling getTxRaw.');
            }
            const localVarPath = `/tx/{txId}/raw`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the transaction confirmation status.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxStatus: (txId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'txId' is not null or undefined
            if (txId === null || txId === undefined) {
                throw new base_1.RequiredError('txId', 'Required parameter txId was null or undefined when calling getTxStatus.');
            }
            const localVarPath = `/tx/{txId}/status`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Broadcast a raw transaction to the network.
         * @param {string} body The transaction should be provided as hex in the request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTx: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling postTx.');
            }
            const localVarPath = `/tx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'text/plain';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TxApiAxiosParamCreator = TxApiAxiosParamCreator;
/**
 * TxApi - functional programming interface
 * @export
 */
const TxApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Returns the spending status of all transaction outputs.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTxOutspends(txId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TxApiAxiosParamCreator(configuration).getAllTxOutspends(txId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns information about the transaction.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx(txId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TxApiAxiosParamCreator(configuration).getTx(txId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the raw transaction in hex.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxHex(txId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TxApiAxiosParamCreator(configuration).getTxHex(txId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a merkle inclusion proof for the transaction using bitcoind\'s merkleblock format.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxMerkleBlockProof(txId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TxApiAxiosParamCreator(configuration).getTxMerkleBlockProof(txId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a merkle inclusion proof for the transaction using Electrum\'s blockchain.transaction.get_merkle format.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxMerkleProof(txId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TxApiAxiosParamCreator(configuration).getTxMerkleProof(txId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the spending status of a transaction output.
         * @param {string} txId
         * @param {number} vout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxOutspend(txId, vout, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TxApiAxiosParamCreator(configuration).getTxOutspend(txId, vout, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the raw transaction as binary data.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxRaw(txId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TxApiAxiosParamCreator(configuration).getTxRaw(txId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the transaction confirmation status.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxStatus(txId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TxApiAxiosParamCreator(configuration).getTxStatus(txId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Broadcast a raw transaction to the network.
         * @param {string} body The transaction should be provided as hex in the request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTx(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TxApiAxiosParamCreator(configuration).postTx(body, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
exports.TxApiFp = TxApiFp;
/**
 * TxApi - factory interface
 * @export
 */
const TxApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Returns the spending status of all transaction outputs.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTxOutspends(txId, options) {
            return exports.TxApiFp(configuration).getAllTxOutspends(txId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns information about the transaction.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx(txId, options) {
            return exports.TxApiFp(configuration).getTx(txId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the raw transaction in hex.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxHex(txId, options) {
            return exports.TxApiFp(configuration).getTxHex(txId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a merkle inclusion proof for the transaction using bitcoind\'s merkleblock format.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxMerkleBlockProof(txId, options) {
            return exports.TxApiFp(configuration).getTxMerkleBlockProof(txId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a merkle inclusion proof for the transaction using Electrum\'s blockchain.transaction.get_merkle format.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxMerkleProof(txId, options) {
            return exports.TxApiFp(configuration).getTxMerkleProof(txId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the spending status of a transaction output.
         * @param {string} txId
         * @param {number} vout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxOutspend(txId, vout, options) {
            return exports.TxApiFp(configuration).getTxOutspend(txId, vout, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the raw transaction as binary data.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxRaw(txId, options) {
            return exports.TxApiFp(configuration).getTxRaw(txId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the transaction confirmation status.
         * @param {string} txId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxStatus(txId, options) {
            return exports.TxApiFp(configuration).getTxStatus(txId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Broadcast a raw transaction to the network.
         * @param {string} body The transaction should be provided as hex in the request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTx(body, options) {
            return exports.TxApiFp(configuration).postTx(body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TxApiFactory = TxApiFactory;
/**
 * TxApi - object-oriented interface
 * @export
 * @class TxApi
 * @extends {BaseAPI}
 */
class TxApi extends base_1.BaseAPI {
    /**
     *
     * @summary Returns the spending status of all transaction outputs.
     * @param {string} txId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    getAllTxOutspends(txId, options) {
        return exports.TxApiFp(this.configuration).getAllTxOutspends(txId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns information about the transaction.
     * @param {string} txId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    getTx(txId, options) {
        return exports.TxApiFp(this.configuration).getTx(txId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the raw transaction in hex.
     * @param {string} txId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    getTxHex(txId, options) {
        return exports.TxApiFp(this.configuration).getTxHex(txId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a merkle inclusion proof for the transaction using bitcoind\'s merkleblock format.
     * @param {string} txId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    getTxMerkleBlockProof(txId, options) {
        return exports.TxApiFp(this.configuration).getTxMerkleBlockProof(txId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a merkle inclusion proof for the transaction using Electrum\'s blockchain.transaction.get_merkle format.
     * @param {string} txId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    getTxMerkleProof(txId, options) {
        return exports.TxApiFp(this.configuration).getTxMerkleProof(txId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the spending status of a transaction output.
     * @param {string} txId
     * @param {number} vout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    getTxOutspend(txId, vout, options) {
        return exports.TxApiFp(this.configuration).getTxOutspend(txId, vout, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the raw transaction as binary data.
     * @param {string} txId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    getTxRaw(txId, options) {
        return exports.TxApiFp(this.configuration).getTxRaw(txId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the transaction confirmation status.
     * @param {string} txId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    getTxStatus(txId, options) {
        return exports.TxApiFp(this.configuration).getTxStatus(txId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Broadcast a raw transaction to the network.
     * @param {string} body The transaction should be provided as hex in the request body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    postTx(body, options) {
        return exports.TxApiFp(this.configuration).postTx(body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TxApi = TxApi;
