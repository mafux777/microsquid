import Big, { RoundingMode } from "big.js";
import { Currency, MonetaryAmount, UnitList } from "./monetary";
export declare type UnitMap<B extends UnitList, C extends UnitList> = {
    baseUnit: B[keyof B];
    counterUnit: C[keyof C];
};
export declare class ExchangeRate<Base extends Currency<BaseUnit>, BaseUnit extends UnitList, Counter extends Currency<CounterUnit>, CounterUnit extends UnitList> {
    readonly base: Base;
    readonly counter: Counter;
    readonly rate: Big;
    /**
     * Helper that takes a rate converting arbitrary units (e.g. Satoshi/ETH, BTC/Gwei, etc.)
     * and returns the base rate among minimal units (i.e. Satoshi/Wei, for Bitcoin and Ethereum)
     **/
    private normalizeRate;
    /**
     * Helper that takes a rate converting minimal units (e.g. Wei/Satoshi, for Bitcoin and
     * Ethereum) and returns the rate among arbitrary mixed-and-matched units
     * (i.e. ETH/Satoshi, Gwei/BTC, etc.)
     * Defaults to denormalizing to base units of the currencies (e.g. ETH/BTC).
     **/
    private denormalizeRate;
    /**
     *
     * @param base Base currency, BTC in BTC/USDT
     * @param counter Counter currency, USDT in BTC/USDT
     * @param rate Exchange rate: amount of `counter` needed per unit of `base`
     * @param baseUnit (optional) Unit of base currency which `rate` expresses. Defaults to the currency base unit.
     * E.g. "BTC" or "satoshi" in BTC/USDT, defaulting to BTC.
     * @param counterUnit (optional) Unit of counter currency which `rate` expresses. Defaults to the currency base unit.
     */
    constructor(base: Base, counter: Counter, rate: Big, baseUnit?: BaseUnit[keyof BaseUnit], counterUnit?: CounterUnit[keyof CounterUnit]);
    toBase(amount: MonetaryAmount<Counter, CounterUnit>): MonetaryAmount<Base, BaseUnit>;
    toCounter(amount: MonetaryAmount<Base, BaseUnit>): MonetaryAmount<Counter, CounterUnit>;
    toBig(units?: Partial<UnitMap<BaseUnit, CounterUnit>>): Big;
    toRawBig(): Big;
    toString(units?: Partial<UnitMap<BaseUnit, CounterUnit>>, precision?: number, rm?: RoundingMode): string;
    toRawString(): string;
    toHuman(precision?: number): string;
}
export declare const BTC_INTERBTC: ExchangeRate<Currency<{
    readonly BTC: 8;
    readonly Satoshi: 0;
}>, {
    readonly BTC: 8;
    readonly Satoshi: 0;
}, Currency<{
    readonly BTC: 8;
    readonly Satoshi: 0;
}>, {
    readonly BTC: 8;
    readonly Satoshi: 0;
}>;
export declare const BTC_KBTC: ExchangeRate<Currency<{
    readonly BTC: 8;
    readonly Satoshi: 0;
}>, {
    readonly BTC: 8;
    readonly Satoshi: 0;
}, Currency<{
    readonly BTC: 8;
    readonly Satoshi: 0;
}>, {
    readonly BTC: 8;
    readonly Satoshi: 0;
}>;
export declare const INTERBTC_KBTC: ExchangeRate<Currency<{
    readonly BTC: 8;
    readonly Satoshi: 0;
}>, {
    readonly BTC: 8;
    readonly Satoshi: 0;
}, Currency<{
    readonly BTC: 8;
    readonly Satoshi: 0;
}>, {
    readonly BTC: 8;
    readonly Satoshi: 0;
}>;
