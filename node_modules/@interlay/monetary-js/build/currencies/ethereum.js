"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TetherAmount = exports.Tether = exports.EthereumAmount = exports.Ethereum = void 0;
const monetary_1 = require("../monetary");
const EthereumUnit = {
    ETH: 18,
    GWei: 9,
    Wei: 0,
};
exports.Ethereum = {
    name: "Ethereum",
    units: EthereumUnit,
    base: EthereumUnit.ETH,
    rawBase: EthereumUnit.Wei,
    ticker: "ETH",
    humanDecimals: 7
};
/* Example that extends the constructor to allow convenient `new EthereumAmount(amount)` calls */
class EthereumAmount extends monetary_1.MonetaryAmount {
    constructor(amount, unit) {
        super(exports.Ethereum, amount, unit ? EthereumUnit[unit] : 0);
    }
    withAmount(amount) {
        const Cls = this.constructor;
        return new Cls(amount);
    }
}
exports.EthereumAmount = EthereumAmount;
EthereumAmount.from = monetary_1.generateFromConversions(exports.Ethereum, EthereumUnit);
EthereumAmount.zero = EthereumAmount.from.ETH(0);
const TetherUnit = {
    Tether: 6,
    Raw: 0
};
class Tether {
    constructor(address) {
        this.address = address;
    }
    get units() {
        return TetherUnit;
    }
    get base() {
        return TetherUnit.Tether;
    }
    get rawBase() {
        return TetherUnit.Raw;
    }
    get name() {
        return "Tether";
    }
    get ticker() {
        return "USDT";
    }
}
exports.Tether = Tether;
class TetherAmount extends monetary_1.MonetaryAmount {
}
exports.TetherAmount = TetherAmount;
TetherAmount.from = monetary_1.generateFromConversions(new Tether("0xdac17f958d2ee523a2206206994597c13d831ec7"), TetherUnit);
