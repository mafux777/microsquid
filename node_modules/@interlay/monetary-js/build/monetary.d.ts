import Big, { RoundingMode, BigSource } from "big.js";
export declare type UnitList = Record<string, number>;
export interface Currency<Units extends UnitList> {
    readonly name: string;
    readonly units: Units;
    readonly base: Units[keyof Units];
    readonly rawBase: Units[keyof Units];
    readonly ticker: string;
    readonly humanDecimals?: number;
}
declare type toConversions<U extends UnitList> = {
    [key in keyof U]: () => Big;
};
declare type strConversions<U extends UnitList> = {
    [key in keyof U]: () => string;
};
declare type fromConversions<M extends MonetaryAmount<C, U>, C extends Currency<U>, U extends UnitList> = {
    [key in keyof U]: (amount: BigSource) => M;
};
export declare class MonetaryAmount<C extends Currency<U>, U extends UnitList> {
    readonly currency: C;
    protected _amount: Big;
    rm: RoundingMode;
    /**
     * Accessor for the arbitrary precision internal storage.
     * May hold fractional amounts below the lowest currency unit (e.g. fractional Satoshi).
     **/
    get _rawAmount(): Big;
    private _integerAmount;
    constructor(currency: C, amount: BigSource, unit?: U[keyof U]);
    toString(unit?: U[keyof U], rm?: RoundingMode): string;
    toBig(unit?: U[keyof U], rm?: RoundingMode): Big;
    toHuman(decimals?: number | undefined): string;
    private parseCmpMembers;
    private ensureSameCurrency;
    eq(amount: this, rm?: RoundingMode): boolean;
    gt(amount: this, rm?: RoundingMode): boolean;
    gte(amount: this, rm?: RoundingMode): boolean;
    lt(amount: this, rm?: RoundingMode): boolean;
    lte(amount: this, rm?: RoundingMode): boolean;
    add(amount: this): this;
    sub(amount: this): this;
    isZero(): boolean;
    protected isSameCurrency(amount: this): boolean;
    mul(multiplier: BigSource): this;
    div(divisor: BigSource): this;
    min(amount: this): this;
    max(amount: this): this;
    withAmount(amount: BigSource, unit?: U[keyof U]): this;
    to: toConversions<U>;
    str: strConversions<U>;
}
export declare function generateFromConversions<M extends MonetaryAmount<C, U>, C extends Currency<U>, U extends UnitList>(currency: C, units: U): fromConversions<M, C, U>;
export {};
