"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateFromConversions = exports.MonetaryAmount = void 0;
const big_js_1 = __importDefault(require("big.js"));
big_js_1.default.DP = 100;
big_js_1.default.NE = -20;
big_js_1.default.PE = 20;
class MonetaryAmount {
    constructor(currency, amount, unit = currency.rawBase) {
        this.currency = currency;
        this.rm = 1 /* RoundHalfUp */;
        this.to = (() => Object.fromEntries(Object.entries(this.currency.units).map(([name, decimals]) => [
            name,
            () => this.toBig(decimals),
        ])))();
        this.str = (() => Object.fromEntries(Object.entries(this.currency.units).map(([name, decimals]) => [
            name,
            () => this.toString(decimals),
        ])))();
        amount = new big_js_1.default(amount).mul(new big_js_1.default(10).pow(unit)); // convert to min denomination
        this._amount = amount;
    }
    /**
     * Accessor for the arbitrary precision internal storage.
     * May hold fractional amounts below the lowest currency unit (e.g. fractional Satoshi).
     **/
    get _rawAmount() {
        return this._amount;
    }
    _integerAmount(rm) {
        if (rm === undefined)
            rm = this.rm;
        return this._amount.round(0, rm);
    }
    toString(unit, rm) {
        return this.toBig(unit, rm).toString();
    }
    toBig(unit = this.currency.rawBase, rm) {
        const ret = this._amount.div(new big_js_1.default(10).pow(unit));
        return ret.round(unit, rm === undefined ? this.rm : rm); // ensure no decimal places lower than smallest unit
    }
    toHuman(decimals = this.currency.humanDecimals) {
        const big = this.toBig(this.currency.base);
        let rounded;
        if (decimals !== undefined) {
            rounded = big.e >= -decimals ?
                big.round(decimals).toString() :
                big.toPrecision(1); // show at least 1 significant digit if rounding would give '0'
        }
        else
            rounded = big.toString();
        return rounded;
    }
    parseCmpMembers(lhs, rhs, rm) {
        return [lhs._integerAmount(rm), rhs._integerAmount(rm)];
    }
    ensureSameCurrency(counterpart, opName = "operation") {
        if (!this.isSameCurrency(counterpart)) {
            throw new Error(`cannot perform ${opName} on ${this.currency.name} and ${counterpart.currency.name}`);
        }
    }
    eq(amount, rm) {
        this.ensureSameCurrency(amount, "equality comparison");
        const [lhs, rhs] = this.parseCmpMembers(this, amount, rm);
        return lhs.eq(rhs);
    }
    gt(amount, rm) {
        this.ensureSameCurrency(amount, "comparison");
        const [lhs, rhs] = this.parseCmpMembers(this, amount, rm);
        return lhs.gt(rhs);
    }
    gte(amount, rm) {
        this.ensureSameCurrency(amount, "comparison");
        const [lhs, rhs] = this.parseCmpMembers(this, amount, rm);
        return lhs.gte(rhs);
    }
    lt(amount, rm) {
        this.ensureSameCurrency(amount, "comparison");
        const [lhs, rhs] = this.parseCmpMembers(this, amount, rm);
        return lhs.lt(rhs);
    }
    lte(amount, rm) {
        this.ensureSameCurrency(amount, "comparison");
        const [lhs, rhs] = this.parseCmpMembers(this, amount, rm);
        return lhs.lte(rhs);
    }
    add(amount) {
        this.ensureSameCurrency(amount, "addition");
        return this.withAmount(this._amount.add(amount._amount));
    }
    sub(amount) {
        this.ensureSameCurrency(amount, "subtraction");
        return this.withAmount(this._amount.sub(amount._amount));
    }
    isZero() {
        return this._amount.eq(new big_js_1.default(0));
    }
    isSameCurrency(amount) {
        return this.currency.name === amount.currency.name;
    }
    mul(multiplier) {
        return this.withAmount(this._amount.mul(multiplier));
    }
    div(divisor) {
        return this.withAmount(this._amount.div(divisor));
    }
    min(amount) {
        return this.lt(amount) ? this : amount;
    }
    max(amount) {
        return this.gt(amount) ? this : amount;
    }
    // NOTE: needs override if constructor is overriden
    withAmount(amount, unit) {
        const Cls = this.constructor;
        return new Cls(this.currency, amount, unit);
    }
}
exports.MonetaryAmount = MonetaryAmount;
function generateFromConversions(currency, units) {
    return Object.fromEntries(Object.entries(units).map(([name, decimals]) => [
        name,
        (amount) => new MonetaryAmount(currency, amount, decimals),
    ]));
}
exports.generateFromConversions = generateFromConversions;
