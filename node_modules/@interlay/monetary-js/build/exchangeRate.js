"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.INTERBTC_KBTC = exports.BTC_KBTC = exports.BTC_INTERBTC = exports.ExchangeRate = void 0;
const big_js_1 = __importDefault(require("big.js"));
const currencies_1 = require("./currencies");
const interbtc_1 = require("./currencies/interbtc");
const kbtc_1 = require("./currencies/kbtc");
const monetary_1 = require("./monetary");
big_js_1.default.DP = 100;
class ExchangeRate {
    /**
     *
     * @param base Base currency, BTC in BTC/USDT
     * @param counter Counter currency, USDT in BTC/USDT
     * @param rate Exchange rate: amount of `counter` needed per unit of `base`
     * @param baseUnit (optional) Unit of base currency which `rate` expresses. Defaults to the currency base unit.
     * E.g. "BTC" or "satoshi" in BTC/USDT, defaulting to BTC.
     * @param counterUnit (optional) Unit of counter currency which `rate` expresses. Defaults to the currency base unit.
     */
    constructor(base, counter, rate, baseUnit = base.base, counterUnit = counter.base) {
        this.base = base;
        this.counter = counter;
        this.rate = rate;
        this.rate = this.normalizeRate(rate, { baseUnit, counterUnit });
    }
    /**
     * Helper that takes a rate converting arbitrary units (e.g. Satoshi/ETH, BTC/Gwei, etc.)
     * and returns the base rate among minimal units (i.e. Satoshi/Wei, for Bitcoin and Ethereum)
     **/
    normalizeRate(rate, { baseUnit, counterUnit }) {
        if (baseUnit) {
            rate = rate.div(new big_js_1.default(10).pow(baseUnit));
        }
        if (counterUnit) {
            rate = rate.mul(new big_js_1.default(10).pow(counterUnit));
        }
        return rate;
    }
    /**
     * Helper that takes a rate converting minimal units (e.g. Wei/Satoshi, for Bitcoin and
     * Ethereum) and returns the rate among arbitrary mixed-and-matched units
     * (i.e. ETH/Satoshi, Gwei/BTC, etc.)
     * Defaults to denormalizing to base units of the currencies (e.g. ETH/BTC).
     **/
    denormalizeRate(rate, { baseUnit, counterUnit }) {
        if (baseUnit === undefined)
            baseUnit = this.base.base;
        if (counterUnit === undefined)
            counterUnit = this.counter.base;
        rate = rate
            .mul(new big_js_1.default(10).pow(baseUnit))
            .div(new big_js_1.default(10).pow(counterUnit));
        return rate;
    }
    toBase(amount) {
        const converted = amount.div(this.rate);
        return new monetary_1.MonetaryAmount(this.base, converted._rawAmount);
    }
    toCounter(amount) {
        const converted = amount.mul(this.rate);
        return new monetary_1.MonetaryAmount(this.counter, converted._rawAmount);
    }
    toBig(units) {
        return this.denormalizeRate(this.rate, units || {});
    }
    toRawBig() {
        return this.toBig({ baseUnit: this.base.rawBase, counterUnit: this.counter.rawBase });
    }
    toString(units, precision, rm) {
        let rate = this.denormalizeRate(this.rate, units || {});
        if (precision !== undefined)
            rate = rate.round(precision, rm);
        return rate.toString();
    }
    toRawString() {
        return this.toString({ baseUnit: 0, counterUnit: 0 });
    }
    toHuman(precision) {
        if (precision === undefined) {
            if (this.base.humanDecimals && this.counter.humanDecimals) {
                precision = Math.max(this.base.humanDecimals, this.counter.humanDecimals);
            }
            else if (this.base.humanDecimals !== undefined) {
                precision = this.base.humanDecimals;
            }
            else {
                precision = this.counter.humanDecimals;
            }
        }
        return this.toString({ baseUnit: this.base.base, counterUnit: this.counter.base }, precision);
    }
}
exports.ExchangeRate = ExchangeRate;
const one = new big_js_1.default(1);
exports.BTC_INTERBTC = new ExchangeRate(currencies_1.Bitcoin, interbtc_1.InterBtc, one);
exports.BTC_KBTC = new ExchangeRate(currencies_1.Bitcoin, kbtc_1.KBtc, one);
exports.INTERBTC_KBTC = new ExchangeRate(interbtc_1.InterBtc, kbtc_1.KBtc, one);
