"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Codec = void 0;
const scale_codec_1 = require("@subsquid/scale-codec");
const util_1 = require("@subsquid/scale-codec/lib/util");
const util_internal_hex_1 = require("@subsquid/util-internal-hex");
const assert_1 = __importDefault(require("assert"));
const types_1 = require("./types");
const util_2 = require("./util");
class Codec {
    constructor(types) {
        this.types = (0, types_1.toJsonTypes)(types);
        this.scaleCodec = new scale_codec_1.Codec(types);
    }
    decode(type, value) {
        let def = this.types[type];
        switch (def.kind) {
            case scale_codec_1.TypeKind.Primitive:
                return (0, util_2.decodePrimitive)(def.primitive, value);
            case scale_codec_1.TypeKind.Compact:
                return (0, util_2.decodeCompact)(def.integer, value);
            case scale_codec_1.TypeKind.BitSequence:
                return (0, util_internal_hex_1.decodeHex)(value);
            case scale_codec_1.TypeKind.Array:
                return this.decodeArray(type, def, value);
            case scale_codec_1.TypeKind.Sequence:
                return this.decodeSequence(def, value);
            case scale_codec_1.TypeKind.Tuple:
                return this.decodeTuple(def, value);
            case scale_codec_1.TypeKind.Struct:
                return this.decodeStruct(def, value);
            case scale_codec_1.TypeKind.Variant:
                return this.decodeVariant(def, value);
            case scale_codec_1.TypeKind.Option:
                return this.decodeOption(def.type, value);
            case scale_codec_1.TypeKind.BooleanOption:
                return this.decodeBooleanOption(value);
            case scale_codec_1.TypeKind.Bytes:
                return (0, util_internal_hex_1.decodeHex)(value);
            case scale_codec_1.TypeKind.BytesArray:
                return (0, util_2.decodeBinaryArray)(def.len, value);
            case scale_codec_1.TypeKind.DoNotConstruct:
                throw new Error('DoNotConstruct type reached');
            default:
                (0, util_1.throwUnexpectedCase)(def.kind);
        }
    }
    decodeArray(ti, def, value) {
        if (Array.isArray(value)) {
            (0, assert_1.default)(value.length == def.len);
            let result = new Array(value.length);
            for (let i = 0; i < value.length; i++) {
                result[i] = this.decode(def.type, value[i]);
            }
            return result;
        }
        else {
            // For some reasons, polkadot can encode values
            // for which we get type [u64; 4] as a single u256 number.
            // This branch is for that case.
            (0, assert_1.default)(typeof value == 'string' || typeof value == 'number');
            let n = BigInt(value);
            let itemType = this.types[def.type];
            (0, assert_1.default)(itemType.kind == scale_codec_1.TypeKind.Primitive && itemType.primitive[0] == 'U');
            let totalLength = def.len * Number.parseInt(itemType.primitive.slice(1)) / 8;
            let binary = (0, util_2.encodeUnsignedInt)(totalLength, n);
            return this.scaleCodec.decodeBinary(ti, binary);
        }
    }
    decodeSequence(def, value) {
        (0, assert_1.default)(Array.isArray(value));
        let result = new Array(value.length);
        for (let i = 0; i < value.length; i++) {
            result[i] = this.decode(def.type, value[i]);
        }
        return result;
    }
    decodeTuple(def, value) {
        let items = def.tuple;
        if (items.length == 0) {
            (0, assert_1.default)(value == null || Array.isArray(value) && value.length == 0);
            return null;
        }
        else {
            (0, assert_1.default)(Array.isArray(value));
            (0, assert_1.default)(value.length == items.length);
            let result = new Array(items.length);
            for (let i = 0; i < items.length; i++) {
                result[i] = this.decode(items[i], value[i]);
            }
            return result;
        }
    }
    decodeStruct(def, value) {
        (0, assert_1.default)(typeof value == 'object' && value != null);
        let result = {};
        for (let i = 0; i < def.fields.length; i++) {
            let f = def.fields[i];
            result[f.name] = this.decode(f.type, value[f.name]);
        }
        return result;
    }
    decodeVariant(def, value) {
        if (typeof value == 'string') {
            if (def.variantNames == null) {
                throw new Error(`Variant type which has variants with arguments can't be encoded as string`);
            }
            if (def.variantNames[value])
                return { __kind: value };
            throw new Error(`Unknown variant: ${value}`);
        }
        (0, assert_1.default)(typeof value == 'object' && value != null);
        let result = undefined;
        for (let key in value) {
            if (result != null)
                throw new Error('Ambiguous variant');
            let v = def.variantsByPropName[key.toLowerCase()];
            if (v == null)
                throw new Error(`Unknown variant ${key}`);
            switch (v.kind) {
                case 'struct':
                    result = this.decodeStruct(v.def, value[key]);
                    result.__kind = v.name;
                    break;
                case 'tuple':
                    result = {
                        __kind: v.name,
                        value: this.decodeTuple(v.def, value[key])
                    };
                    break;
                case 'value':
                    result = {
                        __kind: v.name,
                        value: this.decode(v.type, value[key])
                    };
                    break;
                case 'empty':
                    result = { __kind: v.name };
                    break;
                default:
                    (0, util_1.throwUnexpectedCase)();
            }
        }
        if (result == null)
            throw new Error('Empty variant object');
        return result;
    }
    decodeOption(type, value) {
        return value == null ? undefined : this.decode(type, value);
    }
    decodeBooleanOption(value) {
        if (value == null)
            return undefined;
        (0, assert_1.default)(typeof value == 'boolean');
        return value;
    }
}
exports.Codec = Codec;
//# sourceMappingURL=index.js.map