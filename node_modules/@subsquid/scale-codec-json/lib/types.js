"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toJsonVariantType = exports.toJsonTypes = void 0;
const scale_codec_1 = require("@subsquid/scale-codec");
const types_codec_1 = require("@subsquid/scale-codec/lib/types-codec");
function toJsonTypes(types) {
    return (0, types_codec_1.toCodecTypes)(types).map(type => {
        switch (type.kind) {
            case scale_codec_1.TypeKind.Variant:
                return toJsonVariantType(type);
            default:
                return type;
        }
    });
}
exports.toJsonTypes = toJsonTypes;
function toJsonVariantType(type) {
    let byProp = Object.create(null);
    let names = Object.create(null);
    let hasNoFields = true;
    type.variants.forEach(v => {
        if (v == null)
            return;
        names[v.name] = true;
        byProp[v.name.toLowerCase()] = v;
        if (v.kind != 'empty') {
            hasNoFields = false;
        }
    });
    if (Object.keys(byProp).length != Object.keys(names).length) {
        throw new Error(`
Variant type with variants ${JSON.stringify(Object.keys(names))} can't be reliably decoded,
because of a clash between lower cased variant names.
            `.trim());
    }
    return {
        kind: scale_codec_1.TypeKind.Variant,
        variantsByPropName: byProp,
        variantNames: hasNoFields ? names : undefined
    };
}
exports.toJsonVariantType = toJsonVariantType;
//# sourceMappingURL=types.js.map