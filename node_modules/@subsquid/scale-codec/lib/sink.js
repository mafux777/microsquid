"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ByteSink = exports.HexSink = exports.Sink = void 0;
const assert_1 = __importDefault(require("assert"));
const util_1 = require("./util");
class Sink {
    uncheckedU16(val) {
        this.write(val & 0xff);
        this.write(val >>> 8);
    }
    uncheckedU32(val) {
        this.write(val & 0xff);
        this.write((val >>> 8) & 0xff);
        this.write((val >>> 16) & 0xff);
        this.write(val >>> 24);
    }
    uncheckedU64(val) {
        this.uncheckedU32(Number(val & 0xffffffffn));
        this.uncheckedU32(Number(val >> 32n));
    }
    uncheckedU128(val) {
        this.uncheckedU64(val & 0xffffffffffffffffn);
        this.uncheckedU64(val >> 64n);
    }
    uncheckedU256(val) {
        this.uncheckedU128(val & (2n ** 128n) - 1n);
        this.uncheckedU128(val >> 128n);
    }
    u8(val) {
        (0, util_1.checkInt)(val, 'U8', 0, 0xff);
        this.write(val);
    }
    u16(val) {
        (0, util_1.checkInt)(val, 'U16', 0, 0xffff);
        this.uncheckedU16(val);
    }
    u32(val) {
        (0, util_1.checkInt)(val, 'U32', 0, 0xffffffff);
        this.uncheckedU32(val);
    }
    u64(val) {
        (0, util_1.checkBigInt)(val, 'U64', 0n, 0xffffffffffffffffn);
        this.uncheckedU64(val);
    }
    u128(val) {
        (0, util_1.checkBigInt)(val, 'U128', 0n, 2n ** 128n - 1n);
        this.uncheckedU128(val);
    }
    u256(val) {
        (0, util_1.checkBigInt)(val, 'U128', 0n, 2n ** 256n - 1n);
        this.uncheckedU256(val);
    }
    i8(val) {
        (0, util_1.checkInt)(val, 'I8', -0x80, 0x7f);
        this.write((val + 256) % 256);
    }
    i16(val) {
        (0, util_1.checkInt)(val, 'I16', -0x8000, 0x7fff);
        let base = 2 ** 16;
        val = (val + base) % base;
        this.uncheckedU16(val);
    }
    i32(val) {
        (0, util_1.checkInt)(val, 'I16', -0x80000000, 0x7fffffff);
        let base = 2 ** 32;
        val = (val + base) % base;
        this.uncheckedU32(val);
    }
    i64(val) {
        (0, util_1.checkBigInt)(val, 'I64', -(2n ** 63n), 2n ** 63n - 1n);
        let base = 2n ** 64n;
        val = (val + base) % base;
        this.uncheckedU64(val);
    }
    i128(val) {
        (0, util_1.checkBigInt)(val, 'I128', -(2n ** 127n), 2n ** 127n - 1n);
        let base = 2n ** 128n;
        val = (val + base) % base;
        this.uncheckedU128(val);
    }
    i256(val) {
        (0, util_1.checkBigInt)(val, 'I256', -(2n ** 255n), 2n ** 255n - 1n);
        let base = 2n ** 256n;
        val = (val + base) % base;
        this.uncheckedU256(val);
    }
    str(val) {
        (0, assert_1.default)(typeof val == 'string');
        let bytes = util_1.UTF8_ENCODER.encode(val);
        this.compact(bytes.length);
        this.bytes(bytes);
    }
    bool(val) {
        (0, assert_1.default)(typeof val == 'boolean');
        this.write(Number(val));
    }
    compact(val) {
        (0, assert_1.default)((typeof val == 'number' || typeof val == 'bigint') && val >= 0, 'invalid compact');
        if (val < 64) {
            this.write(Number(val) * 4);
        }
        else if (val < 2 ** 14) {
            val = Number(val);
            this.write((val & 63) * 4 + 1);
            this.write(val >>> 6);
        }
        else if (val < 2 ** 30) {
            val = Number(val);
            this.write((val & 63) * 4 + 2);
            this.write((val >>> 6) & 0xff);
            this.uncheckedU16(val >>> 14);
        }
        else if (val < 2n ** 536n) {
            val = BigInt(val);
            this.write((0, util_1.unsignedIntByteLength)(val) * 4 - 13);
            while (val > 0) {
                this.write(Number(val & 0xffn));
                val = val >> 8n;
            }
        }
        else {
            throw new Error(`${val.toString(16)} is too large for a compact`);
        }
    }
}
exports.Sink = Sink;
class HexSink extends Sink {
    constructor() {
        super(...arguments);
        this.hex = '0x';
    }
    write(byte) {
        this.hex += (byte >>> 4).toString(16);
        this.hex += (byte & 15).toString(16);
    }
    bytes(b) {
        if (Buffer.isBuffer(b)) {
            this.hex += b.toString('hex');
        }
        else {
            this.hex += Buffer.from(b.buffer, b.byteOffset, b.byteLength).toString('hex');
        }
    }
    toHex() {
        return this.hex;
    }
}
exports.HexSink = HexSink;
class ByteSink extends Sink {
    constructor() {
        super(...arguments);
        this.buf = Buffer.allocUnsafe(128);
        this.pos = 0;
    }
    alloc(size) {
        if (this.buf.length - this.pos < size) {
            let buf = Buffer.allocUnsafe(Math.max(size, this.buf.length) * 2);
            buf.set(this.buf);
            this.buf = buf;
        }
    }
    write(byte) {
        this.alloc(1);
        this.buf[this.pos] = byte;
        this.pos += 1;
    }
    bytes(b) {
        this.alloc(b.length);
        this.buf.set(b, this.pos);
        this.pos += b.length;
    }
    toBytes() {
        return this.buf.subarray(0, this.pos);
    }
}
exports.ByteSink = ByteSink;
//# sourceMappingURL=sink.js.map