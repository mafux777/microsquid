"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const typeorm_config_1 = require("@subsquid/typeorm-config");
const util_1 = require("@subsquid/util");
const dotenv = __importStar(require("dotenv"));
const typeorm_1 = require("typeorm");
class CreateMigration extends core_1.Command {
    async run() {
        dotenv.config();
        let { args } = await this.parse(CreateMigration);
        let name = args.name ? args.name : await core_1.CliUx.ux.prompt('Enter migration name', {
            required: true,
        });
        let cfg = {
            ...(0, typeorm_config_1.createOrmConfig)(),
            synchronize: false,
            migrationsRun: false,
            dropSchema: false,
            logging: false
        };
        let commands;
        let connection = await (0, typeorm_1.createConnection)(cfg);
        try {
            commands = await connection.driver.createSchemaBuilder().log();
        }
        finally {
            await connection.close().catch(err => null);
        }
        if (commands.upQueries.length == 0) {
            this.error('No changes in database schema were found - cannot generate a migration.');
        }
        let dir = new util_1.OutDir((0, util_1.assertNotNull)(cfg.cli?.migrationsDir));
        let timestamp = Date.now();
        let out = dir.file(`${timestamp}-${name}.js`);
        out.block(`module.exports = class ${name}${timestamp}`, () => {
            out.line(`name = '${name}${timestamp}'`);
            out.line();
            out.block(`async up(db)`, () => {
                commands.upQueries.forEach(q => {
                    out.line(`await db.query${queryTuple(q)}`);
                });
            });
            out.line();
            out.block(`async down(db)`, () => {
                commands.downQueries.forEach(q => {
                    out.line(`await db.query${queryTuple(q)}`);
                });
            });
        });
        out.write();
    }
}
exports.default = CreateMigration;
CreateMigration.description = 'Analyze database state and generate migration to match the target schema';
CreateMigration.args = [{ name: 'name' }];
function queryTuple(q) {
    let params = q.parameters?.length ? ', ' + JSON.stringify(q.parameters) : '';
    return '(`' + q.query + '`' + params + ')';
}
//# sourceMappingURL=create-migration.js.map