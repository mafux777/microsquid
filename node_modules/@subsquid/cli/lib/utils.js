"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseNameAndVersion = exports.buildRemoteUrlFromGit = exports.pollDeployPipelines = void 0;
const core_1 = require("@oclif/core");
const cli_select_1 = __importDefault(require("cli-select"));
const pipeline_1 = require("./rest-client/routes/pipeline");
function buildPipelineErrorMessage(text, errorMessage) {
    return `${text} ${errorMessage ? `: ${errorMessage}` : ''}`;
}
async function pollDeployPipelines(squidName, versionName, deploymentUrl, command) {
    let inProgress = true;
    let lastStatus;
    while (inProgress) {
        const pipeline = await (0, pipeline_1.getDeployPipeline)(squidName, versionName);
        if (pipeline) {
            if (pipeline.status !== lastStatus) {
                lastStatus = pipeline.status;
                core_1.CliUx.ux.action.stop('✔️');
            }
            switch (pipeline?.status) {
                case pipeline_1.DeployPipelineStatusEnum.CREATED:
                    core_1.CliUx.ux.action.start('◷ Preparing your squid');
                    if (pipeline.isErrorOccurred) {
                        command.error(buildPipelineErrorMessage(`❌ An error occurred during building process`, pipeline.comment));
                    }
                    break;
                case pipeline_1.DeployPipelineStatusEnum.IMAGE_BUILDING:
                    core_1.CliUx.ux.action.start('◷ Building your squid');
                    if (pipeline.isErrorOccurred) {
                        command.error(buildPipelineErrorMessage(`❌ An error occurred during building process`, pipeline.comment));
                    }
                    break;
                case pipeline_1.DeployPipelineStatusEnum.IMAGE_PUSHING:
                    core_1.CliUx.ux.action.start('◷ Publishing your squid');
                    if (pipeline.isErrorOccurred) {
                        command.error(buildPipelineErrorMessage(`❌ An error occurred during pushing process`, pipeline.comment));
                    }
                    break;
                case pipeline_1.DeployPipelineStatusEnum.DEPLOYING:
                    core_1.CliUx.ux.action.start('◷ Almost ready');
                    if (pipeline.isErrorOccurred) {
                        command.error(buildPipelineErrorMessage(`❌ An error occurred during deploying process`, pipeline.comment));
                    }
                    break;
                case pipeline_1.DeployPipelineStatusEnum.OK:
                    command.log(`◷ Your squid almost ready and will be accessible on ${deploymentUrl}`);
                    inProgress = false;
                    break;
                default:
                    command.error('❌ An error occurred. Unexpected status of pipeline.');
            }
        }
        await new Promise((resolve) => setTimeout(resolve, 3000));
    }
}
exports.pollDeployPipelines = pollDeployPipelines;
async function buildRemoteUrlFromGit(git, command) {
    let remoteUrl;
    const remotes = await git.getRemotes(true);
    if (remotes.length === 0) {
        command.error(`The remotes were not found`, { code: '1' });
    }
    else if (remotes.length === 1) {
        remoteUrl = remotes[0];
    }
    else {
        const selected = await (0, cli_select_1.default)({
            cleanup: false,
            values: remotes.map((remote) => remote.name),
        }).catch(() => {
            command.error('Canceled', { code: '1' });
        });
        remoteUrl = remotes.find((remote) => remote.name === selected.value);
    }
    await git.listRemote([remoteUrl.name]).catch(() => {
        command.error(`Remote url with name ${remoteUrl.name} not exists`, {
            code: '1',
        });
    });
    const branch = (await git.branch()).current;
    const status = await git.status();
    if (status.files && status.files.length) {
        command.error(`There are unstaged or uncommitted changes`);
    }
    await git.fetch();
    const remoteBranchRefs = await git.listRemote([
        `${remoteUrl.name}`,
        `${branch}`,
    ]);
    if (remoteBranchRefs === '') {
        command.error(`Remote branch "${remoteUrl.name}/${branch}" not exists`);
    }
    const localCommit = await git.log([
        '-n',
        1,
        branch,
    ]);
    const remoteCommit = await git.log([
        '-n',
        1,
        `${remoteUrl.name}/${branch}`,
    ]);
    if (!localCommit.latest ||
        !remoteCommit.latest ||
        localCommit.latest.hash !== remoteCommit.latest.hash) {
        command.error(`Head origin commit is not the same as the local origin commit`);
    }
    return `${remoteUrl.refs.fetch}${remoteUrl.refs.fetch.endsWith('.git') ? '' : '.git'}#${remoteCommit.latest.hash}`;
}
exports.buildRemoteUrlFromGit = buildRemoteUrlFromGit;
function parseNameAndVersion(nameAndVersion, command) {
    if ((nameAndVersion.match(/.+@.+/gi) || []).length === 0 ||
        (nameAndVersion.match(/@/g) || []).length !== 1) {
        command.error('Required format: <name>@<version>. Symbol @ not allowed in names');
    }
    const squidName = nameAndVersion.split('@')[0];
    const versionName = nameAndVersion.split('@')[1];
    return { squidName, versionName };
}
exports.parseNameAndVersion = parseNameAndVersion;
//# sourceMappingURL=utils.js.map