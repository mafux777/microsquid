"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFtsQuery = exports.getObject = exports.getEntity = exports.propTypeEquals = exports.validateIndexes = exports.validateLookups = exports.validateUnionTypes = exports.validateNames = exports.validateModel = exports.buildUnionProps = exports.getUnionProps = void 0;
const assert_1 = __importDefault(require("assert"));
const UNION_MAPS = new WeakMap();
function getUnionProps(model, unionName) {
    let map = UNION_MAPS.get(model);
    if (map == null) {
        map = {};
        UNION_MAPS.set(model, map);
    }
    if (map[unionName])
        return map[unionName];
    return map[unionName] = buildUnionProps(model, unionName);
}
exports.getUnionProps = getUnionProps;
function buildUnionProps(model, unionName) {
    let union = model[unionName];
    (0, assert_1.default)(union.kind == 'union');
    let properties = {};
    for (let i = 0; i < union.variants.length; i++) {
        let objectName = union.variants[i];
        let object = model[objectName];
        (0, assert_1.default)(object.kind == 'object');
        Object.assign(properties, object.properties);
    }
    properties.isTypeOf = {
        type: { kind: 'scalar', name: 'String' },
        nullable: false
    };
    return { kind: 'object', properties };
}
exports.buildUnionProps = buildUnionProps;
function validateModel(model) {
    // TODO: check all invariants we assume
    validateNames(model);
    validateUnionTypes(model);
    validateLookups(model);
    validateIndexes(model);
}
exports.validateModel = validateModel;
const TYPE_NAME_REGEX = /^[A-Z][a-zA-Z0-9]*$/;
const PROP_NAME_REGEX = /^[a-z][a-zA-Z0-9]*$/;
function validateNames(model) {
    for (let name in model) {
        let item = model[name];
        if (item.kind == 'fts') {
            if (!PROP_NAME_REGEX.test(name)) {
                throw new Error(`Invalid fulltext search name: ${name}. It must match ${PROP_NAME_REGEX}.`);
            }
        }
        else {
            if (!TYPE_NAME_REGEX.test(name)) {
                throw new Error(`Invalid ${item.kind} name: ${name}. It must match ${TYPE_NAME_REGEX}`);
            }
        }
        switch (item.kind) {
            case 'entity':
            case 'object':
            case 'interface':
                for (let prop in item.properties) {
                    if (!PROP_NAME_REGEX.test(prop)) {
                        throw new Error(`Type ${name} has a property with invalid name: ${prop}. It must match ${PROP_NAME_REGEX}.`);
                    }
                }
                break;
        }
    }
}
exports.validateNames = validateNames;
function validateUnionTypes(model) {
    for (let key in model) {
        let item = model[key];
        if (item.kind != 'union')
            continue;
        let properties = {};
        item.variants.forEach(objectName => {
            let object = model[objectName];
            (0, assert_1.default)(object.kind == 'object');
            for (let propName in object.properties) {
                let rec = properties[propName];
                if (rec && !propTypeEquals(rec.type, object.properties[propName].type)) {
                    throw new Error(`${rec.objectName} and ${objectName} variants of union ${key} both have property '${propName}', but types of ${rec.objectName}.${propName} and ${objectName}.${propName} are different.`);
                }
                else {
                    properties[propName] = { objectName, type: object.properties[propName].type };
                }
            }
        });
    }
}
exports.validateUnionTypes = validateUnionTypes;
function validateLookups(model) {
    for (let name in model) {
        let item = model[name];
        switch (item.kind) {
            case 'object':
            case 'interface':
                for (let key in item.properties) {
                    let prop = item.properties[key];
                    if (prop.type.kind == 'lookup' || prop.type.kind == 'list-lookup') {
                        throw invalidProperty(name, key, `lookups are only supported on entity types`);
                    }
                }
                break;
            case 'entity':
                for (let key in item.properties) {
                    let prop = item.properties[key];
                    if (prop.type.kind == 'lookup' && !prop.nullable) {
                        throw invalidProperty(name, key, 'one-to-one lookups must be nullable');
                    }
                    if (prop.type.kind == 'lookup' || prop.type.kind == 'list-lookup') {
                        let lookupEntity = getEntity(model, prop.type.entity);
                        let lookupProperty = lookupEntity.properties[prop.type.field];
                        if (lookupProperty?.type.kind != 'fk' || lookupProperty.type.foreignEntity != name) {
                            throw invalidProperty(name, key, `${prop.type.entity}.${prop.type.field} is not a foreign key pointing to ${name}`);
                        }
                        if (prop.type.kind == 'lookup' && !lookupProperty.unique) {
                            throw invalidProperty(name, key, `${prop.type.entity}.${prop.type.field} is not @unique`);
                        }
                    }
                }
                break;
        }
    }
}
exports.validateLookups = validateLookups;
function validateIndexes(model) {
    for (let name in model) {
        const item = model[name];
        if (item.kind != 'entity')
            continue;
        item.indexes?.forEach(index => {
            if (index.fields.length == 0)
                throw new Error(`Entity ${name} has an index without fields`);
            index.fields.forEach(f => {
                let prop = item.properties[f.name];
                if (prop == null)
                    throw new Error(`Entity ${name} doesn't have a property ${f.name}, but is a part of index`);
                switch (prop.type.kind) {
                    case "scalar":
                    case "enum":
                    case "fk":
                        break;
                    default:
                        throw new Error(`Property ${name}.${f.name} can't be a part of index`);
                }
            });
        });
    }
}
exports.validateIndexes = validateIndexes;
function invalidProperty(item, key, msg) {
    return new Error(`Invalid property ${item}.${key}: ${msg}`);
}
function propTypeEquals(a, b) {
    if (a.kind != b.kind)
        return false;
    if (a.kind == 'list')
        return propTypeEquals(a.item.type, b.item.type);
    switch (a.kind) {
        case 'fk':
            return a.foreignEntity == b.foreignEntity;
        case 'lookup':
        case 'list-lookup':
            return a.entity == b.entity && a.field == b.field;
        default:
            return a.name == b.name;
    }
}
exports.propTypeEquals = propTypeEquals;
function getEntity(model, name) {
    let entity = model[name];
    (0, assert_1.default)(entity.kind == 'entity', `${name} expected to be an entity`);
    return entity;
}
exports.getEntity = getEntity;
function getObject(model, name) {
    let object = model[name];
    (0, assert_1.default)(object.kind == 'object', `${name} expected to be an object`);
    return object;
}
exports.getObject = getObject;
function getFtsQuery(model, name) {
    let query = model[name];
    (0, assert_1.default)(query.kind == 'fts', `${name} expected to be FTS query`);
    return query;
}
exports.getFtsQuery = getFtsQuery;
//# sourceMappingURL=model.tools.js.map