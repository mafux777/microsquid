"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildResolvers = void 0;
const util_1 = require("@subsquid/util");
const apollo_server_core_1 = require("apollo-server-core");
const assert_1 = __importDefault(require("assert"));
const scalars_1 = require("./gql/scalars");
const queryBuilder_1 = require("./queryBuilder");
const relayConnection_1 = require("./relayConnection");
const requestedFields_1 = require("./requestedFields");
const util_2 = require("./util");
function buildResolvers(model, dialect) {
    let Query = {};
    let resolvers = { Query, ...scalars_1.customScalars };
    for (let name in model) {
        let item = model[name];
        switch (item.kind) {
            case 'entity':
                Query[(0, util_2.toQueryListField)(name)] = async (source, args, context, info) => {
                    let fields = (0, requestedFields_1.requestedFields)(model, name, info);
                    let db = await context.openReaderTransaction.get();
                    return new queryBuilder_1.QueryBuilder(model, dialect, db).executeSelect(name, args, fields);
                };
                Query[(0, util_2.toQueryListField)(name) + 'Connection'] = async (source, args, context, info) => {
                    let db = await context.openReaderTransaction.get();
                    return resolveEntityConnection(model, dialect, name, args, info, db);
                };
                Query[`${(0, util_1.toCamelCase)(name)}ById`] = async (source, args, context, info) => {
                    let fields = (0, requestedFields_1.requestedFields)(model, name, info);
                    let db = await context.openReaderTransaction.get();
                    let result = await new queryBuilder_1.QueryBuilder(model, dialect, db)
                        .executeSelect(name, { where: { id_eq: args.id } }, fields);
                    (0, assert_1.default)(result.length < 2);
                    return result[0];
                };
                Query[`${(0, util_1.toCamelCase)(name)}ByUniqueInput`] = async (source, args, context, info) => {
                    let fields = (0, requestedFields_1.requestedFields)(model, name, info);
                    let db = await context.openReaderTransaction.get();
                    let result = await new queryBuilder_1.QueryBuilder(model, dialect, db)
                        .executeSelect(name, { where: { id_eq: args.where.id } }, fields);
                    (0, assert_1.default)(result.length < 2);
                    return result[0];
                };
                installFieldResolvers(name, item);
                break;
            case 'object':
                installFieldResolvers(name, item);
                break;
            case 'union':
                resolvers[name] = {
                    __resolveType: resolveUnionType
                };
                break;
            case 'fts':
                Query[name] = async (source, args, context, info) => {
                    let fields = (0, requestedFields_1.ftsRequestedFields)(model, name, info);
                    let db = await context.openReaderTransaction.get();
                    return new queryBuilder_1.QueryBuilder(model, dialect, db).executeFulltextSearch(name, args, fields);
                };
                resolvers[`${name}_Item`] = {
                    __resolveType: resolveUnionType
                };
                break;
        }
    }
    function installFieldResolvers(name, object) {
        let fields = {};
        for (let key in object.properties) {
            let kind = object.properties[key].type.kind;
            switch (kind) {
                case 'object':
                case 'union':
                case 'fk':
                case 'lookup':
                case 'list-lookup':
                    fields[key] = aliasResolver;
                    break;
                case 'scalar':
                case 'enum':
                case 'list':
                    break;
                default:
                    throw (0, util_2.unsupportedCase)(kind);
            }
        }
        resolvers[name] = fields;
    }
    return resolvers;
}
exports.buildResolvers = buildResolvers;
function resolveUnionType(source) {
    return source.isTypeOf;
}
function aliasResolver(source, args, ctx, info) {
    return source[info.path.key];
}
async function resolveEntityConnection(model, dialect, entityName, args, info, db) {
    let response = {};
    let orderBy = args.orderBy && (0, util_2.ensureArray)(args.orderBy);
    if (!orderBy?.length) {
        throw new apollo_server_core_1.UserInputError('orderBy argument is required for connection');
    }
    let { offset, limit } = (0, relayConnection_1.decodeConnectionArgs)(args);
    let listArgs = {
        where: args.where,
        orderBy,
        offset,
        limit: limit + 1
    };
    // https://relay.dev/assets/files/connections-932f4f2cdffd79724ac76373deb30dc8.htm#sec-undefined.PageInfo.Fields
    function pageInfo(listLength) {
        return {
            hasNextPage: listLength > limit,
            hasPreviousPage: listLength > 0 && offset > 0,
            startCursor: listLength > 0 ? (0, relayConnection_1.encodeCursor)(offset + 1) : '',
            endCursor: listLength > 0 ? (0, relayConnection_1.encodeCursor)(offset + Math.min(limit, listLength)) : ''
        };
    }
    let fields = (0, requestedFields_1.connectionRequestedFields)(model, entityName, info);
    if (fields.edges?.node) {
        let nodes = await new queryBuilder_1.QueryBuilder(model, dialect, db).executeSelect(entityName, listArgs, fields.edges.node);
        let edges = new Array(Math.min(limit, nodes.length));
        for (let i = 0; i < edges.length; i++) {
            edges[i] = {
                node: nodes[i],
                cursor: (0, relayConnection_1.encodeCursor)(offset + i + 1)
            };
        }
        response.edges = edges;
        response.pageInfo = pageInfo(nodes.length);
        if (nodes.length > 0 && nodes.length <= limit) {
            response.totalCount = offset + nodes.length;
        }
    }
    else if (fields.edges?.cursor || fields.pageInfo) {
        let listLength = await new queryBuilder_1.QueryBuilder(model, dialect, db).executeListCount(entityName, listArgs);
        response.pageInfo = pageInfo(listLength);
        if (fields.edges?.cursor) {
            response.edges = [];
            for (let i = 0; i < Math.min(limit, listLength); i++) {
                response.edges.push({
                    cursor: (0, relayConnection_1.encodeCursor)(offset + i + 1)
                });
            }
        }
        if (listLength > 0 && listLength <= limit) {
            response.totalCount = offset + listLength;
        }
    }
    if (fields.totalCount && response.totalCount == null) {
        response.totalCount = await new queryBuilder_1.QueryBuilder(model, dialect, db).executeSelectCount(entityName, listArgs.where);
    }
    return response;
}
//# sourceMappingURL=resolver.js.map