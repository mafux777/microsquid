import { Database } from "./db";
import type { Dialect } from "./dialect";
import type { Model } from "./model";
import { OpenCrudOrderByValue } from "./orderBy";
import type { FtsRequestedFields, RequestedFields } from "./requestedFields";
export interface ListArgs {
    offset?: number;
    limit?: number;
    orderBy?: OpenCrudOrderByValue[];
    where?: any;
}
export declare class QueryBuilder {
    private model;
    private dialect;
    private db;
    private params;
    private aliases;
    constructor(model: Model, dialect: Dialect, db: Database);
    private param;
    private ident;
    select(entityName: string, args: ListArgs, fields?: RequestedFields, variant?: SelectVariant): string;
    private populateOrderBy;
    private populateColumns;
    private generateWhere;
    private addPropCondition;
    toResult(rows: any[][], fields?: RequestedFields): any[];
    private mapRow;
    executeSelect(entityName: string, args: ListArgs, fields$: RequestedFields): Promise<any[]>;
    executeSelectCount(entityName: string, where?: any): Promise<number>;
    executeListCount(entityName: string, args: ListArgs): Promise<number>;
    private query;
    fulltextSearchSelect(queryName: string, args: any, $fields: FtsRequestedFields): string;
    toFulltextSearchResult(rows: any[][], fields: FtsRequestedFields): FtsItem[];
    executeFulltextSearch(queryName: string, args: any, $fields: FtsRequestedFields): Promise<FtsItem[]>;
}
export interface FtsItem {
    rank?: number;
    highlight?: string;
    item?: any;
}
declare type SelectVariant = FtsVariant | ListSubquery;
interface FtsVariant {
    kind: 'fts';
    queryName: string;
    textParam: string;
}
/**
 * SELECT json_build_array(...fields) FROM ... WHERE {toFkColumn(field)} = {parent}
 */
interface ListSubquery {
    kind: 'list-subquery';
    field: string;
    parent: string;
}
export {};
//# sourceMappingURL=queryBuilder.d.ts.map