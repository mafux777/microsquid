"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryBuilder = void 0;
const util_1 = require("@subsquid/util");
const assert_1 = __importDefault(require("assert"));
const model_tools_1 = require("./model.tools");
const orderBy_1 = require("./orderBy");
const util_2 = require("./util");
const where_1 = require("./where");
class QueryBuilder {
    constructor(model, dialect, db) {
        this.model = model;
        this.dialect = dialect;
        this.db = db;
        this.params = [];
        this.aliases = new AliasSet();
    }
    param(value) {
        return '$' + this.params.push(value);
    }
    ident(name) {
        return this.db.escapeIdentifier(name);
    }
    select(entityName, args, fields, variant) {
        let entity = (0, model_tools_1.getEntity)(this.model, entityName);
        let table = (0, util_2.toTable)(entityName);
        let alias = this.aliases.add(table);
        let join = new JoinSet(this.aliases);
        let cursor = new Cursor(this.model, this.dialect, this.ident.bind(this), this.aliases, join, entityName, entity, alias, '');
        let whereExps = [];
        let orderByExps = [];
        let columns = new ColumnSet();
        let out = '';
        if (fields) {
            this.populateColumns(columns, cursor, fields);
        }
        switch (variant?.kind) {
            case 'fts':
                out += 'SELECT\n';
                out += `    '${entityName}' AS isTypeOf`;
                out += ',\n';
                out += `    ts_rank(${cursor.tsv(variant.queryName)}, phraseto_tsquery('english', ${variant.textParam})) AS rank`;
                out += ',\n';
                out += `    ts_headline(${cursor.doc(variant.queryName)}, phraseto_tsquery('english', ${variant.textParam})) AS highlight`;
                out += ',\n';
                out += columns.size() ? `    json_build_array(${columns.render()})` : "    '[]'::json";
                out += ' AS item\n';
                break;
            case 'list-subquery':
                if (columns.size()) {
                    out += `SELECT json_build_array(${columns.render()}) AS row `;
                }
                break;
            default:
                if (columns.size()) {
                    out += `SELECT ${columns.render(true)}\n`;
                }
        }
        out += `FROM ${this.ident(table)} ${this.ident(alias)}`;
        if ((0, where_1.hasConditions)(args.where)) {
            whereExps.push(this.generateWhere(cursor, args.where));
        }
        if (variant?.kind == 'list-subquery') {
            whereExps.push(`${cursor.fk(variant.field)} = ${variant.parent}`);
        }
        if (variant?.kind == 'fts') {
            whereExps.push(`phraseto_tsquery('english', ${variant.textParam}) @@ ${cursor.tsv(variant.queryName)}`);
        }
        let orderByInput = args.orderBy && (0, util_2.ensureArray)(args.orderBy);
        if (orderByInput?.length) {
            let orderBy = (0, orderBy_1.parseOrderBy)(this.model, entityName, orderByInput);
            this.populateOrderBy(orderByExps, cursor, orderBy);
        }
        join.forEach(j => {
            let table = this.ident(j.table);
            let alias = this.ident(j.alias);
            out += `\nLEFT OUTER JOIN ${table} ${alias} ON ${alias}.${j.column} = ${j.rhs}`;
        });
        if (whereExps.length) {
            out += '\nWHERE ' + whereExps.join(' AND ');
        }
        if (orderByExps.length > 0) {
            out += '\nORDER BY ' + orderByExps.join(', ');
        }
        if (args.limit) {
            out += '\nLIMIT ' + this.param(args.limit);
        }
        if (args.offset) {
            out += '\nOFFSET ' + this.param(args.offset);
        }
        if (variant?.kind == 'list-subquery') {
            out = out.replace(/\n/g, ' ');
        }
        return out;
    }
    populateOrderBy(exps, cursor, orderBy) {
        for (let key in orderBy) {
            let spec = orderBy[key];
            let propType = cursor.object.properties[key].type;
            switch (propType.kind) {
                case 'scalar':
                case 'enum':
                    (0, assert_1.default)(typeof spec == 'string');
                    exps.push(`${cursor.native(key)} ${spec}`);
                    break;
                case 'object':
                case 'union':
                case 'fk':
                case 'lookup':
                    (0, assert_1.default)(typeof spec == 'object');
                    this.populateOrderBy(exps, cursor.child(key), spec);
                    break;
                default:
                    throw (0, util_2.unsupportedCase)(propType.kind);
            }
        }
    }
    populateColumns(columns, cursor, fields$) {
        for (let fieldName in fields$) {
            let field = fields$[fieldName];
            for (let i = 0; i < field.requests.length; i++) {
                let req = field.requests[i];
                switch (field.propType.kind) {
                    case 'scalar':
                    case 'enum':
                    case 'list':
                        req.index = columns.add(cursor.output(fieldName));
                        break;
                    case 'object':
                        req.index = columns.add(cursor.field(fieldName) + ' IS NULL');
                        this.populateColumns(columns, cursor.child(fieldName), req.children);
                        break;
                    case 'union':
                        let cu = cursor.child(fieldName);
                        req.index = columns.add(cu.output('isTypeOf'));
                        this.populateColumns(columns, cu, req.children);
                        break;
                    case 'fk':
                    case 'lookup': {
                        let cu = cursor.child(fieldName);
                        req.index = columns.add(cu.output('id'));
                        this.populateColumns(columns, cu, req.children);
                        break;
                    }
                    case 'list-lookup':
                        req.index = columns.add('(SELECT jsonb_agg(row) FROM (' + this.select(field.propType.entity, req.args, req.children, {
                            kind: 'list-subquery',
                            field: field.propType.field,
                            parent: cursor.native('id')
                        }) + ') as rows)');
                        break;
                    default:
                        throw (0, util_2.unsupportedCase)(field.propType.kind);
                }
            }
        }
    }
    generateWhere(cursor, where) {
        let { AND, OR, ...conditions } = where;
        let exps = [];
        for (let key in conditions) {
            let opArg = conditions[key];
            let f = (0, where_1.parseWhereField)(key);
            switch (f.op) {
                case 'every':
                    if ((0, where_1.hasConditions)(opArg)) {
                        let rel = cursor.object.properties[f.field].type;
                        (0, assert_1.default)(rel.kind == 'list-lookup');
                        let conditionedFrom = this.select(rel.entity, { where: opArg }, undefined, { kind: 'list-subquery', parent: cursor.native('id'), field: rel.field });
                        let allFrom = this.select(rel.entity, {}, undefined, { kind: 'list-subquery', parent: cursor.native('id'), field: rel.field });
                        exps.push(`(SELECT count(*) ${conditionedFrom}) = (SELECT count(*) ${allFrom})`);
                    }
                    break;
                case 'some':
                case 'none':
                    let rel = cursor.object.properties[f.field].type;
                    (0, assert_1.default)(rel.kind == 'list-lookup');
                    let q = '(SELECT true ' + this.select(rel.entity, { where: opArg }, undefined, { kind: 'list-subquery', parent: cursor.native('id'), field: rel.field }) + ' LIMIT 1)';
                    if (f.op == 'some') {
                        exps.push(q);
                    }
                    else {
                        exps.push(`(SELECT count(*) FROM ${q} ${this.ident(this.aliases.add(key))}) = 0`);
                    }
                    break;
                default: {
                    let prop = cursor.object.properties[f.field];
                    (0, assert_1.default)(prop != null);
                    this.addPropCondition(exps, cursor, f.field, f.op, opArg);
                }
            }
        }
        if (AND) {
            // We are getting objects here, although we have array in schema
            (0, util_2.ensureArray)(AND).forEach((andWhere) => {
                if ((0, where_1.hasConditions)(andWhere)) {
                    exps.push(this.generateWhere(cursor, andWhere));
                }
            });
        }
        if (OR) {
            let ors = [];
            if (exps.length) {
                ors.push('(' + exps.join(' AND ') + ')');
            }
            // We are getting objects here, although we have array in schema
            (0, util_2.ensureArray)(OR).forEach((orWhere) => {
                if ((0, where_1.hasConditions)(orWhere)) {
                    ors.push('(' + this.generateWhere(cursor, orWhere) + ')');
                }
            });
            return '(' + ors.join(' OR ') + ')';
        }
        else {
            return exps.join(' AND ');
        }
    }
    addPropCondition(exps, cursor, field, op, arg) {
        let propType = cursor.object.properties[field].type;
        if (op == 'isNull') {
            let lhs = propType.kind == 'fk' ? cursor.fk(field) : cursor.field(field);
            if (arg) {
                exps.push(`${lhs} IS NULL`);
            }
            else {
                exps.push(`${lhs} IS NOT NULL`);
            }
            return;
        }
        switch (propType.kind) {
            case 'scalar':
            case 'enum': {
                let lhs = cursor.native(field);
                switch (op) {
                    case 'in':
                    case 'not_in': {
                        // We have 2 options here
                        // 1. use array parameter and do: WHERE col IN (SELECT * FROM unnest($array_param))
                        // 2. use arg list
                        // Let's try second option first.
                        let list = (0, util_2.ensureArray)(arg).map(a => this.param(a));
                        let param = `(${list.join(', ')})`;
                        exps.push(`${lhs} ${(0, where_1.whereOpToSqlOperator)(op)} ${param}`);
                        break;
                    }
                    case 'startsWith':
                        if (this.dialect == 'cockroach') {
                            let p = this.param(arg) + '::text';
                            exps.push(`${lhs} >= ${p}`);
                            exps.push(`left(${lhs}, length(${p})) = ${p}`);
                        }
                        else {
                            exps.push(`starts_with(${lhs}, ${this.param(arg)})`);
                        }
                        break;
                    case 'not_startsWith':
                        if (this.dialect == 'cockroach') {
                            let p = this.param(arg) + '::text';
                            exps.push(`(${lhs} < ${p} OR left(${lhs}, length(${p})) != ${p})`);
                        }
                        else {
                            exps.push(`NOT starts_with(${lhs}, ${this.param(arg)})`);
                        }
                        break;
                    case 'endsWith': {
                        let param = this.param(arg) + '::text';
                        exps.push(`right(${lhs}, length(${param})) = ${param}`);
                        break;
                    }
                    case 'not_endsWith': {
                        let param = this.param(arg) + '::text';
                        exps.push(`right(${lhs}, length(${param})) != ${param}`);
                        break;
                    }
                    case 'contains':
                        exps.push(`position(${this.param(arg)} in ${lhs}) > 0`);
                        break;
                    case 'not_contains':
                        exps.push(`position(${this.param(arg)} in ${lhs}) = 0`);
                        break;
                    case 'containsInsensitive':
                        exps.push(`position(lower(${this.param(arg)}) in lower(${lhs})) > 0`);
                        break;
                    case 'not_containsInsensitive':
                        exps.push(`position(lower(${this.param(arg)}) in lower(${lhs})) = 0`);
                        break;
                    default: {
                        exps.push(`${lhs} ${(0, where_1.whereOpToSqlOperator)(op)} ${this.param(arg)}`);
                    }
                }
                break;
            }
            case 'list': {
                let item = propType.item.type;
                (0, assert_1.default)(item.kind == 'scalar' || item.kind == 'enum');
                let param = this.param(arg);
                let lhs = cursor.native(field);
                switch (op) {
                    case 'containsAll':
                        exps.push(`${lhs} @> ${param}`);
                        break;
                    case 'containsAny':
                        exps.push(`${lhs} && ${param}`);
                        break;
                    case 'containsNone':
                        exps.push(`NOT (${lhs} && ${param})`);
                        break;
                    default:
                        throw (0, util_2.unsupportedCase)(op);
                }
                break;
            }
            case 'object':
            case 'union': {
                (0, assert_1.default)(op == '-');
                let cu = cursor.child(field);
                for (let key in arg) {
                    let f = (0, where_1.parseWhereField)(key);
                    this.addPropCondition(exps, cu, f.field, f.op, arg[key]);
                }
                break;
            }
            case 'fk':
            case 'lookup': {
                (0, assert_1.default)(op == '-');
                if ((0, where_1.hasConditions)(arg)) {
                    exps.push(this.generateWhere(cursor.child(field), arg));
                }
                break;
            }
            default:
                throw (0, util_2.unsupportedCase)(propType.kind);
        }
    }
    toResult(rows, fields) {
        let out = new Array(rows.length);
        for (let i = 0; i < rows.length; i++) {
            out[i] = this.mapRow(rows[i], fields);
        }
        return out;
    }
    mapRow(row, fields, ifType) {
        let rec = {};
        for (let key in fields) {
            let f = fields[key];
            for (let i = 0; i < f.requests.length; i++) {
                let req = f.requests[i];
                if (req.ifType != ifType)
                    continue;
                switch (f.propType.kind) {
                    case 'scalar':
                    case 'enum':
                    case 'list':
                        rec[req.alias] = row[req.index];
                        break;
                    case 'object': {
                        let isNull = row[req.index];
                        if (!isNull) {
                            rec[req.alias] = this.mapRow(row, req.children);
                        }
                        break;
                    }
                    case 'union': {
                        let isTypeOf = row[req.index];
                        if (isTypeOf != null) {
                            let obj = this.mapRow(row, req.children, isTypeOf);
                            obj.isTypeOf = isTypeOf;
                            rec[req.alias] = obj;
                        }
                        break;
                    }
                    case 'fk':
                    case 'lookup': {
                        let id = row[req.index];
                        if (id != null) {
                            rec[req.alias] = this.mapRow(row, req.children);
                        }
                        break;
                    }
                    case 'list-lookup':
                        rec[req.alias] = this.toResult(row[req.index], req.children);
                        break;
                    default:
                        throw (0, util_2.unsupportedCase)(f.propType.kind);
                }
            }
        }
        return rec;
    }
    async executeSelect(entityName, args, fields$) {
        let sql = this.select(entityName, args, fields$);
        let rows = await this.query(sql);
        return this.toResult(rows, fields$);
    }
    async executeSelectCount(entityName, where) {
        let sql = `SELECT count(*) ${this.select(entityName, { where })}`;
        let rows = await this.query(sql);
        return (0, util_2.toInt)(rows[0][0]);
    }
    async executeListCount(entityName, args) {
        let sql = `SELECT count(*) FROM (SELECT true ${this.select(entityName, args)}) AS ${this.aliases.add('list')}`;
        let rows = await this.query(sql);
        return (0, util_2.toInt)(rows[0][0]);
    }
    query(sql) {
        return this.db.query(sql, this.params);
    }
    fulltextSearchSelect(queryName, args, $fields) {
        let query = (0, model_tools_1.getFtsQuery)(this.model, queryName);
        let { limit, offset, text } = args;
        let textParam = this.param(text);
        let srcSelects = [];
        query.sources.forEach(src => {
            let where = args[`where${src.entity}`];
            let itemFields = $fields.item?.[src.entity];
            let sql = this.select(src.entity, { where }, itemFields, { kind: 'fts', textParam, queryName });
            srcSelects.push(sql);
        });
        let cols = [];
        cols.push('isTypeOf');
        cols.push('rank');
        if ($fields.highlight) {
            cols.push('highlight');
        }
        if ($fields.item) {
            cols.push('item');
        }
        let sql = `SELECT ${cols.join(', ')} FROM (\n\n`;
        sql += srcSelects.join('\n\nUNION ALL\n\n');
        sql += `\n\n) AS ${this.aliases.add('tsv')}`;
        sql += ` ORDER BY rank DESC`;
        if (limit != null) {
            sql += ` LIMIT ${this.param(limit)}`;
        }
        if (offset != null) {
            sql += ` OFFSET ${this.param(offset)}`;
        }
        return sql;
    }
    toFulltextSearchResult(rows, fields) {
        let out = new Array(rows.length);
        for (let i = 0; i < rows.length; i++) {
            let row = rows[i];
            let isTypeOf = row[0];
            let highlight = fields.highlight ? row[2] : undefined;
            let itemIdx = fields.highlight ? 3 : 2;
            let itemFields = fields.item?.[isTypeOf];
            let item;
            if (itemFields) {
                item = this.mapRow(row[itemIdx], itemFields);
                item.isTypeOf = isTypeOf;
            }
            else {
                item = { isTypeOf };
            }
            out[i] = {
                rank: row[1],
                highlight,
                item
            };
        }
        return out;
    }
    async executeFulltextSearch(queryName, args, $fields) {
        let sql = this.fulltextSearchSelect(queryName, args, $fields);
        let rows = await this.query(sql);
        return this.toFulltextSearchResult(rows, $fields);
    }
}
exports.QueryBuilder = QueryBuilder;
/**
 * A pointer to an entity or nested json object within SQL query.
 *
 * It has convenience methods for building various SQL expressions
 * related to individual properties of an entity or of an object it points to.
 */
class Cursor {
    constructor(model, dialect, ident, aliases, join, name, object, alias, prefix) {
        this.model = model;
        this.dialect = dialect;
        this.ident = ident;
        this.aliases = aliases;
        this.join = join;
        this.name = name;
        this.object = object;
        this.alias = alias;
        this.prefix = prefix;
    }
    output(propName) {
        let prop = this.object.properties[propName];
        switch (prop.type.kind) {
            case 'scalar':
                if (this.object.kind == 'object') {
                    switch (prop.type.name) {
                        case 'Int':
                            return `(${this.prefix}->'${propName}')::integer`;
                        case 'Float':
                            return `(${this.prefix}->'${propName}')::numeric`;
                        case 'Boolean':
                            return `(${this.prefix}->>'${propName}')::bool`;
                        default:
                            return `${this.prefix}->>'${propName}'`;
                    }
                }
                else {
                    let exp = this.column(propName);
                    switch (prop.type.name) {
                        case 'BigInt':
                            return `(${exp})::text`;
                        case 'Bytes':
                            return `'0x' || encode(${exp}, 'hex')`;
                        case 'DateTime':
                            if (this.dialect == 'cockroach') {
                                return `experimental_strftime((${exp}) at time zone 'UTC', '%Y-%m-%dT%H:%M:%S.%fZ')`;
                            }
                            else {
                                return `to_char((${exp}) at time zone 'UTC', 'YYYY-MM-DD"T"HH24:MI:SS.US"Z"')`;
                            }
                        default:
                            return exp;
                    }
                }
            case 'enum':
                if (this.object.kind == 'object') {
                    return `${this.prefix}->>'${propName}'`;
                }
                else {
                    return this.column(propName);
                }
            case 'list':
                let itemType = prop.type.item.type;
                if (this.object.kind == 'object' || itemType.kind != 'scalar' && itemType.kind != 'enum') {
                    // this is json
                    return this.field(propName);
                }
                else {
                    let exp = this.column(propName);
                    switch (itemType.name) {
                        case 'BigInt':
                            return `(${exp})::text[]`;
                        case 'Bytes':
                            return `array(select '0x' || encode(i, 'hex') from unnest(${exp}) as i)`;
                        case 'DateTime':
                            if (this.dialect == 'cockroach') {
                                return `array(select experimental_strftime(i at time zone 'UTC', '%Y-%m-%dT%H:%M:%S.%fZ') from unnest(${exp}) as i)`;
                            }
                            else {
                                return `array(select to_char(i at time zone 'UTC', 'YYYY-MM-DD"T"HH24:MI:SS.US"Z"') from unnest(${exp}) as i)`;
                            }
                        default:
                            return exp;
                    }
                }
            default:
                throw (0, util_2.unsupportedCase)(prop.type.kind);
        }
    }
    native(propName) {
        let prop = this.object.properties[propName];
        if (prop.type.kind == 'list') {
            let item = prop.type.item.type;
            (0, assert_1.default)(item.kind == 'scalar' || item.kind == 'enum');
            return this.column(propName);
        }
        (0, assert_1.default)(prop.type.kind == 'scalar' || prop.type.kind == 'enum');
        if (this.object.kind == 'object') {
            let js = `${this.prefix}->'${propName}'`;
            let str = `${this.prefix}->>'${propName}'`;
            switch (prop.type.name) {
                case 'Int':
                    return `(${js})::integer`;
                case 'Float':
                    return `(${js})::numeric`;
                case 'Boolean':
                    return `(${str})::bool`;
                case 'BigInt':
                    return `(${str})::numeric`;
                case 'Bytes':
                    return `decode(substr(${str}, 3), 'hex')`;
                case 'DateTime':
                    return `(${str})::timestamptz`;
                default:
                    return str;
            }
        }
        else {
            return this.column(propName);
        }
    }
    child(propName) {
        let name;
        let object;
        let alias;
        let prefix;
        let prop = this.object.properties[propName];
        switch (prop.type.kind) {
            case 'object':
                name = prop.type.name;
                object = (0, model_tools_1.getObject)(this.model, name);
                alias = this.alias;
                prefix = this.field(propName);
                break;
            case 'union':
                name = prop.type.name;
                object = (0, model_tools_1.getUnionProps)(this.model, name);
                alias = this.alias;
                prefix = this.field(propName);
                break;
            case 'fk':
                name = prop.type.foreignEntity;
                object = (0, model_tools_1.getEntity)(this.model, name);
                alias = this.join.add((0, util_2.toTable)(name), '"id"', this.fk(propName));
                prefix = '';
                break;
            case 'lookup':
                name = prop.type.entity;
                object = (0, model_tools_1.getEntity)(this.model, name);
                alias = this.join.add((0, util_2.toTable)(name), this.ident((0, util_2.toFkColumn)(prop.type.field)), this.field('id'));
                prefix = '';
                break;
            default:
                throw (0, util_2.unsupportedCase)(prop.type.kind);
        }
        return new Cursor(this.model, this.dialect, this.ident, this.aliases, this.join, name, object, alias, prefix);
    }
    field(name) {
        if (this.object.kind == 'entity') {
            return this.column(name);
        }
        else {
            return `${this.prefix}->'${name}'`;
        }
    }
    column(name) {
        (0, assert_1.default)(this.object.kind == 'entity');
        return this.ident(this.alias) + '.' + this.ident((0, util_2.toColumn)(name));
    }
    fk(propName) {
        return this.object.kind == 'entity'
            ? this.ident(this.alias) + '.' + this.ident((0, util_2.toFkColumn)(propName))
            : `${this.prefix}->>'${propName}'`;
    }
    tsv(queryName) {
        (0, assert_1.default)(this.object.kind == 'entity');
        return this.ident(this.alias) + '.' + this.ident((0, util_1.toSnakeCase)(queryName) + '_tsv');
    }
    doc(queryName) {
        (0, assert_1.default)(this.object.kind == 'entity');
        let query = (0, model_tools_1.getFtsQuery)(this.model, queryName);
        let src = query.sources.find(src => src.entity == this.name);
        (0, assert_1.default)(src != null);
        return src.fields.map(f => `coalesce(${this.field(f)}, '')`).join(` || E'\\n\\n' || `);
    }
}
class ColumnSet {
    constructor() {
        this.columns = new Map();
    }
    add(column) {
        let idx = this.columns.get(column);
        if (idx == null) {
            idx = this.columns.size;
            this.columns.set(column, idx);
        }
        return idx;
    }
    render(withAliases) {
        let cols = Array.from(this.columns.keys());
        if (withAliases) {
            cols = cols.map((col, idx) => `${col} AS _c${idx}`);
        }
        return cols.join(', ');
    }
    size() {
        return this.columns.size;
    }
}
class JoinSet {
    constructor(aliases) {
        this.aliases = aliases;
        this.joins = new Map();
    }
    add(table, column, rhs) {
        let key = `${table} ${column} ${rhs}`;
        let e = this.joins.get(key);
        if (!e) {
            e = {
                table,
                alias: this.aliases.add(table),
                column,
                rhs
            };
            this.joins.set(key, e);
        }
        return e.alias;
    }
    forEach(cb) {
        this.joins.forEach(join => cb(join));
    }
}
class AliasSet {
    constructor() {
        this.aliases = {};
    }
    add(name) {
        if (this.aliases[name]) {
            return name + '_' + (this.aliases[name]++);
        }
        else {
            this.aliases[name] = 1;
            return name;
        }
    }
}
//# sourceMappingURL=queryBuilder.js.map