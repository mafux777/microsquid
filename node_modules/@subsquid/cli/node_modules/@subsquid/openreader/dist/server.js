"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupGraphiqlConsole = exports.listen = exports.serve = void 0;
const apollo_server_core_1 = require("apollo-server-core");
const apollo_server_express_1 = require("apollo-server-express");
const assert_1 = __importDefault(require("assert"));
const express_1 = __importDefault(require("express"));
const fs_1 = __importDefault(require("fs"));
const http_1 = __importDefault(require("http"));
const path_1 = __importDefault(require("path"));
const db_1 = require("./db");
const opencrud_1 = require("./gql/opencrud");
const resolver_1 = require("./resolver");
async function serve(options) {
    let { model, db } = options;
    let dialect = options.dialect ?? 'postgres';
    let resolvers = (0, resolver_1.buildResolvers)(model, dialect);
    let typeDefs = (0, opencrud_1.buildServerSchema)(model, dialect);
    let app = (0, express_1.default)();
    let server = http_1.default.createServer(app);
    let apollo = new apollo_server_express_1.ApolloServer({
        typeDefs,
        resolvers,
        context: () => ({ openReaderTransaction: new db_1.PoolTransaction(db) }),
        plugins: [
            {
                async requestDidStart() {
                    return {
                        willSendResponse(req) {
                            return req.context.openReaderTransaction.close();
                        }
                    };
                }
            },
            (0, apollo_server_core_1.ApolloServerPluginDrainHttpServer)({ httpServer: server })
        ]
    });
    if (options.graphiqlConsole !== false) {
        setupGraphiqlConsole(app);
    }
    await apollo.start();
    apollo.applyMiddleware({ app });
    return listen(apollo, server, options.port);
}
exports.serve = serve;
function listen(apollo, server, port) {
    return new Promise((resolve, reject) => {
        function onerror(err) {
            cleanup();
            reject(err);
        }
        function onlistening() {
            cleanup();
            let address = server.address();
            (0, assert_1.default)(address != null && typeof address == 'object');
            resolve({
                port: address.port,
                stop: () => apollo.stop()
            });
        }
        function cleanup() {
            server.removeListener('error', onerror);
            server.removeListener('listening', onlistening);
        }
        server.on('error', onerror);
        server.on('listening', onlistening);
        server.listen(port);
    });
}
exports.listen = listen;
function setupGraphiqlConsole(app) {
    let assets = path_1.default.join(require.resolve('@subsquid/graphiql-console/package.json'), '../build');
    let indexHtml = fs_1.default.readFileSync(path_1.default.join(assets, 'index.html'), 'utf-8')
        .replace(/\/static\//g, 'console/static/')
        .replace('/manifest.json', 'console/manifest.json')
        .replace('${GRAPHQL_API}', 'graphql')
        .replace('${APP_TITLE}', 'Query node playground');
    app.use('/console', express_1.default.static(assets));
    app.use('/graphql', (req, res, next) => {
        if (req.path != '/')
            return next();
        if (req.method != 'GET' && req.method != 'HEAD')
            return next();
        if (req.query['query'])
            return next();
        res.vary('Accept');
        if (!req.accepts('html'))
            return next();
        res.type('html').send(indexHtml);
    });
}
exports.setupGraphiqlConsole = setupGraphiqlConsole;
//# sourceMappingURL=server.js.map