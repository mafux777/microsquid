"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ftsRequestedFields = exports.connectionRequestedFields = exports.requestedFields = void 0;
const util_1 = require("@subsquid/util");
const apollo_server_core_1 = require("apollo-server-core");
const assert_1 = __importDefault(require("assert"));
const graphql_parse_resolve_info_1 = require("graphql-parse-resolve-info");
function requestedFields(model, entityName, info) {
    let tree = getResolveTree(info);
    return collectRequestedFields(model, entityName, info.schema, tree);
}
exports.requestedFields = requestedFields;
function collectRequestedFields(model, objectName, schema, tree) {
    let requested = {};
    let object = model[objectName];
    (0, assert_1.default)(object.kind == 'entity' || object.kind == 'object');
    let fields = simplifyResolveTree(schema, tree, objectName).fields;
    for (let alias in fields) {
        let f = fields[alias];
        let prop = object.properties[f.name];
        let propType = prop.type;
        switch (propType.kind) {
            case 'scalar':
            case 'enum':
            case 'list':
                requested[f.name] = {
                    propType,
                    requests: [{ alias: f.name, index: 0 }]
                };
                break;
            case 'object':
                addRequest(requested, f.name, propType, {
                    alias,
                    children: collectRequestedFields(model, propType.name, schema, f),
                    index: 0
                });
                break;
            case 'fk':
                addRequest(requested, f.name, propType, {
                    alias,
                    children: collectRequestedFields(model, propType.foreignEntity, schema, f),
                    index: 0
                });
                break;
            case 'lookup':
                addRequest(requested, f.name, propType, {
                    alias,
                    children: collectRequestedFields(model, propType.entity, schema, f),
                    index: 0
                });
                break;
            case 'list-lookup':
                addRequest(requested, f.name, propType, {
                    alias,
                    args: f.args,
                    children: collectRequestedFields(model, propType.entity, schema, f),
                    index: 0
                });
                break;
            case 'union': {
                let union = model[propType.name];
                (0, assert_1.default)(union.kind == 'union');
                let children = {};
                union.variants.forEach(name => {
                    let variantFields = collectRequestedFields(model, name, schema, f);
                    for (let key in variantFields) {
                        let field = variantFields[key];
                        field.requests.forEach(req => {
                            addRequest(children, key, field.propType, { ...req, ifType: name });
                        });
                    }
                });
                addRequest(requested, f.name, propType, {
                    alias,
                    children,
                    index: 0
                });
                break;
            }
            default:
                throw new Error(`Field ${objectName}.${f.name} has unsupported type and can't be requested`);
        }
    }
    return requested;
}
function addRequest(requested, name, propType, req) {
    let field = requested[name];
    if (field == null) {
        requested[name] = {
            propType,
            requests: [req]
        };
    }
    else {
        field.requests.push(req);
    }
}
function connectionRequestedFields(model, entityName, info) {
    let requested = {};
    let tree = getResolveTree(info, (0, util_1.toPlural)(entityName) + 'Connection');
    requested.totalCount = hasTreeRequest(tree.fields, 'totalCount');
    requested.pageInfo = hasTreeRequest(tree.fields, 'pageInfo');
    let edgesTree = getTreeRequest(tree.fields, 'edges');
    if (edgesTree) {
        let edgeFields = simplifyResolveTree(info.schema, edgesTree, entityName + 'Edge').fields;
        requested.edges = {};
        requested.edges.cursor = hasTreeRequest(edgeFields, 'cursor');
        let nodeTree = getTreeRequest(edgeFields, 'node');
        if (nodeTree) {
            requested.edges.node = collectRequestedFields(model, entityName, info.schema, nodeTree);
        }
    }
    return requested;
}
exports.connectionRequestedFields = connectionRequestedFields;
function ftsRequestedFields(model, queryName, info) {
    let query = model[queryName];
    (0, assert_1.default)(query.kind == 'fts');
    let requested = {};
    let tree = getResolveTree(info, queryName + '_Output');
    requested.rank = hasTreeRequest(tree.fields, 'rank');
    requested.highlight = hasTreeRequest(tree.fields, 'highlight');
    let itemTree = getTreeRequest(tree.fields, 'item');
    if (itemTree) {
        requested.item = {};
        for (let i = 0; i < query.sources.length; i++) {
            let entity = query.sources[i].entity;
            let fields = collectRequestedFields(model, entity, info.schema, itemTree);
            for (let key in fields) {
                requested.item[entity] = fields;
                break;
            }
        }
    }
    return requested;
}
exports.ftsRequestedFields = ftsRequestedFields;
function getTreeRequest(treeFields, fieldName) {
    let req;
    for (let alias in treeFields) {
        let e = treeFields[alias];
        if (e.name != fieldName)
            continue;
        if (req != null)
            throw new apollo_server_core_1.UserInputError(`multiple aliases for field '${fieldName}' are not supported`);
        req = e;
    }
    return req;
}
function hasTreeRequest(treeFields, fieldName) {
    for (let alias in treeFields) {
        let e = treeFields[alias];
        if (e.name == fieldName)
            return true;
    }
    return false;
}
function getResolveTree(info, typeName) {
    let tree = (0, graphql_parse_resolve_info_1.parseResolveInfo)(info);
    (0, assert_1.default)(isResolveTree(tree));
    if (typeName) {
        return simplifyResolveTree(info.schema, tree, typeName);
    }
    else {
        return tree;
    }
}
function simplifyResolveTree(schema, tree, typeName) {
    let type = schema.getType(typeName);
    (0, assert_1.default)(type != null);
    return (0, graphql_parse_resolve_info_1.simplifyParsedResolveInfoFragmentWithType)(tree, type);
}
function isResolveTree(resolveInfo) {
    return resolveInfo != null && resolveInfo.fieldsByTypeName != null;
}
//# sourceMappingURL=requestedFields.js.map