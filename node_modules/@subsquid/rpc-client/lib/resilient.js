"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResilientRpcClient = void 0;
const client_1 = require("./client");
class ResilientRpcClient {
    constructor(url) {
        this.url = url;
        this.errors = 0;
        this.delays = [0, 0, 500, 2000]; // 1 based array of delays
        this.closed = false;
        this.client = Promise.resolve(new client_1.RpcClient(url));
    }
    async call(method, params) {
        let epoch = this.client;
        let client = await this.client;
        try {
            let result = await client.call(method, params);
            this.errors = 0;
            return result;
        }
        catch (e) {
            if (e instanceof client_1.RpcConnectionError) {
                if (epoch === this.client) {
                    this.reconnect();
                }
                return this.call(method, params);
            }
            else {
                throw e;
            }
        }
    }
    reconnect() {
        if (this.closed)
            return;
        this.errors += 1;
        let delay = this.delays[this.errors];
        if (delay == null) {
            this.client = Promise.reject(new client_1.RpcConnectionError(`Got ${this.errors} connection errors in a row`));
        }
        else {
            this.client = new Promise(resolve => {
                setTimeout(() => {
                    resolve(new client_1.RpcClient(this.url));
                }, delay);
            });
        }
    }
    close(err) {
        if (this.closed)
            return;
        this.closed = true;
        this.client.then(client => client.close(err));
        this.client = Promise.reject(err || new Error('Closed'));
        this.client.catch(err => {
            // handle error, so that node doesn't warn you that something is unhandled
        });
    }
}
exports.ResilientRpcClient = ResilientRpcClient;
//# sourceMappingURL=resilient.js.map