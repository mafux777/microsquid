"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const merge_1 = require("@graphql-tools/merge");
const db_1 = require("@subsquid/openreader/dist/db");
const opencrud_1 = require("@subsquid/openreader/dist/gql/opencrud");
const resolver_1 = require("@subsquid/openreader/dist/resolver");
const server_1 = require("@subsquid/openreader/dist/server");
const tools_1 = require("@subsquid/openreader/dist/tools");
const util_1 = require("@subsquid/util");
const apollo_server_core_1 = require("apollo-server-core");
const apollo_server_express_1 = require("apollo-server-express");
const assert_1 = __importDefault(require("assert"));
const express_1 = __importDefault(require("express"));
const http = __importStar(require("http"));
const path = __importStar(require("path"));
const pg_1 = require("pg");
const process = __importStar(require("process"));
const check_1 = require("./check");
const typeorm_1 = require("./typeorm");
class Server {
    constructor(dir) {
        this.dir = path.resolve(dir || process.cwd());
    }
    path(name) {
        return path.join(this.dir, name);
    }
    run() {
        this.start().then(s => {
            console.log(`Squid graphql server is listening on port ${s.port}`);
        }, err => {
            console.error(err);
            process.exit(1);
        });
    }
    getPort() {
        return process.env.GQL_PORT || process.env.GRAPHQL_SERVER_PORT || 4000;
    }
    async start() {
        let app = this.app();
        let cfg = await this.config();
        let apollo = new apollo_server_express_1.ApolloServer(cfg);
        await apollo.start();
        try {
            (0, server_1.setupGraphiqlConsole)(app);
            apollo.applyMiddleware({ app });
            return await (0, server_1.listen)(apollo, this.httpServer(), this.getPort());
        }
        catch (e) {
            await apollo.stop().catch(err => {
                e = new Error(e.stack + '\n\n' + err.stack);
            });
            throw e;
        }
    }
    app() {
        return (0, express_1.default)();
    }
    httpServer() {
        return http.createServer(this.app());
    }
    async config() {
        let plugins = [];
        let typeDefs = [(0, opencrud_1.buildServerSchema)(this.model())];
        let resolvers = (0, resolver_1.buildResolvers)(this.model());
        let requestCheck = this.customCheck();
        if (requestCheck) {
            plugins.push((0, check_1.createCheckPlugin)(requestCheck, this.model()));
        }
        let context;
        let customResolvers = await this.customResolvers();
        if (customResolvers) {
            typeDefs.push(customResolvers.typeDefs);
            resolvers = (0, merge_1.mergeResolvers)([resolvers, customResolvers.resolvers]);
            context = () => this.createTypeormResolverContext();
        }
        else {
            context = () => this.createPoolResolverContext();
        }
        plugins.push({
            serverWillStart: async () => {
                if (customResolvers) {
                    this.db = await this.typeormConnection();
                }
                else {
                    this.db = this.pgPool();
                }
                return {
                    serverWillStop: async () => {
                        if (this.db == null)
                            return;
                        if (this.db instanceof pg_1.Pool) {
                            await this.db.end();
                        }
                        else {
                            await this.db.close();
                        }
                    }
                };
            },
            async requestDidStart() {
                return {
                    willSendResponse(req) {
                        return req.context.openReaderTransaction.close();
                    }
                };
            }
        });
        plugins.push((0, apollo_server_core_1.ApolloServerPluginDrainHttpServer)({ httpServer: this.httpServer() }));
        return {
            typeDefs,
            resolvers,
            context,
            plugins
        };
    }
    createTypeormResolverContext() {
        let db = (0, util_1.assertNotNull)(this.db);
        (0, assert_1.default)(!(db instanceof pg_1.Pool));
        return { openReaderTransaction: new typeorm_1.TypeormTransaction(db) };
    }
    createPoolResolverContext() {
        let db = (0, util_1.assertNotNull)(this.db);
        (0, assert_1.default)(db instanceof pg_1.Pool);
        return { openReaderTransaction: new db_1.PoolTransaction(db) };
    }
    async customResolvers() {
        let loc = this.module('lib/server-extension/resolvers');
        if (loc == null)
            return undefined;
        let { loadCustomResolvers } = await Promise.resolve().then(() => __importStar(require('./resolvers')));
        return loadCustomResolvers(loc);
    }
    customCheck() {
        let loc = this.module('lib/server-extension/check');
        if (loc == null)
            return undefined;
        let mod = require(loc);
        if (typeof mod.requestCheck != 'function') {
            throw new Error(`${loc} should export requestCheck() function`);
        }
        return mod.requestCheck;
    }
    module(name) {
        let loc = this.path(name);
        try {
            return require.resolve(loc);
        }
        catch (e) {
            return undefined;
        }
    }
    pgPool() {
        let cfg = (0, db_1.createPoolConfig)();
        return new pg_1.Pool(cfg);
    }
    async typeormConnection() {
        let { createOrmConfig } = await Promise.resolve().then(() => __importStar(require('@subsquid/typeorm-config')));
        let { createConnection } = await Promise.resolve().then(() => __importStar(require('typeorm')));
        let cfg = createOrmConfig({ projectDir: this.dir });
        return createConnection(cfg);
    }
    model() {
        let file = (0, util_1.resolveGraphqlSchema)(this.dir);
        return (0, tools_1.loadModel)(file);
    }
}
__decorate([
    util_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Server.prototype, "start", null);
__decorate([
    util_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Function)
], Server.prototype, "app", null);
__decorate([
    util_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", http.Server)
], Server.prototype, "httpServer", null);
__decorate([
    util_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Server.prototype, "config", null);
__decorate([
    util_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Server.prototype, "customResolvers", null);
__decorate([
    util_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], Server.prototype, "customCheck", null);
__decorate([
    util_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], Server.prototype, "pgPool", null);
__decorate([
    util_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Server.prototype, "typeormConnection", null);
__decorate([
    util_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], Server.prototype, "model", null);
exports.Server = Server;
//# sourceMappingURL=server.js.map