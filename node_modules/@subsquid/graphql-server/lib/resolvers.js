"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadCustomResolvers = void 0;
const assert_1 = __importDefault(require("assert"));
const graphql_1 = require("graphql");
const type_graphql_1 = require("type-graphql");
const scalars_1 = require("./scalars");
async function loadCustomResolvers(mod) {
    let { typeDefs, resolvers } = await (0, type_graphql_1.buildTypeDefsAndResolvers)({
        resolvers: [mod],
        scalarsMap: [
            { type: Date, scalar: scalars_1.DateTime },
            { type: BigInt, scalar: scalars_1.BigInteger },
            { type: Buffer, scalar: scalars_1.Bytes }
        ],
        container: resolverData => new CustomResolversContainer(resolverData)
    });
    return {
        resolvers,
        typeDefs: (0, graphql_1.parse)(typeDefs)
    };
}
exports.loadCustomResolvers = loadCustomResolvers;
class CustomResolversContainer {
    constructor(resolverData) {
        let transaction = resolverData.context.openReaderTransaction;
        (0, assert_1.default)(typeof transaction?.getEntityManager == 'function', 'expected typeorm transaction in the context');
        this.transaction = transaction;
    }
    get(resolverClass) {
        return new resolverClass(() => this.transaction.getEntityManager());
    }
}
//# sourceMappingURL=resolvers.js.map