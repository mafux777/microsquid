"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.needsName = exports.assignNames = void 0;
const types_codec_1 = require("@subsquid/scale-codec/lib/types-codec");
const substrate_metadata_1 = require("@subsquid/substrate-metadata");
const assert_1 = __importDefault(require("assert"));
const util_1 = require("./util");
/**
 * Assign names to types
 */
function assignNames(d) {
    let types = d.types;
    let assignment = new Map();
    let reserved = new Set();
    reserved.add('Result');
    function assign(ti, name) {
        assignment.set(ti, name);
        reserved.add(name);
    }
    // assign good names for events and calls
    assign(d.call, 'Call');
    assign(d.event, 'Event');
    forEachPallet(types, d.call, (pallet, ti) => {
        assign(ti, pallet + 'Call');
    });
    forEachPallet(types, d.event, (pallet, ti) => {
        assign(ti, pallet + 'Event');
    });
    // a mapping between a name and types which want to have it
    let names = new Map();
    types.forEach((type, ti) => {
        if (assignment.has(ti))
            return;
        let name = deriveName(type);
        if (name && reserved.has(name)) {
            name = undefined;
        }
        if (name == null && needsName(types, ti)) {
            name = `Type_${ti}`;
        }
        if (name) {
            let list = names.get(name);
            if (list == null) {
                list = [];
                names.set(name, list);
            }
            list.push(ti);
        }
    });
    names.forEach((tis, name) => {
        let hashes = new Map();
        for (let i = 0; i < 2; i++) {
            tis.forEach(ti => {
                let hash = (0, substrate_metadata_1.getTypeHash)(types, ti);
                if (hashes.has(hash))
                    return;
                hashes.set(hash, ti);
            });
            if (hashes.size == 1) {
                tis.forEach(ti => assign(ti, name));
                return;
            }
            tis = tis.filter(ti => needsName(types, ti));
            hashes.clear();
        }
        let hashToName = new Map();
        tis.forEach(ti => {
            let hash = (0, substrate_metadata_1.getTypeHash)(types, ti);
            let assignedName = hashToName.get(hash);
            if (assignedName == null) {
                assignedName = `${name}_${ti}`;
                hashToName.set(hash, assignedName);
            }
            assign(ti, assignedName);
        });
    });
    return assignment;
}
exports.assignNames = assignNames;
function forEachPallet(types, ti, cb) {
    let type = types[ti];
    (0, assert_1.default)(type.kind == substrate_metadata_1.TypeKind.Variant);
    type.variants.forEach(v => {
        (0, assert_1.default)(v.fields.length == 1);
        let vi = v.fields[0].type;
        cb(v.name, vi);
    });
}
/**
 * Derive "the best" name from a path.
 */
function deriveName(type) {
    if (!type.path?.length)
        return undefined;
    let version = type.path.find(name => /^v\d+$/i.test(name));
    let name = type.path[type.path.length - 1];
    if (version && version !== name) {
        return `V${version.slice(1)}${name}`;
    }
    else {
        return name;
    }
}
function needsName(types, ti) {
    let type = (0, types_codec_1.getUnwrappedType)(types, ti);
    switch (type.kind) {
        case substrate_metadata_1.TypeKind.Variant:
            return !(0, util_1.asResultType)(type);
        case substrate_metadata_1.TypeKind.Composite:
            return true;
        default:
            return false;
    }
}
exports.needsName = needsName;
//# sourceMappingURL=names.js.map