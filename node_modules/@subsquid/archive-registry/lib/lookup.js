"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVersion = exports.getGenesisHash = exports.getChainInfo = exports.lookupArchive = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const node_abort_controller_1 = require("node-abort-controller");
const assert_1 = __importDefault(require("assert"));
const semver_1 = require("semver");
const registry_1 = require("./registry");
/**
 * Lookup an archive endpoint by network name, provider (optional) and genesis hash (optional)
 *
 * @param network network name for lookup
 * @param genesis network genesis hex string (must start with "0x...")
 * @param semver semver range to match archive image version
 * @param image archive image name
 * @param gateway archive gateway image
 *
 * @returns Archive endpoint url matching the filter
 * @throws If none matching archive is found or if there's ambiguity in choosing the network
 */
function lookupArchive(network, semver, genesis, image, gateway) {
    let archives = registry_1.archivesRegistry.archives.filter(a => a.network.toLowerCase() === network.toLowerCase());
    if (genesis) {
        archives = archives.filter(a => a.genesisHash?.toLowerCase() === genesis.toLowerCase());
    }
    if (archives.length === 0) {
        throw new Error(`Failed to lookup a matching archive. \
Please consider submitting a PR to subsquid/archive-registry github repo to extend the registry`);
    }
    if (archives.length > 1) {
        throw new Error(`There are multiple networks with name ${network}. \
Provide genesis hash option to prevent ambiguity.`);
    }
    let matched = archives[0].providers;
    if (semver) {
        // if (valid(semver) === null) {
        //     throw new Error(`${semver} is not a valid semver range`)
        // }
        matched = matched.filter(p => (0, semver_1.satisfies)(p.version, semver));
    }
    if (image) {
        matched = matched.filter(p => p.image === image);
    }
    if (gateway) {
        matched = matched.filter(p => p.gateway === gateway);
    }
    if (matched.length === 0) {
        throw new Error(`Failed to lookup a matching archive. \
Please consider submitting a PR to subsquid/archive-registry github repo to extend the registry`);
    }
    return matched;
}
exports.lookupArchive = lookupArchive;
/**
 * Get parachain information by its name
 *
 * @param network Network name
 * @returns Chain info incluing genesis hash, token symbols, parachainId if relevent, etc
 */
function getChainInfo(network, genesis) {
    let matched = registry_1.networkRegistry.networks.filter(n => n.name.toLowerCase() === network.toLowerCase());
    if (genesis) {
        matched = matched.filter(a => a.genesisHash?.toLowerCase() === genesis.toLowerCase());
    }
    if (matched.length === 0) {
        throw new Error(`Failed to get info on ${network}. \
Please consider submitting a PR to subsquid/archive-registry github repo to extend the registry`);
    }
    if (matched.length > 1) {
        throw new Error(`There are multiple networks with name ${network}. \
Provide genesis hash option to prevent ambiguity.`);
    }
    return matched[0];
}
exports.getChainInfo = getChainInfo;
async function getGenesisHash(endpoint) {
    const query = `
    query {
        substrate_block(where: {height: {_eq: 0}}) {
            hash
        }
    }
    `;
    const result = await archiveRequest(endpoint, query);
    return result.substrate_block[0].hash;
}
exports.getGenesisHash = getGenesisHash;
async function getVersion(endpoint) {
    const query = `
    query {
        indexerStatus {
            hydraVersion
        }
    }
    `;
    const result = await archiveRequest(endpoint, query);
    return result.indexerStatus.hydraVersion;
}
exports.getVersion = getVersion;
async function archiveRequest(endpoint, query) {
    const controller = new node_abort_controller_1.AbortController();
    // 5 second timeout:
    const timeoutId = setTimeout(() => controller.abort(), 5000);
    let response = await (0, node_fetch_1.default)(endpoint, {
        method: 'POST',
        body: JSON.stringify({ query }),
        headers: {
            'content-type': 'application/json',
            'accept': 'application/json',
            'accept-encoding': 'gzip, br'
        },
        signal: controller.signal
    });
    clearTimeout(timeoutId);
    if (!response.ok) {
        let body = await response.text();
        throw new Error(`Got http ${response.status}${body ? `, body: ${body}` : ''}`);
    }
    let result = await response.json();
    if (result.errors?.length) {
        throw new Error(`GraphQL error: ${result.errors[0].message}`);
    }
    (0, assert_1.default)(result.data != null);
    return result.data;
}
//# sourceMappingURL=lookup.js.map