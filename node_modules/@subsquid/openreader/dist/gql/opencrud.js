"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildServerSchema = exports.generateOpenCrudQueries = void 0;
const util_1 = require("@subsquid/util");
const assert_1 = __importDefault(require("assert"));
const graphql_1 = require("graphql");
const orderBy_1 = require("../orderBy");
const scalars_1 = require("../scalars");
const util_2 = require("../util");
function generateOpenCrudQueries(model) {
    let out = new util_1.Output();
    generatePageInfoType();
    for (let name in model) {
        let item = model[name];
        switch (item.kind) {
            case 'entity':
                generateOrderByInput(name);
                generateWhereUniqueInput(name);
                generateWhereInput(name, item);
                generateObjectType(name, item);
                generateEntityConnection(name);
                break;
            case 'object':
                if (hasFilters(item)) {
                    generateWhereInput(name, item);
                }
                generateObjectType(name, item);
                break;
            case 'interface':
                generateObjectType(name, item);
                break;
            case 'union':
                generateUnionWhereInput(name, item);
                generateUnionType(name, item);
                break;
            case 'enum':
                generateEnumType(name, item);
                break;
            case 'fts':
                generateFtsTypes(name, item);
                break;
        }
    }
    out.block('type Query', () => {
        for (let name in model) {
            let item = model[name];
            if (item.kind == 'entity') {
                out.line(`${(0, util_1.toCamelCase)(name)}ById(id: ID!): ${name}`);
                out.line(`${(0, util_1.toCamelCase)(name)}ByUniqueInput(where: ${name}WhereUniqueInput!): ${name} @deprecated(reason: "Use \`${(0, util_1.toCamelCase)(name)}ById\`")`);
                out.line(`${(0, util_2.toQueryListField)(name)}${manyArguments(name)}: [${name}!]!`);
                out.line(`${(0, util_2.toQueryListField)(name)}Connection${connectionArguments(name)}: ${(0, util_1.toPlural)(name)}Connection!`);
            }
            if (item.kind == 'fts') {
                generateFtsQuery(name, item);
            }
        }
    });
    function generateObjectType(name, object) {
        let head;
        if (object.kind == 'interface') {
            head = `interface ${name}`;
        }
        else {
            head = `type ${name}`;
            if (object.interfaces?.length) {
                head += ` implements ${object.interfaces.join(' & ')}`;
            }
        }
        generateDescription(object.description);
        out.block(head, () => {
            for (let key in object.properties) {
                let prop = object.properties[key];
                let gqlType = renderPropType(prop);
                generateDescription(prop.description);
                if (prop.type.kind == 'list-lookup') {
                    out.line(`${key}${manyArguments(prop.type.entity)}: ${gqlType}`);
                }
                else {
                    out.line(`${key}: ${gqlType}`);
                }
            }
        });
        out.line();
    }
    function renderPropType(prop) {
        switch (prop.type.kind) {
            case "list":
                return `[${renderPropType(prop.type.item)}]${prop.nullable ? '' : '!'}`;
            case 'fk':
                return `${prop.type.foreignEntity}${prop.nullable ? '' : '!'}`;
            case 'lookup':
                return prop.type.entity;
            case 'list-lookup':
                return `[${prop.type.entity}!]!`;
            default:
                return prop.type.name + (prop.nullable ? '' : '!');
        }
    }
    function manyArguments(entityName) {
        return `(where: ${entityName}WhereInput orderBy: [${entityName}OrderByInput] offset: Int limit: Int)`;
    }
    function connectionArguments(entityName) {
        return `(orderBy: [${entityName}OrderByInput!]! after: String first: Int where: ${entityName}WhereInput)`;
    }
    function generateOrderByInput(entityName) {
        out.block(`enum ${entityName}OrderByInput`, () => {
            let mapping = (0, orderBy_1.getOrderByMapping)(model, entityName);
            for (let key of mapping.keys()) {
                out.line(key);
            }
        });
        out.line();
    }
    function generateWhereUniqueInput(entityName) {
        out.block(`input ${entityName}WhereUniqueInput`, () => {
            out.line('id: ID!');
        });
    }
    function generateWhereInput(name, object) {
        out.block(`input ${name}WhereInput`, () => {
            generatePropsFilters(object.properties);
            if (object.kind == 'entity') {
                out.line(`AND: [${name}WhereInput!]`);
                out.line(`OR: [${name}WhereInput!]`);
            }
        });
        out.line();
    }
    function generatePropsFilters(props) {
        for (let key in props) {
            let prop = props[key];
            switch (prop.type.kind) {
                case 'scalar':
                case 'enum':
                    generateIsNullFilter(key, prop);
                    generateScalarFilters(key, prop.type.name);
                    break;
                case 'list':
                    generateIsNullFilter(key, prop);
                    if (prop.type.item.type.kind == 'scalar' || prop.type.item.type.kind == 'enum') {
                        let item = prop.type.item.type.name;
                        out.line(`${key}_containsAll: [${item}!]`);
                        out.line(`${key}_containsAny: [${item}!]`);
                        out.line(`${key}_containsNone: [${item}!]`);
                    }
                    break;
                case 'object':
                    generateIsNullFilter(key, prop);
                    if (hasFilters(getObject(prop.type.name))) {
                        out.line(`${key}: ${prop.type.name}WhereInput`);
                    }
                    break;
                case 'union':
                    generateIsNullFilter(key, prop);
                    out.line(`${key}: ${prop.type.name}WhereInput`);
                    break;
                case 'fk':
                    generateIsNullFilter(key, prop);
                    out.line(`${key}: ${prop.type.foreignEntity}WhereInput`);
                    break;
                case 'lookup':
                    out.line(`${key}: ${prop.type.entity}WhereInput`);
                    break;
                case 'list-lookup':
                    out.line(`${key}_every: ${prop.type.entity}WhereInput`);
                    out.line(`${key}_some: ${prop.type.entity}WhereInput`);
                    out.line(`${key}_none: ${prop.type.entity}WhereInput`);
                    break;
            }
        }
    }
    function generateIsNullFilter(key, prop) {
        if (!prop.nullable)
            return;
        out.line(`${key}_isNull: Boolean`);
    }
    function hasFilters(obj) {
        for (let key in obj.properties) {
            let propType = obj.properties[key].type;
            switch (propType.kind) {
                case 'scalar':
                case 'enum':
                case 'union':
                    return true;
                case 'object': {
                    let ref = getObject(propType.name);
                    if (ref !== obj && hasFilters(ref)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    function getObject(name) {
        let obj = model[name];
        (0, assert_1.default)(obj.kind == 'object');
        return obj;
    }
    function generateUnionWhereInput(name, union) {
        out.block(`input ${name}WhereInput`, () => {
            // TODO: unify and use enum
            out.line('isTypeOf_eq: String');
            out.line('isTypeOf_not_eq: String');
            out.line('isTypeOf_in: [String!]');
            out.line('isTypeOf_not_in: [String!]');
            let props = {};
            union.variants.forEach(variant => {
                let obj = getObject(variant);
                Object.assign(props, obj.properties);
            });
            generatePropsFilters(props);
        });
    }
    function generateScalarFilters(fieldName, graphqlType) {
        out.line(`${fieldName}_eq: ${graphqlType}`);
        out.line(`${fieldName}_not_eq: ${graphqlType}`);
        switch (graphqlType) {
            case 'ID':
            case 'String':
            case 'Int':
            case 'Float':
            case 'DateTime':
            case 'BigInt':
                out.line(`${fieldName}_gt: ${graphqlType}`);
                out.line(`${fieldName}_gte: ${graphqlType}`);
                out.line(`${fieldName}_lt: ${graphqlType}`);
                out.line(`${fieldName}_lte: ${graphqlType}`);
                out.line(`${fieldName}_in: [${graphqlType}!]`);
                out.line(`${fieldName}_not_in: [${graphqlType}!]`);
                break;
        }
        if (graphqlType == 'String' || graphqlType == 'ID') {
            out.line(`${fieldName}_contains: ${graphqlType}`);
            out.line(`${fieldName}_not_contains: ${graphqlType}`);
            out.line(`${fieldName}_startsWith: ${graphqlType}`);
            out.line(`${fieldName}_not_startsWith: ${graphqlType}`);
            out.line(`${fieldName}_endsWith: ${graphqlType}`);
            out.line(`${fieldName}_not_endsWith: ${graphqlType}`);
        }
        if (model[graphqlType]?.kind == 'enum') {
            out.line(`${fieldName}_in: [${graphqlType}!]`);
            out.line(`${fieldName}_not_in: [${graphqlType}!]`);
        }
    }
    function generateUnionType(name, union) {
        generateDescription(union.description);
        out.line(`union ${name} = ${union.variants.join(' | ')}`);
        out.line();
    }
    function generateEnumType(name, e) {
        generateDescription(e.description);
        out.block(`enum ${name}`, () => {
            for (let key in e.values) {
                out.line(key);
            }
        });
    }
    function generatePageInfoType() {
        out.block(`type PageInfo`, () => {
            out.line('hasNextPage: Boolean!');
            out.line('hasPreviousPage: Boolean!');
            out.line('startCursor: String!');
            out.line('endCursor: String!');
        });
        out.line();
    }
    function generateEntityConnection(name) {
        out.block(`type ${name}Edge`, () => {
            out.line(`node: ${name}!`);
            out.line(`cursor: String!`);
        });
        out.line();
        out.block(`type ${(0, util_1.toPlural)(name)}Connection`, () => {
            out.line(`edges: [${name}Edge!]!`);
            out.line(`pageInfo: PageInfo!`);
            out.line(`totalCount: Int!`);
        });
        out.line();
    }
    function generateFtsTypes(name, query) {
        let itemType = name + '_Item';
        out.line(`union ${itemType} = ${query.sources.map(s => s.entity).join(' | ')}`);
        out.line();
        out.block(`type ${name}_Output`, () => {
            out.line(`item: ${itemType}!`);
            out.line(`rank: Float!`);
            out.line(`highlight: String!`);
        });
        out.line();
    }
    function generateFtsQuery(name, query) {
        let where = query.sources.map(src => {
            return `where${src.entity}: ${src.entity}WhereInput`;
        });
        out.line(`${name}(text: String! ${where.join(' ')} limit: Int offset: Int): [${name}_Output!]!`);
    }
    function generateDescription(description) {
        if (description) {
            out.line((0, graphql_1.print)({
                kind: 'StringValue',
                value: description
            }));
        }
    }
    return out.toString();
}
exports.generateOpenCrudQueries = generateOpenCrudQueries;
function buildServerSchema(model) {
    let scalars = scalars_1.scalars_list.map(name => 'scalar ' + name).join('\n');
    let queries = generateOpenCrudQueries(model);
    return (0, graphql_1.parse)(scalars + '\n\n' + queries);
}
exports.buildServerSchema = buildServerSchema;
//# sourceMappingURL=opencrud.js.map