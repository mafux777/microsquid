"use strict";
/**
 * The current concept of custom scalars is as follows:
 *
 * Each custom scalar has a canonical string representation which is used almost everywhere:
 *    in JSON responses
 *    in graphql queries/schemas
 *    in jsonb database columns
 *    in database results
 *
 * Database must support 2 way coercion between underlying database type and canonical representation
 * of a corresponding scalar.
 *
 * We receive from database canonical strings and use them within our resolvers as is.
 *
 * GraphQL parsing procedures convert canonical string representation to corresponding js type.
 * This is for compatibility with possible extensions which would like to reuse our scalars.
 *
 * In GraphQL serialization procedures we accept both a canonical string representation
 * and corresponding js type.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromJsonToOutputCast = exports.fromJsonCast = exports.toOutputArrayCast = exports.fromStringCast = exports.toOutputCast = exports.getScalarResolvers = exports.scalars_list = exports.scalars = void 0;
const graphql_1 = require("graphql");
exports.scalars = {
    BigInt: {
        gql: new graphql_1.GraphQLScalarType({
            name: 'BigInt',
            description: 'Big number integer',
            serialize(value) {
                return '' + value;
            },
            parseValue(value) {
                if (!isBigInt(value))
                    throw invalidFormat('BigInt', value);
                return BigInt(value);
            },
            parseLiteral(ast) {
                switch (ast.kind) {
                    case "StringValue":
                        if (isBigInt(ast.value)) {
                            return BigInt(ast.value);
                        }
                        else {
                            throw invalidFormat('BigInt', ast.value);
                        }
                    case "IntValue":
                        return BigInt(ast.value);
                    default:
                        return null;
                }
            }
        }),
        fromStringCast(exp) {
            return `(${exp})::numeric`;
        },
        toStringCast(exp) {
            return `(${exp})::text`;
        },
        toStringArrayCast(exp) {
            return `(${exp})::text[]`;
        }
    },
    DateTime: {
        gql: new graphql_1.GraphQLScalarType({
            name: 'DateTime',
            description: 'A date-time string in simplified extended ISO 8601 format (YYYY-MM-DDTHH:mm:ss.sssZ)',
            serialize(value) {
                if (value instanceof Date) {
                    return value.toISOString();
                }
                else {
                    if (!isIsoDateTimeString(value))
                        throw invalidFormat('DateTime', value);
                    return value;
                }
            },
            parseValue(value) {
                return parseDateTime(value);
            },
            parseLiteral(ast) {
                switch (ast.kind) {
                    case "StringValue":
                        return parseDateTime(ast.value);
                    default:
                        return null;
                }
            }
        }),
        fromStringCast(exp) {
            return `(${exp})::timestamptz`;
        },
        toStringCast(exp) {
            return `to_char((${exp}) at time zone 'UTC', 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"')`;
        },
        toStringArrayCast(exp) {
            return `array(select to_char(i at time zone 'UTC', 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"') from unnest(${exp}) as i)`;
        }
    },
    Bytes: {
        gql: new graphql_1.GraphQLScalarType({
            name: 'Bytes',
            description: 'Binary data encoded as a hex string always prefixed with 0x',
            serialize(value) {
                if (typeof value == 'string') {
                    if (!isBytesString(value))
                        throw invalidFormat('Bytes', value);
                    return value.toLowerCase();
                }
                else {
                    return '0x' + value.toString('hex');
                }
            },
            parseValue(value) {
                return parseBytes(value);
            },
            parseLiteral(ast) {
                switch (ast.kind) {
                    case "StringValue":
                        return parseBytes(ast.value);
                    default:
                        return null;
                }
            }
        }),
        fromStringCast(exp) {
            return `decode(substr(${exp}, 3), 'hex')`;
        },
        toStringCast(exp) {
            return `'0x' || encode(${exp}, 'hex')`;
        },
        toStringArrayCast(exp) {
            return `array(select '0x' || encode(i, 'hex') from unnest(${exp}) as i)`;
        }
    }
};
function isBigInt(s) {
    return /^[+\-]?\d+$/.test(s);
}
// credit - https://github.com/Urigo/graphql-scalars/blob/91b4ea8df891be8af7904cf84751930cc0c6613d/src/scalars/iso-date/validator.ts#L122
const RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\.\d{1,})?([Z])$/;
function isIsoDateTimeString(s) {
    return RFC_3339_REGEX.test(s);
}
function parseDateTime(s) {
    if (!isIsoDateTimeString(s))
        throw invalidFormat('DateTime', s);
    let timestamp = Date.parse(s);
    if (isNaN(timestamp))
        throw invalidFormat('DateTime', s);
    return new Date(timestamp);
}
function isBytesString(s) {
    return s.length % 2 == 0 && /^0x[a-f0-9]+$/i.test(s);
}
function parseBytes(s) {
    if (!isBytesString(s))
        throw invalidFormat('Bytes', s);
    return Buffer.from(s.slice(2), 'hex');
}
function invalidFormat(type, value) {
    return new TypeError(`Not a ${type}: ${value}`);
}
exports.scalars_list = ['ID'].concat(Object.keys(exports.scalars));
function getScalarResolvers() {
    let resolvers = {};
    for (let type in exports.scalars) {
        resolvers[type] = exports.scalars[type].gql;
    }
    return resolvers;
}
exports.getScalarResolvers = getScalarResolvers;
function toOutputCast(scalarType, sqlExp) {
    let s = exports.scalars[scalarType];
    if (s) {
        return s.toStringCast(sqlExp);
    }
    else {
        return sqlExp;
    }
}
exports.toOutputCast = toOutputCast;
function fromStringCast(scalarType, sqlExp) {
    let s = exports.scalars[scalarType];
    if (s) {
        return s.fromStringCast(sqlExp);
    }
    else {
        return sqlExp;
    }
}
exports.fromStringCast = fromStringCast;
function toOutputArrayCast(scalarType, sqlExp) {
    let s = exports.scalars[scalarType];
    if (s) {
        return s.toStringArrayCast(sqlExp);
    }
    else {
        return sqlExp;
    }
}
exports.toOutputArrayCast = toOutputArrayCast;
function fromJsonCast(scalarType, objSqlExp, prop) {
    switch (scalarType) {
        case 'Int':
            return `(${objSqlExp}->'${prop}')::integer`;
        case 'Float':
            return `(${objSqlExp}->'${prop}')::numeric`;
        case 'Boolean':
            return `(${objSqlExp}->'${prop}')::bool`;
        default:
            return fromStringCast(scalarType, `${objSqlExp}->>'${prop}'`);
    }
}
exports.fromJsonCast = fromJsonCast;
function fromJsonToOutputCast(scalarType, objSqlExp, prop) {
    switch (scalarType) {
        case 'Int':
            return `(${objSqlExp}->'${prop}')::integer`;
        case 'Float':
            return `(${objSqlExp}->'${prop}')::numeric`;
        case 'Boolean':
            return `(${objSqlExp}->'${prop}')::bool`;
        default:
            return `${objSqlExp}->>'${prop}'`;
    }
}
exports.fromJsonToOutputCast = fromJsonToOutputCast;
//# sourceMappingURL=scalars.js.map