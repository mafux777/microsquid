/**
 * The current concept of custom scalars is as follows:
 *
 * Each custom scalar has a canonical string representation which is used almost everywhere:
 *    in JSON responses
 *    in graphql queries/schemas
 *    in jsonb database columns
 *    in database results
 *
 * Database must support 2 way coercion between underlying database type and canonical representation
 * of a corresponding scalar.
 *
 * We receive from database canonical strings and use them within our resolvers as is.
 *
 * GraphQL parsing procedures convert canonical string representation to corresponding js type.
 * This is for compatibility with possible extensions which would like to reuse our scalars.
 *
 * In GraphQL serialization procedures we accept both a canonical string representation
 * and corresponding js type.
 */
import { GraphQLScalarType } from "graphql";
export interface Scalar {
    gql: GraphQLScalarType;
    fromStringCast: (sqlExp: string) => string;
    toStringCast: (sqlExp: string) => string;
    toStringArrayCast: (sqlExp: string) => string;
}
export declare const scalars: Record<string, Scalar>;
export declare const scalars_list: string[];
export declare function getScalarResolvers(): Record<string, GraphQLScalarType>;
export declare function toOutputCast(scalarType: string, sqlExp: string): string;
export declare function fromStringCast(scalarType: string, sqlExp: string): string;
export declare function toOutputArrayCast(scalarType: string, sqlExp: string): string;
export declare function fromJsonCast(scalarType: string, objSqlExp: string, prop: string): string;
export declare function fromJsonToOutputCast(scalarType: string, objSqlExp: string, prop: string): string;
//# sourceMappingURL=scalars.d.ts.map