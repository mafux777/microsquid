"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPoolConfig = exports.PoolTransaction = exports.PgDatabase = void 0;
class PgDatabase {
    constructor(client) {
        this.client = client;
    }
    query(sql, parameters) {
        return this.client.query({ text: sql, rowMode: 'array' }, parameters).then(result => result.rows);
    }
    escapeIdentifier(name) {
        return this.client.escapeIdentifier(name);
    }
}
exports.PgDatabase = PgDatabase;
class PoolTransaction {
    constructor(pool) {
        this.pool = pool;
        this.closed = false;
    }
    async get() {
        if (this.closed) {
            throw new Error('Too late to request transaction');
        }
        this.tx = this.tx || this.startTransaction();
        let { db } = await this.tx;
        return db;
    }
    async startTransaction() {
        let client = await this.pool.connect();
        try {
            await client.query('START TRANSACTION ISOLATION LEVEL SERIALIZABLE READ ONLY');
            return {
                client,
                db: new PgDatabase(client)
            };
        }
        catch (e) {
            client.release();
            throw e;
        }
    }
    close() {
        this.closed = true;
        return this.tx?.then(async ({ client }) => {
            try {
                await client.query('COMMIT');
            }
            catch (e) {
                // ignore
            }
            finally {
                client.release();
            }
        }) || Promise.resolve();
    }
}
exports.PoolTransaction = PoolTransaction;
function createPoolConfig() {
    return {
        host: process.env.DB_HOST || 'localhost',
        port: process.env.DB_PORT ? parseInt(process.env.DB_PORT) : 5432,
        database: process.env.DB_NAME || 'postgres',
        user: process.env.DB_USER || 'postgres',
        password: process.env.DB_PASS || 'postgres'
    };
}
exports.createPoolConfig = createPoolConfig;
//# sourceMappingURL=db.js.map