"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Prometheus = void 0;
const util_1 = require("@subsquid/util");
const assert_1 = __importDefault(require("assert"));
const http = __importStar(require("http"));
const prom_client_1 = require("prom-client");
const stoppable_1 = __importDefault(require("stoppable"));
class Prometheus {
    constructor() {
        this.chainHeightValue = -1;
        this.ingestSpeedValue = 0;
        this.registry = new prom_client_1.Registry();
        this.lastBlock = new prom_client_1.Gauge({
            name: 'sqd_processor_last_block',
            help: 'Last processed block',
            registers: [this.registry],
            aggregator: 'max'
        });
        this.chainHeight = new prom_client_1.Gauge({
            name: 'sqd_processor_chain_height',
            help: 'Chain height of the data source',
            registers: [this.registry],
            aggregator: 'max'
        });
        this.mappingSpeed = new prom_client_1.Gauge({
            name: 'sqd_processor_mapping_blocks_per_second',
            help: 'Mapping performance',
            registers: [this.registry],
            aggregator: 'average'
        });
        this.ingestSpeed = new prom_client_1.Gauge({
            name: 'sqd_processor_ingest_blocks_per_second',
            help: 'Data fetching speed',
            registers: [this.registry],
            aggregator: 'average'
        });
        this.syncETA = new prom_client_1.Gauge({
            name: 'sqd_processor_sync_eta_seconds',
            help: 'Estimated time until all required blocks will be processed or until chain height will be reached',
            registers: [this.registry]
        });
        this.syncRatio = new prom_client_1.Gauge({
            name: 'sqd_processor_sync_ratio',
            help: 'Percentage of processed blocks',
            registers: [this.registry],
            aggregator: 'max'
        });
        (0, prom_client_1.collectDefaultMetrics)({ register: this.registry });
        this.setLastProcessedBlock(-1);
        this.setChainHeight(-1);
    }
    setLastProcessedBlock(height) {
        this.lastBlock.set(height);
    }
    setChainHeight(height) {
        this.chainHeightValue = height;
        this.chainHeight.set(height);
    }
    getChainHeight() {
        return this.chainHeightValue;
    }
    setMappingSpeed(blocksPerSecond) {
        this.mappingSpeed.set(blocksPerSecond);
    }
    setIngestSpeed(blocksPerSecond) {
        this.ingestSpeedValue = blocksPerSecond;
        this.ingestSpeed.set(blocksPerSecond);
    }
    getIngestSpeed() {
        return this.ingestSpeedValue;
    }
    setSyncETA(seconds) {
        this.syncETA.set(seconds);
    }
    setSyncRatio(ratio) {
        this.syncRatio.set(ratio);
    }
    async handleHttpRequest(req, send) {
        let url = new URL((0, util_1.assertNotNull)(req.url), `http://${req.headers.host}`);
        let path = url.pathname.slice(1).split('/');
        if (path[0] != 'metrics')
            return send(404);
        let metricName = path[1];
        if (metricName) {
            if (this.registry.getSingleMetric(metricName)) {
                let value = await this.registry.getSingleMetricAsString(metricName);
                return send(200, value);
            }
            else {
                return send(404, 'requested metric not found');
            }
        }
        else if (url.searchParams.get('json') == 'true') {
            let value = await this.registry.getMetricsAsJSON();
            return send(200, value);
        }
        else {
            let value = await this.registry.metrics();
            return send(200, value, this.registry.contentType);
        }
    }
    serve(port) {
        function send(res, status, body, type) {
            body = body || http.STATUS_CODES[status] || '';
            type = type || (typeof body == 'string' ? 'text/plain' : 'application/json');
            if (typeof body != 'string') {
                body = JSON.stringify(body);
            }
            res.statusCode = status;
            res.setHeader('content-type', type + '; charset=UTF-8');
            res.setHeader('content-length', Buffer.byteLength(body));
            res.end(body);
        }
        let server = (0, stoppable_1.default)(http.createServer(async (req, res) => {
            try {
                await this.handleHttpRequest(req, send.bind(this, res));
            }
            catch (err) {
                if (res.headersSent) {
                    res.destroy();
                }
                else {
                    send(res, 500, err.stack);
                }
            }
        }));
        function close() {
            return new Promise((resolve, reject) => {
                server.stop((err, gracefully) => {
                    if (gracefully) {
                        resolve();
                    }
                    else {
                        reject(err || new Error('Failed to shutdown gracefully'));
                    }
                });
            });
        }
        return new Promise((resolve, reject) => {
            server.listen(port, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    let address = server.address();
                    (0, assert_1.default)(address != null && typeof address == 'object');
                    resolve({
                        port: address.port,
                        close
                    });
                }
            });
        });
    }
}
exports.Prometheus = Prometheus;
//# sourceMappingURL=prometheus.js.map