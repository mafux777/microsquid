export declare class Channel<T> {
    private capacity;
    private buf;
    private drained;
    private takes;
    private closed;
    private closedValue?;
    constructor(capacity: number);
    put(item: T): Promise<void>;
    take(): Promise<T>;
    close(val?: T): void;
}
export declare class ClosedChannelError extends Error {
    constructor();
}
export declare class Future<T> {
    private result?;
    private cb?;
    resolve(value: T): void;
    reject(error: Error): void;
    readonly promise: Promise<T>;
    private resolvePromise;
}
export declare class AbortHandle {
    private abortError;
    private listeners;
    get isAborted(): boolean;
    assertNotAborted(): void;
    abort(err?: Error): void;
    addListener(f: (err: Error) => void): void;
    removeListener(f: (err: Error) => void): void;
    guard<T>(promise: Promise<T>): Promise<T>;
}
export declare class AbortError extends Error {
    constructor();
}
export declare function wait(ms: number, abort?: AbortHandle): Promise<void>;
//# sourceMappingURL=async.d.ts.map