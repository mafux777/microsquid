"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wait = exports.AbortError = exports.AbortHandle = exports.Future = exports.ClosedChannelError = exports.Channel = void 0;
const util_1 = require("@subsquid/util");
const assert_1 = __importDefault(require("assert"));
class Channel {
    constructor(capacity) {
        this.capacity = capacity;
        this.buf = [];
        this.takes = [];
        this.closed = false;
    }
    put(item) {
        if (this.closed) {
            return Promise.reject(new ClosedChannelError());
        }
        let take = this.takes.shift();
        if (take) {
            take.resolve(item);
            return Promise.resolve();
        }
        this.buf.push(item);
        if (this.buf.length >= this.capacity) {
            this.drained = this.drained || new Future();
            return this.drained.promise;
        }
        else {
            return Promise.resolve();
        }
    }
    take() {
        if (this.buf.length) {
            let value = this.buf.shift();
            if (this.buf.length < this.capacity) {
                let drained = this.drained;
                this.drained = undefined;
                drained?.resolve();
            }
            return Promise.resolve(value);
        }
        else if (this.closed) {
            if (this.closedValue === undefined) {
                return Promise.reject(new ClosedChannelError());
            }
            else {
                return Promise.resolve(this.closedValue);
            }
        }
        else {
            let future = new Future();
            this.takes.push(future);
            return future.promise;
        }
    }
    close(val) {
        if (this.closed)
            return;
        this.closed = true;
        this.closedValue = val;
        let drained = this.drained;
        this.drained = undefined;
        drained?.reject(new ClosedChannelError());
        this.takes.forEach(take => {
            if (this.closedValue === undefined) {
                take.reject(new ClosedChannelError());
            }
            else {
                take.resolve(this.closedValue);
            }
        });
        this.takes.length = 0;
    }
}
exports.Channel = Channel;
class ClosedChannelError extends Error {
    constructor() {
        super('Channel was closed');
    }
}
exports.ClosedChannelError = ClosedChannelError;
class Future {
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            if (this.result) {
                this.resolvePromise(resolve, reject);
            }
            else {
                this.cb = () => this.resolvePromise(resolve, reject);
            }
        });
    }
    resolve(value) {
        this.result = { value, error: null };
        this.cb?.();
    }
    reject(error) {
        this.result = { error };
        this.cb?.();
    }
    resolvePromise(resolve, reject) {
        let result = (0, util_1.assertNotNull)(this.result);
        if (result.error == null) {
            resolve(result.value);
        }
        else {
            reject(result.error);
        }
    }
}
exports.Future = Future;
class AbortHandle {
    constructor() {
        this.listeners = [];
    }
    get isAborted() {
        return this.abortError != null;
    }
    assertNotAborted() {
        if (this.abortError)
            throw this.abortError;
    }
    abort(err) {
        if (this.abortError)
            return;
        this.abortError = err || new AbortError();
        for (let i = 0; i < this.listeners.length; i++) {
            safeCall(() => this.listeners[i](this.abortError));
        }
        this.listeners.length = 0;
    }
    addListener(f) {
        (0, assert_1.default)(!this.isAborted);
        this.listeners.push(f);
    }
    removeListener(f) {
        let idx = this.listeners.indexOf(f);
        if (idx >= 0) {
            this.listeners.splice(idx, 1);
        }
    }
    guard(promise) {
        return new Promise((resolve, reject) => {
            if (this.abortError) {
                promise.catch(() => null);
                reject(this.abortError);
                return;
            }
            this.addListener(reject);
            promise.then(result => {
                this.removeListener(reject);
                resolve(result);
            }, err => {
                this.removeListener(reject);
                reject(err);
            });
        });
    }
}
exports.AbortHandle = AbortHandle;
class AbortError extends Error {
    constructor() {
        super('Aborted');
    }
}
exports.AbortError = AbortError;
function wait(ms, abort) {
    return new Promise((resolve, reject) => {
        abort?.assertNotAborted();
        let timeout = setTimeout(() => {
            abort?.removeListener(onabort);
            resolve();
        }, ms);
        function onabort(err) {
            clearTimeout(timeout);
            reject(err);
        }
        abort?.addListener(onabort);
    });
}
exports.wait = wait;
function safeCall(f) {
    try {
        f();
    }
    catch (e) {
        // TODO: log
    }
}
//# sourceMappingURL=async.js.map