"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ingest = void 0;
const util_1 = require("@subsquid/util");
const assert_1 = __importDefault(require("assert"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const async_1 = require("./util/async");
const misc_1 = require("./util/misc");
const range_1 = require("./util/range");
class Ingest {
    constructor(options) {
        this.options = options;
        this.out = new async_1.Channel(3);
        this._abort = new async_1.AbortHandle();
        this.archiveHeight = -1;
        this.batches = options.batches$;
        this.limit = this.options.batchSize;
        (0, assert_1.default)(this.limit > 0);
        this.ingestion = this.run();
    }
    nextBatch() {
        return this.out.take();
    }
    close() {
        this._abort.abort();
        return this.ingestion;
    }
    async run() {
        try {
            await this.loop();
        }
        catch (err) {
            return err;
        }
        finally {
            this.out.close(null);
        }
    }
    async loop() {
        while (this.batches.length) {
            this._abort.assertNotAborted();
            let batch = this.batches[0];
            let archiveHeight = await this.waitForHeight(batch.range.from);
            let fetchStart = process.hrtime.bigint();
            let blocks = await this.batchFetch(batch, archiveHeight);
            if (blocks.length) {
                (0, assert_1.default)(blocks.length <= this.limit);
                (0, assert_1.default)(batch.range.from <= blocks[0].block.height);
                (0, assert_1.default)((0, range_1.rangeEnd)(batch.range) >= blocks[blocks.length - 1].block.height);
                (0, assert_1.default)(archiveHeight >= blocks[blocks.length - 1].block.height);
            }
            let from = batch.range.from;
            let to;
            if (blocks.length === this.limit && blocks[blocks.length - 1].block.height < (0, range_1.rangeEnd)(batch.range)) {
                to = blocks[blocks.length - 1].block.height;
                batch.range = { from: to + 1, to: batch.range.to };
            }
            else if (archiveHeight < (0, range_1.rangeEnd)(batch.range)) {
                to = archiveHeight;
                batch.range = { from: to + 1, to: batch.range.to };
            }
            else {
                to = (0, util_1.assertNotNull)(batch.range.to);
                this.batches.shift();
            }
            if (this.options.metrics && blocks.length > 0) {
                let fetchEnd = process.hrtime.bigint();
                let duration = Number(fetchEnd - fetchStart);
                let speed = blocks.length * Math.pow(10, 9) / duration;
                this.options.metrics.setIngestSpeed(speed);
            }
            await this._abort.guard(this.out.put({
                blocks,
                range: { from, to },
                handlers: batch.handlers
            }));
        }
    }
    async batchFetch(batch, archiveHeight) {
        let from = batch.range.from;
        let to = Math.min(archiveHeight, (0, range_1.rangeEnd)(batch.range));
        (0, assert_1.default)(from <= to);
        let hs = batch.handlers;
        let events = Object.keys(hs.events);
        let notAllBlocksRequired = hs.pre.length == 0 && hs.post.length == 0;
        let blockArgs = {
            limit: this.limit,
            order_by: { height: { $: 'asc' } },
            where: {
                height: { _gte: from, _lte: to },
                _or: []
            }
        };
        if (notAllBlocksRequired) {
            events.forEach(name => {
                blockArgs.where._or.push({
                    events: { _contains: [{ name }] }
                });
            });
            let extrinsics = (0, misc_1.unique)(Object.entries(hs.extrinsics).flatMap(e => Object.keys(e[1])));
            extrinsics.forEach(name => {
                blockArgs.where._or.push({
                    extrinsics: { _contains: [{ name }] }
                });
            });
            if ((0, misc_1.hasProperties)(hs.evmLogs)) {
                let blocks = await this.fetchBlocksWithEvmData(from, to, hs.evmLogs);
                blocks.evm_log_idx.forEach(({ block_id }) => {
                    blockArgs.where._or.push({ id: { _eq: block_id } });
                });
            }
        }
        let eventArgs = {
            order_by: { indexInBlock: { $: 'asc' } },
            where: { _or: [] }
        };
        if (events.length > 0) {
            eventArgs.where._or.push({
                name: { _in: events }
            });
        }
        for (let event in hs.extrinsics) {
            let extrinsics = Object.keys(hs.extrinsics[event]);
            eventArgs.where._or.push({
                name: { _eq: event },
                extrinsic: { name: { _in: extrinsics } }
            });
        }
        this.forEachEvmContract(hs.evmLogs, (contract, topics) => {
            eventArgs.where._or.push({
                evmLogAddress: { _eq: contract },
                _or: topics.map(topic => {
                    return {
                        evmLogTopics: { _contains: topic }
                    };
                })
            });
        });
        let q = new util_1.Output();
        q.block(`query`, () => {
            q.block(`indexerStatus`, () => {
                q.line('head');
            });
            q.block(`substrate_block(${printArguments(blockArgs)})`, () => {
                q.line('id');
                q.line('hash');
                q.line('height');
                q.line('timestamp');
                q.line('parentHash');
                q.line('stateRoot');
                q.line('extrinsicsRoot');
                q.line('runtimeVersion');
                q.line('lastRuntimeUpgrade');
                q.line('validatorId');
                q.block('events: substrate_events(order_by: {indexInBlock: asc})', () => {
                    q.line('id');
                    q.line('name');
                    q.line('extrinsic: extrinsicName');
                    q.line('extrinsicId');
                });
                q.line('extrinsics');
                q.line();
                q.block(`substrate_events(${printArguments(eventArgs)})`, () => {
                    q.line('id');
                    q.line('name');
                    q.line('method');
                    q.line('section');
                    q.line('params');
                    q.line('indexInBlock');
                    q.line('blockNumber');
                    q.line('blockTimestamp');
                    if ((0, misc_1.hasProperties)(hs.evmLogs)) {
                        q.line('evmLogAddress');
                        q.line('evmLogData');
                        q.line('evmLogTopics');
                        q.line('evmHash');
                    }
                    q.block('extrinsic', () => {
                        q.line('id');
                    });
                });
            });
        });
        let gql = q.toString();
        let response = await this.archiveRequest(gql);
        this.setArchiveHeight(response);
        return this.joinExtrinsicsAndDoPostProcessing(response.substrate_block);
    }
    async joinExtrinsicsAndDoPostProcessing(fetchedBlocks) {
        let extrinsicIds = new Set();
        let blocks = new Array(fetchedBlocks.length);
        for (let i = 0; i < fetchedBlocks.length; i++) {
            i > 0 && (0, assert_1.default)(fetchedBlocks[i - 1].height < fetchedBlocks[i].height);
            let { timestamp, substrate_events: events, validatorId, ...block } = fetchedBlocks[i];
            block.timestamp = Number.parseInt(timestamp);
            block.validator = validatorId.length > 0 ? validatorId : undefined;
            for (let j = 0; j < events.length; j++) {
                j > 0 && (0, assert_1.default)(events[j - 1].indexInBlock < events[j].indexInBlock);
                let event = events[j];
                event.blockTimestamp = block.timestamp;
                if (event.extrinsic) {
                    extrinsicIds.add(`"${event.extrinsic.id}"`);
                }
            }
            blocks[i] = { block, events };
        }
        if (extrinsicIds.size == 0)
            return blocks;
        let q = new util_1.Output();
        q.block(`query`, () => {
            q.block(`substrate_extrinsic(where: {id: {_in: [${Array.from(extrinsicIds).join(', ')}]}})`, () => {
                q.line('id');
                q.line('name');
                q.line('method');
                q.line('section');
                q.line('versionInfo');
                q.line('era');
                q.line('signer');
                q.line('args');
                q.line('hash');
                q.line('tip');
                q.line('indexInBlock');
            });
        });
        let gql = q.toString();
        let { substrate_extrinsic } = await this.archiveRequest(gql);
        let extrinsics = new Map(); // lying a bit about type here
        for (let i = 0; i < substrate_extrinsic.length; i++) {
            let ex = substrate_extrinsic[i];
            if (ex.tip != null) {
                ex.tip = BigInt(ex.tip);
            }
            extrinsics.set(ex.id, ex);
        }
        for (let i = 0; i < blocks.length; i++) {
            let events = blocks[i].events;
            for (let j = 0; j < events.length; j++) {
                let event = events[j];
                if (event.extrinsic) {
                    event.extrinsic = (0, util_1.assertNotNull)(extrinsics.get(event.extrinsic.id));
                }
            }
        }
        return blocks;
    }
    fetchBlocksWithEvmData(from, to, logs) {
        let args = {
            limit: this.limit,
            distinct_on: { $: 'block_id' },
            where: {
                block_id: {
                    _gte: String(from).padStart(10, '0'),
                    _lte: String(to).padStart(10, '0')
                },
                _or: []
            }
        };
        this.forEachEvmContract(logs, (contract, topics) => {
            args.where._or.push({
                contract_address: { _eq: contract },
                _or: (topics.length == 0 ? ['*'] : topics).map(topic => {
                    return {
                        topic: { _eq: topic }
                    };
                })
            });
        });
        let q = new util_1.Output();
        q.block('query', () => {
            q.block(`evm_log_idx(${printArguments(args)})`, () => {
                q.line('block_id');
            });
        });
        let gql = q.toString();
        return this.archiveRequest(gql);
    }
    /**
     * Collects the set of mentioned topics per contract.
     *
     * If there is a handler without any topic restriction the resulting set will be empty.
     * Otherwise, every topic mentioned in any restriction will be included in the resulting set.
     *
     * The ingester will fetch every evm.Log event which includes any mentioned topic (regardless it's position).
     * This is a lame procedure, we'll rework it when new archive will be ready.
     */
    forEachEvmContract(logs, cb) {
        for (let contract in logs) {
            let topics = [];
            for (let h of logs[contract]) {
                if (h.filter == null) {
                    return cb(contract, []);
                }
                let allEmpty = true;
                for (let set of h.filter) {
                    if (set == null || Array.isArray(set) && set.length == 0) {
                        continue;
                    }
                    allEmpty = false;
                    if (Array.isArray(set)) {
                        topics.push(...set);
                    }
                    else {
                        topics.push(set);
                    }
                }
                if (allEmpty) {
                    return cb(contract, []);
                }
            }
            cb(contract, (0, misc_1.unique)(topics));
        }
    }
    async waitForHeight(minimumHeight) {
        while (this.archiveHeight < minimumHeight) {
            await this.fetchArchiveHeight();
            if (this.archiveHeight >= minimumHeight) {
                return this.archiveHeight;
            }
            else {
                await (0, async_1.wait)(this.options.archivePollIntervalMS || 5000, this._abort);
            }
        }
        return this.archiveHeight;
    }
    async fetchArchiveHeight() {
        let res = await this.archiveRequest(`
            query {
                indexerStatus {
                    head
                }
            }
        `);
        this.setArchiveHeight(res);
        return this.archiveHeight;
    }
    setArchiveHeight(res) {
        let height = res.indexerStatus.head;
        this.archiveHeight = Math.max(this.archiveHeight, height);
        this.options.metrics?.setChainHeight(this.archiveHeight);
    }
    async archiveRequest(query) {
        let response = await (0, node_fetch_1.default)(this.options.archive, {
            method: 'POST',
            body: JSON.stringify({ query }),
            headers: {
                'content-type': 'application/json',
                'accept': 'application/json',
                'accept-encoding': 'gzip, br'
            }
        });
        if (!response.ok) {
            let body = await response.text();
            throw new Error(`Got http ${response.status}${body ? `, body: ${body}` : ''}`);
        }
        let result = await response.json();
        if (result.errors?.length) {
            throw new Error(`GraphQL error: ${result.errors[0].message}`);
        }
        return (0, util_1.assertNotNull)(result.data);
    }
}
exports.Ingest = Ingest;
function printArguments(args) {
    let exp = _printArguments(args);
    (0, assert_1.default)(exp[0] == '{' && exp[exp.length - 1] == '}');
    return exp.slice(1, exp.length - 1);
}
function _printArguments(args) {
    if (args == null)
        return '';
    switch (typeof args) {
        case 'string':
            return `"${args}"`;
        case 'number':
            return '' + args;
        case 'object':
            if (Array.isArray(args)) {
                return `[${args.map(i => _printArguments(i)).filter(e => !!e).join(', ')}]`;
            }
            else if (args.$) {
                return args.$;
            }
            else {
                let fields = [];
                collectFields(args, fields);
                return fields.length ? `{${fields.join(', ')}}` : '';
            }
        default:
            throw (0, util_1.unexpectedCase)(typeof args);
    }
}
function collectFields(obj, fields) {
    for (let field in obj) {
        let val = obj[field];
        if (field == '_or') {
            (0, assert_1.default)(Array.isArray(val));
            collectOrExpressions(val, fields);
        }
        else {
            let exp = _printArguments(val);
            if (exp) {
                fields.push(`${field}: ${exp}`);
            }
        }
    }
}
function collectOrExpressions(or, fields) {
    switch (or.length) {
        case 0:
            return;
        case 1:
            return collectFields(or[0], fields);
        default:
            fields.push(`_or: ${_printArguments(or)}`);
    }
}
//# sourceMappingURL=ingest.js.map