import { OldTypesBundle } from "@subsquid/substrate-metadata";
import { IsolationLevel } from "./db";
import type { BlockHandler, EventHandler, ExtrinsicHandler } from "./interfaces/handlerContext";
import { Hooks } from "./interfaces/hooks";
import { QualifiedName } from "./interfaces/substrate";
import { Range } from "./util/range";
export interface BlockHookOptions {
    /**
     * Inclusive range of blocks for which the block hook is effective.
     */
    range?: Range;
}
export interface EventHandlerOptions {
    /**
     * Inclusive range of blocks for which the event handler is effective.
     */
    range?: Range;
}
export interface ExtrinsicHandlerOptions {
    /**
     * Inclusive range of blocks for which the extrinsic handler is effective.
     */
    range?: Range;
    /**
     * A set of trigger events.
     *
     * The extrinsic handler is triggered on any event from the list.
     * For more details see {@link SubstrateProcessor.addExtrinsicHandler}.
     */
    triggerEvents?: QualifiedName[];
}
export interface DataSource {
    /**
     * Archive endpoint URL
     */
    archive: string;
    /**
     * Chain node RPC websocket URL
     */
    chain: string;
}
/**
 * Provides methods to configure and launch data processing.
 */
export declare class SubstrateProcessor {
    private name;
    protected hooks: Hooks;
    private blockRange;
    private batchSize;
    private prometheusPort?;
    private src?;
    private typesBundle?;
    private isolationLevel?;
    private running;
    /**
     * @param name Defines prefix for a name of database schema
     * under which the processor will keep its state.
     */
    constructor(name: string);
    /**
     * Sets blockchain data source.
     *
     * Currently, requires both chain node RPC WS endpoint and archive gateway.
     *
     * @example
     * processor.setDataSource({
     *     chain: 'wss://rpc.polkadot.io',
     *     archive: 'https://polkadot.indexer.gc.subsquid.io/v4/graphql'
     * })
     */
    setDataSource(src: DataSource): void;
    /**
     * Sets types bundle.
     *
     * Types bundle is only required for blocks which have
     * metadata version below 14.
     *
     * Don't confuse this setting with types bundle from polkadot.js.
     * Although those two are similar in purpose and structure,
     * they are not compatible.
     *
     * Types bundle can be specified in 3 different ways:
     *
     * 1. as a name of a known chain
     * 2. as a name of a JSON file structured as {@link OldTypesBundle}
     * 3. as an {@link OldTypesBundle} object
     *
     * @example
     * // known chain
     * processor.setTypesBundle('kusama')
     *
     * // A path to a JSON file resolved relative to `cwd`.
     * processor.setTypesBundle('typesBundle.json')
     *
     * // OldTypesBundle object
     * processor.setTypesBundle({
     *     types: {
     *         Foo: 'u8'
     *     }
     * })
     */
    setTypesBundle(bundle: string | OldTypesBundle): void;
    /**
     * Limits the range of blocks to be processed.
     *
     * When the upper bound is specified,
     * the processor will terminate with exit code 0 once it reaches it.
     *
     * @example
     * // process only block 100
     * processor.setBlockRange({
     *     from: 100,
     *     to: 100
     * })
     */
    setBlockRange(range: Range): void;
    /**
     * Sets the maximum number of blocks which can be fetched
     * from the data source in a single request.
     *
     * The default is 100.
     *
     * Usually this setting doesn't have any significant impact on the performance.
     */
    setBatchSize(size: number): void;
    /**
     * Sets the port for a built-in prometheus metrics server.
     *
     * By default, the value of `PROMETHEUS_PORT` environment
     * variable is used. When it is not set,
     * the processor will pick up an ephemeral port.
     */
    setPrometheusPort(port: number | string): void;
    /**
     * Sets the isolation level for database transactions
     * in which data handlers are executed.
     *
     * Defaults to `SERIALIZABLE`.
     *
     * This setting is for complex scenarios when
     * there are another database writers beside the processor.
     *
     * Note, that altering this setting can easily lead to "hard to debug"
     * consistency issues.
     */
    setIsolationLevel(isolationLevel?: IsolationLevel): void;
    private getPrometheusPort;
    /**
     * Registers a block level data handler which will be executed before
     * any further processing.
     *
     * See {@link BlockHandlerContext} for an API available to the handler.
     *
     * Block level handlers affect performance, as they are
     * triggered for all chain blocks. If no block hooks are defined,
     * only blocks that'd trigger a handler execution will be fetched,
     * which is usually a lot faster.
     *
     * Relative execution order for multiple pre-block hooks is currently not defined.
     *
     * @example
     * processor.addPreHook(async ctx => {
     *     console.log(ctx.block.height)
     * })
     *
     * // limit the range of blocks for which pre-block hook will be effective
     * processor.addPreHook({range: {from: 100000}}, async ctx => {})
     */
    addPreHook(fn: BlockHandler): void;
    addPreHook(options: BlockHookOptions, fn: BlockHandler): void;
    /**
     * Registers a block level data handler which will be executed
     * at the end of processing.
     *
     * See {@link BlockHandlerContext} for an API available to the handler.
     *
     * Block level handlers affect performance, as they are
     * triggered for all chain blocks. If no block hooks are defined,
     * only blocks that'd trigger a handler execution will be fetched,
     * which is usually a lot faster.
     *
     * Relative execution order for multiple post-block hooks is currently not defined.
     *
     * @example
     * processor.addPostHook(async ctx => {
     *     console.log(ctx.block.height)
     * })
     *
     * // limit the range of blocks for which post-block hook will be effective
     * processor.addPostHook({range: {from: 100000}}, async ctx => {})
     */
    addPostHook(fn: BlockHandler): void;
    addPostHook(options: BlockHookOptions, fn: BlockHandler): void;
    /**
     * Registers an event data handler.
     *
     * See {@link EventHandlerContext} for an API available to the handler.
     *
     * All events are processed sequentially according to the event log of the current block.
     *
     * Relative execution order is currently not defined for multiple event handlers
     * registered for the same event.
     *
     * @example
     * processor.addEventHandler('balances.Transfer', async ctx => {
     *     assert(ctx.event.name == 'balances.Transfer')
     * })
     *
     * // limit the range of blocks for which event handler will be effective
     * processor.addEventHandler('balances.Transfer', {
     *     range: {from: 100000}
     * }, async ctx => {
     *     assert(ctx.event.name == 'balances.Transfer')
     * })
     */
    addEventHandler(eventName: QualifiedName, fn: EventHandler): void;
    addEventHandler(eventName: QualifiedName, options: EventHandlerOptions, fn: EventHandler): void;
    /**
     * Registers extrinsic data handler.
     *
     * See {@link ExtrinsicHandlerContext} for an API available to the handler.
     *
     * Extrinsic handlers are triggered following the relative order
     * of trigger event in the event log of the current block.
     * This defines a deterministic canonical ordering
     * of how all the event and extrinsic handlers are executed within a single block.
     *
     * The set of possible trigger events is customizable and defaults to `['system.ExtrinsicSuccess']`.
     * Which means, by default extrinsic handler will be executed after all events of the same extrinsic
     * and only if it was successful.
     *
     * Relative execution order is currently not defined for multiple extrinsic handlers
     * registered for the same extrinsic and trigger events.
     *
     * @example
     * processor.addExtrinsicHandler('balances.transfer', async ctx => {
     *     assert(ctx.extrinsic.name == 'balances.transfer')
     * })
     *
     * // limit the range of blocks for which extrinsic handler will be effective
     * processor.addExtrinsicHandler('balances.transfer', {
     *     range: {from: 100000}
     * }, async ctx => {
     *     assert(ctx.extrinsic.name == 'balances.transfer')
     * })
     *
     * // handle both successful and failed extrinsics
     * processor.addExtrinsicHandler('balances.transfer', {
     *     triggerEvents: ['system.ExtrinsicSuccess', 'system.ExtrinsicFailed']
     * }, async ctx => {
     *     if (ctx.event.name == 'system.ExtrinsicSuccess') {
     *         console.log('successful')
     *     } else {
     *         console.log('failed')
     *     }
     * })
     */
    addExtrinsicHandler(extrinsicName: QualifiedName, fn: ExtrinsicHandler): void;
    addExtrinsicHandler(extrinsicName: QualifiedName, options: ExtrinsicHandlerOptions, fn: ExtrinsicHandler): void;
    protected assertNotRunning(): void;
    /**
     * Starts data processing.
     *
     * This method assumes full control over the current OS process as
     * it terminates the entire program in case of error or
     * at the end of data processing.
     */
    run(): void;
    private _run;
    private process;
    private getEvmLogHandlers;
    private evmHandlerMatches;
}
//# sourceMappingURL=processor.d.ts.map