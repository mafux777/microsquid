"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBlocksCount = exports.mergeBatches = exports.createBatches = void 0;
const util_1 = require("@subsquid/util");
const heap_1 = require("./util/heap");
const range_1 = require("./util/range");
function createBatches(hooks, blockRange) {
    let batches = [];
    function getRange(hook) {
        let range = hook.range || { from: 0 };
        if (blockRange) {
            range = (0, range_1.rangeIntersection)(range, blockRange);
        }
        return range;
    }
    hooks.pre.forEach(hook => {
        let range = getRange(hook);
        if (!range)
            return;
        batches.push({
            range,
            handlers: {
                pre: [hook.handler],
                post: [],
                events: {},
                extrinsics: {},
                evmLogs: {}
            }
        });
    });
    hooks.post.forEach(hook => {
        let range = getRange(hook);
        if (!range)
            return;
        batches.push({
            range,
            handlers: {
                pre: [],
                post: [hook.handler],
                events: {},
                extrinsics: {},
                evmLogs: {}
            }
        });
    });
    hooks.event.forEach(hook => {
        let range = getRange(hook);
        if (!range)
            return;
        batches.push({
            range,
            handlers: {
                pre: [],
                post: [],
                events: {
                    [hook.event]: [hook.handler]
                },
                extrinsics: {},
                evmLogs: {}
            }
        });
    });
    hooks.extrinsic.forEach(hook => {
        let range = getRange(hook);
        if (!range)
            return;
        batches.push({
            range,
            handlers: {
                pre: [],
                post: [],
                events: {},
                extrinsics: {
                    [hook.event]: { [hook.extrinsic]: [hook.handler] }
                },
                evmLogs: {}
            }
        });
    });
    hooks.evmLog.forEach(hook => {
        let range = getRange(hook);
        if (!range)
            return;
        batches.push({
            range,
            handlers: {
                pre: [],
                post: [],
                events: {},
                extrinsics: {},
                evmLogs: {
                    [hook.contractAddress]: [{
                            filter: hook.filter,
                            handler: hook.handler
                        }]
                }
            }
        });
    });
    batches = mergeBatches(batches);
    return batches;
}
exports.createBatches = createBatches;
function mergeBatches(batches) {
    if (batches.length <= 1)
        return batches;
    let union = [];
    let heap = new heap_1.Heap((a, b) => a.range.from - b.range.from);
    heap.init(batches.slice());
    let top = (0, util_1.assertNotNull)(heap.pop());
    let batch;
    while (batch = heap.peek()) {
        let i = (0, range_1.rangeIntersection)(top.range, batch.range);
        if (i == null) {
            union.push(top);
            top = (0, util_1.assertNotNull)(heap.pop());
        }
        else {
            heap.pop();
            (0, range_1.rangeDifference)(top.range, i).forEach(range => {
                heap.push({ range, handlers: top.handlers });
            });
            (0, range_1.rangeDifference)(batch.range, i).forEach(range => {
                heap.push({ range, handlers: batch.handlers });
            });
            heap.push({
                range: i,
                handlers: mergeDataHandlers(top.handlers, batch.handlers)
            });
            top = (0, util_1.assertNotNull)(heap.pop());
        }
    }
    union.push(top);
    return union;
}
exports.mergeBatches = mergeBatches;
function mergeDataHandlers(a, b) {
    return {
        pre: a.pre.concat(b.pre),
        post: a.post.concat(b.post),
        events: mergeMaps(a.events, b.events, (ha, hb) => ha.concat(hb)),
        extrinsics: mergeMaps(a.extrinsics, b.extrinsics, (ea, eb) => {
            return mergeMaps(ea, eb, (ha, hb) => ha.concat(hb));
        }),
        evmLogs: mergeMaps(a.evmLogs, b.evmLogs, (ha, hb) => ha.concat(hb)),
    };
}
function mergeMaps(a, b, mergeItems) {
    let result = {};
    for (let key in a) {
        if (b[key] == null) {
            result[key] = a[key];
        }
        else {
            result[key] = mergeItems(a[key], b[key]);
        }
    }
    for (let key in b) {
        if (result[key] == null) {
            result[key] = b[key];
        }
    }
    return result;
}
function getBlocksCount(batches, chainHeight) {
    let count = 0;
    for (let i = 0; i < batches.length; i++) {
        let range = batches[i].range;
        if (chainHeight < range.from)
            return count;
        let to = Math.min(chainHeight, range.to ?? Infinity);
        count += to - range.from + 1;
    }
    return count;
}
exports.getBlocksCount = getBlocksCount;
//# sourceMappingURL=batch.js.map