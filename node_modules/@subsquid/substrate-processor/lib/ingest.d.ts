import { Batch } from "./batch";
import { SubstrateBlock, SubstrateEvent } from "./interfaces/substrate";
export interface BlockData {
    block: SubstrateBlock;
    events: SubstrateEvent[];
}
export interface DataBatch extends Batch {
    /**
     * This is roughly the range of scanned blocks
     */
    range: {
        from: number;
        to: number;
    };
    blocks: BlockData[];
}
export interface IngestMetrics {
    setChainHeight(height: number): void;
    setIngestSpeed(blocksPerSecond: number): void;
}
export interface IngestOptions {
    archive: string;
    archivePollIntervalMS?: number;
    /**
     * Mutable array of batches to ingest.
     *
     * Ingest will shift elements and modify the range of a head branch.
     */
    batches$: Batch[];
    batchSize: number;
    metrics?: IngestMetrics;
}
export declare class Ingest {
    private options;
    private out;
    private _abort;
    private archiveHeight;
    private readonly limit;
    private readonly batches;
    private readonly ingestion;
    constructor(options: IngestOptions);
    nextBatch(): Promise<DataBatch | null>;
    close(): Promise<Error | void>;
    private run;
    private loop;
    private batchFetch;
    private joinExtrinsicsAndDoPostProcessing;
    private fetchBlocksWithEvmData;
    /**
     * Collects the set of mentioned topics per contract.
     *
     * If there is a handler without any topic restriction the resulting set will be empty.
     * Otherwise, every topic mentioned in any restriction will be included in the resulting set.
     *
     * The ingester will fetch every evm.Log event which includes any mentioned topic (regardless it's position).
     * This is a lame procedure, we'll rework it when new archive will be ready.
     */
    private forEachEvmContract;
    private waitForHeight;
    private fetchArchiveHeight;
    private setArchiveHeight;
    private archiveRequest;
}
//# sourceMappingURL=ingest.d.ts.map