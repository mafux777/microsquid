"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubstrateProcessor = void 0;
const resilient_1 = require("@subsquid/rpc-client/lib/resilient");
const substrate_metadata_1 = require("@subsquid/substrate-metadata");
const util_1 = require("@subsquid/util");
const assert_1 = __importDefault(require("assert"));
const batch_1 = require("./batch");
const chain_1 = require("./chain");
const db_1 = require("./db");
const ingest_1 = require("./ingest");
const progress_tracker_1 = require("./progress-tracker");
const prometheus_1 = require("./prometheus");
const misc_1 = require("./util/misc");
const sm_1 = require("./util/sm");
/**
 * Provides methods to configure and launch data processing.
 */
class SubstrateProcessor {
    /**
     * @param name Defines prefix for a name of database schema
     * under which the processor will keep its state.
     */
    constructor(name) {
        this.name = name;
        this.hooks = { pre: [], post: [], event: [], extrinsic: [], evmLog: [] };
        this.blockRange = { from: 0 };
        this.batchSize = 100;
        this.running = false;
    }
    /**
     * Sets blockchain data source.
     *
     * Currently, requires both chain node RPC WS endpoint and archive gateway.
     *
     * @example
     * processor.setDataSource({
     *     chain: 'wss://rpc.polkadot.io',
     *     archive: 'https://polkadot.indexer.gc.subsquid.io/v4/graphql'
     * })
     */
    setDataSource(src) {
        this.assertNotRunning();
        this.src = src;
    }
    /**
     * Sets types bundle.
     *
     * Types bundle is only required for blocks which have
     * metadata version below 14.
     *
     * Don't confuse this setting with types bundle from polkadot.js.
     * Although those two are similar in purpose and structure,
     * they are not compatible.
     *
     * Types bundle can be specified in 3 different ways:
     *
     * 1. as a name of a known chain
     * 2. as a name of a JSON file structured as {@link OldTypesBundle}
     * 3. as an {@link OldTypesBundle} object
     *
     * @example
     * // known chain
     * processor.setTypesBundle('kusama')
     *
     * // A path to a JSON file resolved relative to `cwd`.
     * processor.setTypesBundle('typesBundle.json')
     *
     * // OldTypesBundle object
     * processor.setTypesBundle({
     *     types: {
     *         Foo: 'u8'
     *     }
     * })
     */
    setTypesBundle(bundle) {
        this.assertNotRunning();
        if (typeof bundle == 'string') {
            this.typesBundle = (0, substrate_metadata_1.getOldTypesBundle)(bundle) || (0, substrate_metadata_1.readOldTypesBundle)(bundle);
        }
        else {
            this.typesBundle = bundle;
        }
    }
    /**
     * Limits the range of blocks to be processed.
     *
     * When the upper bound is specified,
     * the processor will terminate with exit code 0 once it reaches it.
     *
     * @example
     * // process only block 100
     * processor.setBlockRange({
     *     from: 100,
     *     to: 100
     * })
     */
    setBlockRange(range) {
        this.assertNotRunning();
        this.blockRange = range;
    }
    /**
     * Sets the maximum number of blocks which can be fetched
     * from the data source in a single request.
     *
     * The default is 100.
     *
     * Usually this setting doesn't have any significant impact on the performance.
     */
    setBatchSize(size) {
        this.assertNotRunning();
        (0, assert_1.default)(size > 0);
        this.batchSize = size;
    }
    /**
     * Sets the port for a built-in prometheus metrics server.
     *
     * By default, the value of `PROMETHEUS_PORT` environment
     * variable is used. When it is not set,
     * the processor will pick up an ephemeral port.
     */
    setPrometheusPort(port) {
        this.assertNotRunning();
        this.prometheusPort = port;
    }
    /**
     * Sets the isolation level for database transactions
     * in which data handlers are executed.
     *
     * Defaults to `SERIALIZABLE`.
     *
     * This setting is for complex scenarios when
     * there are another database writers beside the processor.
     *
     * Note, that altering this setting can easily lead to "hard to debug"
     * consistency issues.
     */
    setIsolationLevel(isolationLevel) {
        this.assertNotRunning();
        this.isolationLevel = isolationLevel;
    }
    getPrometheusPort() {
        return this.prometheusPort == null
            ? process.env.PROCESSOR_PROMETHEUS_PORT || process.env.PROMETHEUS_PORT || 0
            : this.prometheusPort;
    }
    addPreHook(fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions == 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_1.assertNotNull)(fn);
            options = fnOrOptions;
        }
        this.hooks.pre.push({ handler, ...options });
    }
    addPostHook(fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions == 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_1.assertNotNull)(fn);
            options = fnOrOptions;
        }
        this.hooks.post.push({ handler, ...options });
    }
    addEventHandler(eventName, fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions === 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_1.assertNotNull)(fn);
            options = fnOrOptions;
        }
        this.hooks.event.push({
            event: eventName,
            handler,
            ...options
        });
    }
    addExtrinsicHandler(extrinsicName, fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions == 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_1.assertNotNull)(fn);
            options = { ...fnOrOptions };
        }
        let triggers = options.triggerEvents || ['system.ExtrinsicSuccess'];
        new Set(triggers).forEach(event => {
            this.hooks.extrinsic.push({
                event,
                handler,
                extrinsic: extrinsicName.split('.').map(n => (0, util_1.toCamelCase)(n)).join('.'),
                range: options.range
            });
        });
    }
    assertNotRunning() {
        if (this.running) {
            throw new Error('Settings modifications are not allowed after start of processing');
        }
    }
    /**
     * Starts data processing.
     *
     * This method assumes full control over the current OS process as
     * it terminates the entire program in case of error or
     * at the end of data processing.
     */
    run() {
        if (this.running)
            return;
        this.running = true;
        sm_1.ServiceManager.run(sm => this._run(sm));
    }
    async _run(sm) {
        let prometheus = new prometheus_1.Prometheus();
        let prometheusServer = sm.add(await prometheus.serve(this.getPrometheusPort()));
        console.log(`Prometheus metrics are served at port ${prometheusServer.port}`);
        let db = sm.add(await db_1.Db.connect({
            processorName: this.name,
            isolationLevel: this.isolationLevel
        }));
        let { height: heightAtStart } = await db.init();
        prometheus.setLastProcessedBlock(heightAtStart);
        let blockRange = this.blockRange;
        if (blockRange.to != null && blockRange.to < heightAtStart + 1) {
            return;
        }
        else {
            blockRange = {
                from: Math.max(heightAtStart + 1, blockRange.from),
                to: blockRange.to
            };
        }
        let batches = (0, batch_1.createBatches)(this.hooks, blockRange);
        let ingest = sm.add(new ingest_1.Ingest({
            archive: (0, util_1.assertNotNull)(this.src?.archive, 'use .setDataSource() to specify archive url'),
            batches$: batches,
            batchSize: this.batchSize,
            metrics: prometheus
        }));
        let client = sm.add(new resilient_1.ResilientRpcClient((0, util_1.assertNotNull)(this.src?.chain, 'use .setDataSource() to specify chain RPC endpoint')));
        let wholeRange = (0, batch_1.createBatches)(this.hooks, this.blockRange);
        let progress = new progress_tracker_1.ProgressTracker((0, batch_1.getBlocksCount)(wholeRange, heightAtStart), wholeRange, prometheus);
        await this.process(ingest, new chain_1.ChainManager(client, this.typesBundle), db, prometheus, progress);
    }
    async process(ingest, chainManager, db, prom, progress) {
        let batch;
        let lastBlock = -1;
        while (batch = await ingest.nextBatch()) {
            let { handlers, blocks, range } = batch;
            let beg = blocks.length > 0 ? process.hrtime.bigint() : 0n;
            for (let block of blocks) {
                (0, assert_1.default)(lastBlock < block.block.height);
                let chain = await chainManager.getChainForBlock(block.block);
                await db.transact(block.block.height, async (store) => {
                    let ctx = {
                        _chain: chain,
                        store,
                        ...block
                    };
                    for (let pre of handlers.pre) {
                        await pre(ctx);
                    }
                    for (let event of block.events) {
                        let extrinsic = event.extrinsic;
                        for (let eventHandler of handlers.events[event.name] || []) {
                            await eventHandler({ ...ctx, event, extrinsic });
                        }
                        for (let evmLogHandler of this.getEvmLogHandlers(handlers.evmLogs, event)) {
                            let log = event;
                            await evmLogHandler({
                                contractAddress: log.evmLogAddress,
                                topics: log.evmLogTopics,
                                data: log.evmLogData,
                                txHash: log.evmHash,
                                substrate: { ...ctx, event, extrinsic },
                                store
                            });
                        }
                        if (extrinsic == null)
                            continue;
                        for (let callHandler of handlers.extrinsics[event.name]?.[extrinsic.name] || []) {
                            await callHandler({ ...ctx, event, extrinsic });
                        }
                    }
                    for (let post of handlers.post) {
                        await post(ctx);
                    }
                });
                lastBlock = block.block.height;
                prom.setLastProcessedBlock(lastBlock);
            }
            if (lastBlock < range.to) {
                lastBlock = range.to;
                await db.setHeight(lastBlock);
                prom.setLastProcessedBlock(lastBlock);
            }
            let end = process.hrtime.bigint();
            progress.batch(end, batch);
            let status = [];
            status.push(`Last block: ${lastBlock}`);
            if (blocks.length > 0) {
                let speed = blocks.length * Math.pow(10, 9) / Number(end - beg);
                let roundedSpeed = Math.round(speed);
                status.push(`mapping: ${roundedSpeed} blocks/sec`);
                prom.setMappingSpeed(speed);
            }
            status.push(`ingest: ${Math.round(prom.getIngestSpeed())} blocks/sec`);
            status.push(`eta: ${(0, misc_1.timeInterval)(progress.getSyncEtaSeconds())}`);
            status.push(`progress: ${Math.round(progress.getSyncRatio() * 100)}%`);
            console.log(status.join(', '));
        }
    }
    *getEvmLogHandlers(evmLogs, event) {
        if (event.name != 'evm.Log')
            return;
        let log = event;
        let contractHandlers = evmLogs[log.evmLogAddress];
        if (contractHandlers == null)
            return;
        for (let h of contractHandlers) {
            if (this.evmHandlerMatches(h, log)) {
                yield h.handler;
            }
        }
    }
    evmHandlerMatches(handler, log) {
        if (handler.filter == null)
            return true;
        for (let i = 0; i < handler.filter.length; i++) {
            let set = handler.filter[i];
            if (set == null)
                continue;
            if (Array.isArray(set) && !set.includes(log.evmLogTopics[i])) {
                return false;
            }
            else if (set !== log.evmLogTopics[i]) {
                return false;
            }
        }
        return true;
    }
}
exports.SubstrateProcessor = SubstrateProcessor;
//# sourceMappingURL=processor.js.map