"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chain = exports.ChainManager = void 0;
const scale_codec_1 = require("@subsquid/scale-codec");
const scale_codec_json_1 = require("@subsquid/scale-codec-json");
const util_1 = require("@subsquid/scale-codec/lib/util");
const substrate_metadata_1 = require("@subsquid/substrate-metadata");
const eac = __importStar(require("@subsquid/substrate-metadata/lib/events-and-calls"));
const typesBundle_1 = require("@subsquid/substrate-metadata/lib/old/typesBundle");
const storage_1 = require("@subsquid/substrate-metadata/lib/storage");
const util_2 = require("@subsquid/util");
const assert_1 = __importDefault(require("assert"));
const sto = __importStar(require("./util/storage"));
class ChainManager {
    constructor(client, typesBundle) {
        this.client = client;
        this.typesBundle = typesBundle;
        this.versions = new Map();
    }
    async getChainForBlock(block) {
        let specVersion = typeof block.runtimeVersion == 'number'
            ? block.runtimeVersion
            : block.runtimeVersion.specVersion;
        let v = this.versions.get(specVersion);
        if (v != null && v.height < block.height)
            return v.chain;
        let height = Math.max(0, block.height - 1);
        let hash = height > 0 ? block.parentHash : block.hash;
        let rtv = await this.client.call('chain_getRuntimeVersion', [hash]);
        v = this.versions.get(rtv.specVersion);
        if (v == null) {
            let metadataHex = await this.client.call('state_getMetadata', [hash]);
            v = this.versions.get(rtv.specVersion); // perhaps it was fetched
            if (v == null) {
                let chain = this.createChain(rtv, metadataHex);
                v = { chain, height };
                this.versions.set(rtv.specVersion, v);
            }
        }
        v.height = Math.min(v.height, height);
        return v.chain;
    }
    createChain(rtv, metadataHex) {
        let metadata = (0, substrate_metadata_1.decodeMetadata)(metadataHex);
        let types;
        if (parseInt(metadata.__kind.slice(1)) < 14) {
            let typesBundle = (0, util_2.assertNotNull)(this.typesBundle || (0, substrate_metadata_1.getOldTypesBundle)(rtv.specName), `types bundle is required for ${rtv.specName} chain`);
            types = (0, typesBundle_1.getTypesFromBundle)(typesBundle, rtv.specVersion);
        }
        let description = (0, substrate_metadata_1.getChainDescriptionFromMetadata)(metadata, types);
        return new Chain(description, this.client);
    }
}
exports.ChainManager = ChainManager;
class Chain {
    constructor(description, client) {
        this.description = description;
        this.client = client;
        this.storageHash = Symbol('storage_hash');
        this.jsonCodec = new scale_codec_json_1.Codec(description.types);
        this.scaleCodec = new scale_codec_1.Codec(description.types);
        this.events = new eac.Registry(description.types, description.event);
        this.calls = new eac.Registry(description.types, description.call, true);
    }
    getEventHash(eventName) {
        return this.events.getHash(eventName);
    }
    getCallHash(callName) {
        return this.calls.getHash(callName);
    }
    decodeEvent(event) {
        let def = this.events.get(event.name);
        return this.decode(def, event.params);
    }
    decodeCall(call) {
        let def = this.calls.get(call.name);
        return this.decode(def, call.args);
    }
    decode(def, args) {
        if (def.fields.length == 0)
            return undefined;
        if (def.fields[0].name == null)
            return this.decodeTuple(def.fields, args);
        let result = {};
        for (let i = 0; i < def.fields.length; i++) {
            let f = def.fields[i];
            let name = (0, util_2.assertNotNull)(f.name);
            result[name] = this.jsonCodec.decode(f.type, args[i].value);
        }
        return result;
    }
    decodeTuple(fields, values) {
        if (fields.length == 1) {
            return this.jsonCodec.decode(fields[0].type, values[0].value);
        }
        else {
            (0, assert_1.default)(fields.length == values.length, 'invalid event data');
            let result = new Array(fields.length);
            for (let i = 0; i < fields.length; i++) {
                result[i] = this.jsonCodec.decode(fields[i].type, values[i].value);
            }
            return result;
        }
    }
    async getStorage(blockHash, prefix, name, ...keys) {
        let item = this.getStorageItem(prefix, name);
        (0, assert_1.default)(item.keys.length === keys.length);
        let req = sto.getNameHash(prefix) + sto.getNameHash(name).slice(2);
        for (let i = 0; i < keys.length; i++) {
            req += sto.getKeyHash(item.hashers[i], this.scaleCodec.encodeToBinary(item.keys[i], keys[i])).slice(2);
        }
        let res = await this.client.call('state_getStorageAt', [req, blockHash]);
        if (res == null) {
            switch (item.modifier) {
                case 'Optional':
                    return undefined;
                case 'Default':
                    res = item.fallback;
                    break;
                case 'Required':
                    throw new Error(`Required storage item not found`);
                default:
                    (0, util_1.throwUnexpectedCase)(item.modifier);
            }
        }
        return this.scaleCodec.decodeBinary(item.value, res);
    }
    getStorageItem(prefix, name) {
        let items = this.description.storage[prefix];
        if (items == null)
            throw new Error(`There are no storage items under prefix ${prefix}`);
        let def = items[name];
        if (def == null)
            throw new Error(`Unknown storage item: ${prefix}.${name}`);
        return def;
    }
    getStorageItemTypeHash(prefix, name) {
        let item = this.description.storage[prefix]?.[name];
        if (item == null)
            return undefined;
        let hash = item[this.storageHash];
        if (hash == null) {
            hash = item[this.storageHash] = (0, storage_1.getStorageItemTypeHash)(this.description.types, item);
        }
        return hash;
    }
}
exports.Chain = Chain;
//# sourceMappingURL=chain.js.map