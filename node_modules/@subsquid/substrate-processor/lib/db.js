"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Db = void 0;
const typeorm_config_1 = require("@subsquid/typeorm-config");
const assert_1 = __importDefault(require("assert"));
const typeorm_1 = require("typeorm");
class Db {
    constructor(con, options) {
        this.con = con;
        this.maxTxAttempts = 3;
        this.isolationLevel = options.isolationLevel || 'SERIALIZABLE';
        this.statusSchema = `"${options.processorName}_status"`;
    }
    static async connect(options) {
        let cfg = (0, typeorm_config_1.createOrmConfig)();
        let con = await (0, typeorm_1.createConnection)(cfg);
        return new Db(con, options);
    }
    init() {
        return this.con.transaction('SERIALIZABLE', async (em) => {
            await em.query(`CREATE SCHEMA IF NOT EXISTS ${this.statusSchema}`);
            await em.query(`
              CREATE TABLE IF NOT EXISTS ${this.statusSchema}."status" (
                id int4 primary key,
                height int4 not null
              )
            `);
            let status = await em.query(`SELECT height FROM ${this.statusSchema}.status WHERE id = 0`);
            if (status.length == 0) {
                await em.query(`INSERT INTO ${this.statusSchema}.status (id, height) VALUES (0, -1)`);
                return { height: -1 };
            }
            else {
                return status[0];
            }
        });
    }
    async tx(cb, attempt = 1) {
        try {
            await this.con.transaction(this.isolationLevel, cb);
            return attempt;
        }
        catch (e) {
            if (e.code == '40001' && attempt < this.maxTxAttempts) {
                return this.tx(cb, attempt + 1);
            }
            else {
                throw e;
            }
        }
    }
    transact(blockNumber, cb) {
        return this.tx(async (em) => {
            let status = await em.query(`SELECT height FROM ${this.statusSchema}.status`);
            (0, assert_1.default)(status.length == 1);
            (0, assert_1.default)(status[0].height < blockNumber);
            let store = em;
            store.get = function (entityClass, cond) {
                if (typeof cond == 'string') {
                    return this.findOne(entityClass, { where: { id: cond } });
                }
                else {
                    return this.findOne(entityClass, cond);
                }
            };
            await cb(store);
            await em.query(`UPDATE ${this.statusSchema}.status SET height = $1`, [blockNumber]);
        });
    }
    async setHeight(blockNumber) {
        await this.con.query(`UPDATE ${this.statusSchema}.status SET height = $1 WHERE height < $1`, [blockNumber]);
        // TODO: update assertion
    }
    close() {
        return this.con.close();
    }
}
exports.Db = Db;
//# sourceMappingURL=db.js.map