"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha256 = exports.getTypeByPath = exports.normalizeMetadataTypes = void 0;
const util_1 = require("@subsquid/util");
const crypto_1 = __importDefault(require("crypto"));
const types_1 = require("./types");
function normalizeMetadataTypes(types) {
    return types.map(type => {
        switch (type.kind) {
            case types_1.TypeKind.Composite:
                return {
                    ...type,
                    fields: normalizeFieldNames(type.fields)
                };
            case types_1.TypeKind.Variant:
                if (isOptionType(type)) {
                    return {
                        kind: types_1.TypeKind.Option,
                        type: type.variants[1].fields[0].type,
                        docs: type.docs,
                        path: type.path
                    };
                }
                else {
                    return {
                        ...type,
                        variants: type.variants.map(v => {
                            return {
                                ...v,
                                fields: normalizeFieldNames(v.fields)
                            };
                        })
                    };
                }
            default:
                return type;
        }
    });
}
exports.normalizeMetadataTypes = normalizeMetadataTypes;
function isOptionType(type) {
    if (type.kind !== types_1.TypeKind.Variant)
        return false;
    if (type.variants.length != 2)
        return false;
    let v0 = type.variants[0];
    let v1 = type.variants[1];
    return v0.name == 'None' &&
        v0.fields.length == 0 &&
        v0.index == 0 &&
        v1.name == 'Some' &&
        v1.index == 1 &&
        v1.fields.length == 1 &&
        v1.fields[0].name == null;
}
function normalizeFieldNames(fields) {
    return fields.map(f => {
        if (f.name) {
            let name = f.name;
            if (name.startsWith('r#')) {
                name = name.slice(2);
            }
            name = (0, util_1.toCamelCase)(name);
            return { ...f, name };
        }
        else {
            return f;
        }
    });
}
function getTypeByPath(types, path) {
    let idx = types.findIndex(type => {
        if (type.path?.length != path.length)
            return false;
        for (let i = 0; i < path.length; i++) {
            if (path[i] != type.path[i])
                return false;
        }
        return true;
    });
    if (idx < 0) {
        throw new Error(`Type ${path.join('::')} not found`);
    }
    return idx;
}
exports.getTypeByPath = getTypeByPath;
function sha256(obj) {
    let content = typeof obj == 'string' ? obj : JSON.stringify(obj);
    let hash = crypto_1.default.createHash('sha256');
    hash.update(content);
    return hash.digest().toString('hex');
}
exports.sha256 = sha256;
//# sourceMappingURL=util.js.map